{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DeviceList = void 0;\n\nvar _events = require(\"events\");\n\nvar _logger = require(\"../logger\");\n\nvar _deviceinfo = require(\"./deviceinfo\");\n\nvar _CrossSigning = require(\"./CrossSigning\");\n\nvar olmlib = _interopRequireWildcard(require(\"./olmlib\"));\n\nvar _indexeddbCryptoStore = require(\"./store/indexeddb-crypto-store\");\n\nvar _utils = require(\"../utils\");\n/*\nCopyright 2017 Vector Creations Ltd\nCopyright 2018, 2019 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * @module crypto/DeviceList\n *\n * Manages the list of other users' devices\n */\n\n/* State transition diagram for DeviceList._deviceTrackingStatus\n *\n *                                |\n *     stopTrackingDeviceList     V\n *   +---------------------> NOT_TRACKED\n *   |                            |\n *   +<--------------------+      | startTrackingDeviceList\n *   |                     |      V\n *   |   +-------------> PENDING_DOWNLOAD <--------------------+-+\n *   |   |                      ^ |                            | |\n *   |   | restart     download | |  start download            | | invalidateUserDeviceList\n *   |   | client        failed | |                            | |\n *   |   |                      | V                            | |\n *   |   +------------ DOWNLOAD_IN_PROGRESS -------------------+ |\n *   |                    |       |                              |\n *   +<-------------------+       |  download successful         |\n *   ^                            V                              |\n *   +----------------------- UP_TO_DATE ------------------------+\n */\n// constants for DeviceList._deviceTrackingStatus\n\n\nconst TRACKING_STATUS_NOT_TRACKED = 0;\nconst TRACKING_STATUS_PENDING_DOWNLOAD = 1;\nconst TRACKING_STATUS_DOWNLOAD_IN_PROGRESS = 2;\nconst TRACKING_STATUS_UP_TO_DATE = 3;\n/**\n * @alias module:crypto/DeviceList\n */\n\nclass DeviceList extends _events.EventEmitter {\n  constructor(baseApis, cryptoStore, olmDevice) {\n    super();\n    this._cryptoStore = cryptoStore; // userId -> {\n    //     deviceId -> {\n    //         [device info]\n    //     }\n    // }\n\n    this._devices = {}; // userId -> {\n    //     [key info]\n    // }\n\n    this._crossSigningInfo = {}; // map of identity keys to the user who owns it\n\n    this._userByIdentityKey = {}; // which users we are tracking device status for.\n    // userId -> TRACKING_STATUS_*\n\n    this._deviceTrackingStatus = {}; // loaded from storage in load()\n    // The 'next_batch' sync token at the point the data was writen,\n    // ie. a token representing the point immediately after the\n    // moment represented by the snapshot in the db.\n\n    this._syncToken = null;\n    this._serialiser = new DeviceListUpdateSerialiser(baseApis, olmDevice, this); // userId -> promise\n\n    this._keyDownloadsInProgressByUser = {}; // Set whenever changes are made other than setting the sync token\n\n    this._dirty = false; // Promise resolved when device data is saved\n\n    this._savePromise = null; // Function that resolves the save promise\n\n    this._resolveSavePromise = null; // The time the save is scheduled for\n\n    this._savePromiseTime = null; // The timer used to delay the save\n\n    this._saveTimer = null;\n  }\n  /**\n   * Load the device tracking state from storage\n   */\n\n\n  async load() {\n    await this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_DEVICE_DATA], txn => {\n      this._cryptoStore.getEndToEndDeviceData(txn, deviceData => {\n        this._devices = deviceData ? deviceData.devices : {}, this._crossSigningInfo = deviceData ? deviceData.crossSigningInfo || {} : {};\n        this._deviceTrackingStatus = deviceData ? deviceData.trackingStatus : {};\n        this._syncToken = deviceData ? deviceData.syncToken : null;\n        this._userByIdentityKey = {};\n\n        for (const user of Object.keys(this._devices)) {\n          const userDevices = this._devices[user];\n\n          for (const device of Object.keys(userDevices)) {\n            const idKey = userDevices[device].keys['curve25519:' + device];\n\n            if (idKey !== undefined) {\n              this._userByIdentityKey[idKey] = user;\n            }\n          }\n        }\n      });\n    });\n\n    for (const u of Object.keys(this._deviceTrackingStatus)) {\n      // if a download was in progress when we got shut down, it isn't any more.\n      if (this._deviceTrackingStatus[u] == TRACKING_STATUS_DOWNLOAD_IN_PROGRESS) {\n        this._deviceTrackingStatus[u] = TRACKING_STATUS_PENDING_DOWNLOAD;\n      }\n    }\n  }\n\n  stop() {\n    if (this._saveTimer !== null) {\n      clearTimeout(this._saveTimer);\n    }\n  }\n  /**\n   * Save the device tracking state to storage, if any changes are\n   * pending other than updating the sync token\n   *\n   * The actual save will be delayed by a short amount of time to\n   * aggregate multiple writes to the database.\n   *\n   * @param {integer} delay Time in ms before which the save actually happens.\n   *     By default, the save is delayed for a short period in order to batch\n   *     multiple writes, but this behaviour can be disabled by passing 0.\n   *\n   * @return {Promise<bool>} true if the data was saved, false if\n   *     it was not (eg. because no changes were pending). The promise\n   *     will only resolve once the data is saved, so may take some time\n   *     to resolve.\n   */\n\n\n  async saveIfDirty(delay) {\n    if (!this._dirty) return Promise.resolve(false); // Delay saves for a bit so we can aggregate multiple saves that happen\n    // in quick succession (eg. when a whole room's devices are marked as known)\n\n    if (delay === undefined) delay = 500;\n    const targetTime = Date.now + delay;\n\n    if (this._savePromiseTime && targetTime < this._savePromiseTime) {\n      // There's a save scheduled but for after we would like: cancel\n      // it & schedule one for the time we want\n      clearTimeout(this._saveTimer);\n      this._saveTimer = null;\n      this._savePromiseTime = null; // (but keep the save promise since whatever called save before\n      // will still want to know when the save is done)\n    }\n\n    let savePromise = this._savePromise;\n\n    if (savePromise === null) {\n      savePromise = new Promise((resolve, reject) => {\n        this._resolveSavePromise = resolve;\n      });\n      this._savePromise = savePromise;\n    }\n\n    if (this._saveTimer === null) {\n      const resolveSavePromise = this._resolveSavePromise;\n      this._savePromiseTime = targetTime;\n      this._saveTimer = setTimeout(() => {\n        _logger.logger.log('Saving device tracking data at token ' + this._syncToken); // null out savePromise now (after the delay but before the write),\n        // otherwise we could return the existing promise when the save has\n        // actually already happened. Likewise for the dirty flag.\n\n\n        this._savePromiseTime = null;\n        this._saveTimer = null;\n        this._savePromise = null;\n        this._resolveSavePromise = null;\n        this._dirty = false;\n\n        this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_DEVICE_DATA], txn => {\n          this._cryptoStore.storeEndToEndDeviceData({\n            devices: this._devices,\n            crossSigningInfo: this._crossSigningInfo,\n            trackingStatus: this._deviceTrackingStatus,\n            syncToken: this._syncToken\n          }, txn);\n        }).then(() => {\n          resolveSavePromise();\n        });\n      }, delay);\n    }\n\n    return savePromise;\n  }\n  /**\n   * Gets the sync token last set with setSyncToken\n   *\n   * @return {string} The sync token\n   */\n\n\n  getSyncToken() {\n    return this._syncToken;\n  }\n  /**\n   * Sets the sync token that the app will pass as the 'since' to the /sync\n   * endpoint next time it syncs.\n   * The sync token must always be set after any changes made as a result of\n   * data in that sync since setting the sync token to a newer one will mean\n   * those changed will not be synced from the server if a new client starts\n   * up with that data.\n   *\n   * @param {string} st The sync token\n   */\n\n\n  setSyncToken(st) {\n    this._syncToken = st;\n  }\n  /**\n   * Ensures up to date keys for a list of users are stored in the session store,\n   * downloading and storing them if they're not (or if forceDownload is\n   * true).\n   * @param {Array} userIds The users to fetch.\n   * @param {bool} forceDownload Always download the keys even if cached.\n   *\n   * @return {Promise} A promise which resolves to a map userId->deviceId->{@link\n   * module:crypto/deviceinfo|DeviceInfo}.\n   */\n\n\n  downloadKeys(userIds, forceDownload) {\n    const usersToDownload = [];\n    const promises = [];\n    userIds.forEach(u => {\n      const trackingStatus = this._deviceTrackingStatus[u];\n\n      if (this._keyDownloadsInProgressByUser[u]) {\n        // already a key download in progress/queued for this user; its results\n        // will be good enough for us.\n        _logger.logger.log(`downloadKeys: already have a download in progress for ` + `${u}: awaiting its result`);\n\n        promises.push(this._keyDownloadsInProgressByUser[u]);\n      } else if (forceDownload || trackingStatus != TRACKING_STATUS_UP_TO_DATE) {\n        usersToDownload.push(u);\n      }\n    });\n\n    if (usersToDownload.length != 0) {\n      _logger.logger.log(\"downloadKeys: downloading for\", usersToDownload);\n\n      const downloadPromise = this._doKeyDownload(usersToDownload);\n\n      promises.push(downloadPromise);\n    }\n\n    if (promises.length === 0) {\n      _logger.logger.log(\"downloadKeys: already have all necessary keys\");\n    }\n\n    return Promise.all(promises).then(() => {\n      return this._getDevicesFromStore(userIds);\n    });\n  }\n  /**\n   * Get the stored device keys for a list of user ids\n   *\n   * @param {string[]} userIds the list of users to list keys for.\n   *\n   * @return {Object} userId->deviceId->{@link module:crypto/deviceinfo|DeviceInfo}.\n   */\n\n\n  _getDevicesFromStore(userIds) {\n    const stored = {};\n    const self = this;\n    userIds.map(function (u) {\n      stored[u] = {};\n      const devices = self.getStoredDevicesForUser(u) || [];\n      devices.map(function (dev) {\n        stored[u][dev.deviceId] = dev;\n      });\n    });\n    return stored;\n  }\n  /**\n   * Get the stored device keys for a user id\n   *\n   * @param {string} userId the user to list keys for.\n   *\n   * @return {module:crypto/deviceinfo[]|null} list of devices, or null if we haven't\n   * managed to get a list of devices for this user yet.\n   */\n\n\n  getStoredDevicesForUser(userId) {\n    const devs = this._devices[userId];\n\n    if (!devs) {\n      return null;\n    }\n\n    const res = [];\n\n    for (const deviceId in devs) {\n      if (devs.hasOwnProperty(deviceId)) {\n        res.push(_deviceinfo.DeviceInfo.fromStorage(devs[deviceId], deviceId));\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Get the stored device data for a user, in raw object form\n   *\n   * @param {string} userId the user to get data for\n   *\n   * @return {Object} deviceId->{object} devices, or undefined if\n   * there is no data for this user.\n   */\n\n\n  getRawStoredDevicesForUser(userId) {\n    return this._devices[userId];\n  }\n\n  getStoredCrossSigningForUser(userId) {\n    if (!this._crossSigningInfo[userId]) return null;\n    return _CrossSigning.CrossSigningInfo.fromStorage(this._crossSigningInfo[userId], userId);\n  }\n\n  storeCrossSigningForUser(userId, info) {\n    this._crossSigningInfo[userId] = info;\n    this._dirty = true;\n  }\n  /**\n   * Get the stored keys for a single device\n   *\n   * @param {string} userId\n   * @param {string} deviceId\n   *\n   * @return {module:crypto/deviceinfo?} device, or undefined\n   * if we don't know about this device\n   */\n\n\n  getStoredDevice(userId, deviceId) {\n    const devs = this._devices[userId];\n\n    if (!devs || !devs[deviceId]) {\n      return undefined;\n    }\n\n    return _deviceinfo.DeviceInfo.fromStorage(devs[deviceId], deviceId);\n  }\n  /**\n   * Find a device by curve25519 identity key\n   *\n   * @param {string} algorithm  encryption algorithm\n   * @param {string} senderKey  curve25519 key to match\n   *\n   * @return {module:crypto/deviceinfo?}\n   */\n\n\n  getDeviceByIdentityKey(algorithm, senderKey) {\n    const userId = this._userByIdentityKey[senderKey];\n\n    if (!userId) {\n      return null;\n    }\n\n    if (algorithm !== olmlib.OLM_ALGORITHM && algorithm !== olmlib.MEGOLM_ALGORITHM) {\n      // we only deal in olm keys\n      return null;\n    }\n\n    const devices = this._devices[userId];\n\n    if (!devices) {\n      return null;\n    }\n\n    for (const deviceId in devices) {\n      if (!devices.hasOwnProperty(deviceId)) {\n        continue;\n      }\n\n      const device = devices[deviceId];\n\n      for (const keyId in device.keys) {\n        if (!device.keys.hasOwnProperty(keyId)) {\n          continue;\n        }\n\n        if (keyId.indexOf(\"curve25519:\") !== 0) {\n          continue;\n        }\n\n        const deviceKey = device.keys[keyId];\n\n        if (deviceKey == senderKey) {\n          return _deviceinfo.DeviceInfo.fromStorage(device, deviceId);\n        }\n      }\n    } // doesn't match a known device\n\n\n    return null;\n  }\n  /**\n   * Replaces the list of devices for a user with the given device list\n   *\n   * @param {string} u The user ID\n   * @param {Object} devs New device info for user\n   */\n\n\n  storeDevicesForUser(u, devs) {\n    // remove previous devices from _userByIdentityKey\n    if (this._devices[u] !== undefined) {\n      for (const [deviceId, dev] of Object.entries(this._devices[u])) {\n        const identityKey = dev.keys['curve25519:' + deviceId];\n        delete this._userByIdentityKey[identityKey];\n      }\n    }\n\n    this._devices[u] = devs; // add new ones\n\n    for (const [deviceId, dev] of Object.entries(devs)) {\n      const identityKey = dev.keys['curve25519:' + deviceId];\n      this._userByIdentityKey[identityKey] = u;\n    }\n\n    this._dirty = true;\n  }\n  /**\n   * flag the given user for device-list tracking, if they are not already.\n   *\n   * This will mean that a subsequent call to refreshOutdatedDeviceLists()\n   * will download the device list for the user, and that subsequent calls to\n   * invalidateUserDeviceList will trigger more updates.\n   *\n   * @param {String} userId\n   */\n\n\n  startTrackingDeviceList(userId) {\n    // sanity-check the userId. This is mostly paranoia, but if synapse\n    // can't parse the userId we give it as an mxid, it 500s the whole\n    // request and we can never update the device lists again (because\n    // the broken userId is always 'invalid' and always included in any\n    // refresh request).\n    // By checking it is at least a string, we can eliminate a class of\n    // silly errors.\n    if (typeof userId !== 'string') {\n      throw new Error('userId must be a string; was ' + userId);\n    }\n\n    if (!this._deviceTrackingStatus[userId]) {\n      _logger.logger.log('Now tracking device list for ' + userId);\n\n      this._deviceTrackingStatus[userId] = TRACKING_STATUS_PENDING_DOWNLOAD; // we don't yet persist the tracking status, since there may be a lot\n      // of calls; we save all data together once the sync is done\n\n      this._dirty = true;\n    }\n  }\n  /**\n   * Mark the given user as no longer being tracked for device-list updates.\n   *\n   * This won't affect any in-progress downloads, which will still go on to\n   * complete; it will just mean that we don't think that we have an up-to-date\n   * list for future calls to downloadKeys.\n   *\n   * @param {String} userId\n   */\n\n\n  stopTrackingDeviceList(userId) {\n    if (this._deviceTrackingStatus[userId]) {\n      _logger.logger.log('No longer tracking device list for ' + userId);\n\n      this._deviceTrackingStatus[userId] = TRACKING_STATUS_NOT_TRACKED; // we don't yet persist the tracking status, since there may be a lot\n      // of calls; we save all data together once the sync is done\n\n      this._dirty = true;\n    }\n  }\n  /**\n   * Set all users we're currently tracking to untracked\n   *\n   * This will flag each user whose devices we are tracking as in need of an\n   * update.\n   */\n\n\n  stopTrackingAllDeviceLists() {\n    for (const userId of Object.keys(this._deviceTrackingStatus)) {\n      this._deviceTrackingStatus[userId] = TRACKING_STATUS_NOT_TRACKED;\n    }\n\n    this._dirty = true;\n  }\n  /**\n   * Mark the cached device list for the given user outdated.\n   *\n   * If we are not tracking this user's devices, we'll do nothing. Otherwise\n   * we flag the user as needing an update.\n   *\n   * This doesn't actually set off an update, so that several users can be\n   * batched together. Call refreshOutdatedDeviceLists() for that.\n   *\n   * @param {String} userId\n   */\n\n\n  invalidateUserDeviceList(userId) {\n    if (this._deviceTrackingStatus[userId]) {\n      _logger.logger.log(\"Marking device list outdated for\", userId);\n\n      this._deviceTrackingStatus[userId] = TRACKING_STATUS_PENDING_DOWNLOAD; // we don't yet persist the tracking status, since there may be a lot\n      // of calls; we save all data together once the sync is done\n\n      this._dirty = true;\n    }\n  }\n  /**\n   * If we have users who have outdated device lists, start key downloads for them\n   *\n   * @returns {Promise} which completes when the download completes; normally there\n   *    is no need to wait for this (it's mostly for the unit tests).\n   */\n\n\n  refreshOutdatedDeviceLists() {\n    this.saveIfDirty();\n    const usersToDownload = [];\n\n    for (const userId of Object.keys(this._deviceTrackingStatus)) {\n      const stat = this._deviceTrackingStatus[userId];\n\n      if (stat == TRACKING_STATUS_PENDING_DOWNLOAD) {\n        usersToDownload.push(userId);\n      }\n    }\n\n    return this._doKeyDownload(usersToDownload);\n  }\n  /**\n   * Set the stored device data for a user, in raw object form\n   * Used only by internal class DeviceListUpdateSerialiser\n   *\n   * @param {string} userId the user to get data for\n   *\n   * @param {Object} devices deviceId->{object} the new devices\n   */\n\n\n  _setRawStoredDevicesForUser(userId, devices) {\n    // remove old devices from _userByIdentityKey\n    if (this._devices[userId] !== undefined) {\n      for (const [deviceId, dev] of Object.entries(this._devices[userId])) {\n        const identityKey = dev.keys['curve25519:' + deviceId];\n        delete this._userByIdentityKey[identityKey];\n      }\n    }\n\n    this._devices[userId] = devices; // add new devices into _userByIdentityKey\n\n    for (const [deviceId, dev] of Object.entries(devices)) {\n      const identityKey = dev.keys['curve25519:' + deviceId];\n      this._userByIdentityKey[identityKey] = userId;\n    }\n  }\n\n  setRawStoredCrossSigningForUser(userId, info) {\n    this._crossSigningInfo[userId] = info;\n  }\n  /**\n   * Fire off download update requests for the given users, and update the\n   * device list tracking status for them, and the\n   * _keyDownloadsInProgressByUser map for them.\n   *\n   * @param {String[]} users  list of userIds\n   *\n   * @return {module:client.Promise} resolves when all the users listed have\n   *     been updated. rejects if there was a problem updating any of the\n   *     users.\n   */\n\n\n  _doKeyDownload(users) {\n    if (users.length === 0) {\n      // nothing to do\n      return Promise.resolve();\n    }\n\n    const prom = this._serialiser.updateDevicesForUsers(users, this._syncToken).then(() => {\n      finished(true);\n    }, e => {\n      _logger.logger.error('Error downloading keys for ' + users + \":\", e);\n\n      finished(false);\n      throw e;\n    });\n\n    users.forEach(u => {\n      this._keyDownloadsInProgressByUser[u] = prom;\n      const stat = this._deviceTrackingStatus[u];\n\n      if (stat == TRACKING_STATUS_PENDING_DOWNLOAD) {\n        this._deviceTrackingStatus[u] = TRACKING_STATUS_DOWNLOAD_IN_PROGRESS;\n      }\n    });\n\n    const finished = success => {\n      users.forEach(u => {\n        this._dirty = true; // we may have queued up another download request for this user\n        // since we started this request. If that happens, we should\n        // ignore the completion of the first one.\n\n        if (this._keyDownloadsInProgressByUser[u] !== prom) {\n          _logger.logger.log('Another update in the queue for', u, '- not marking up-to-date');\n\n          return;\n        }\n\n        delete this._keyDownloadsInProgressByUser[u];\n        const stat = this._deviceTrackingStatus[u];\n\n        if (stat == TRACKING_STATUS_DOWNLOAD_IN_PROGRESS) {\n          if (success) {\n            // we didn't get any new invalidations since this download started:\n            // this user's device list is now up to date.\n            this._deviceTrackingStatus[u] = TRACKING_STATUS_UP_TO_DATE;\n\n            _logger.logger.log(\"Device list for\", u, \"now up to date\");\n          } else {\n            this._deviceTrackingStatus[u] = TRACKING_STATUS_PENDING_DOWNLOAD;\n          }\n        }\n      });\n      this.saveIfDirty();\n      this.emit(\"crypto.devicesUpdated\", users);\n    };\n\n    return prom;\n  }\n\n}\n/**\n * Serialises updates to device lists\n *\n * Ensures that results from /keys/query are not overwritten if a second call\n * completes *before* an earlier one.\n *\n * It currently does this by ensuring only one call to /keys/query happens at a\n * time (and queuing other requests up).\n */\n\n\nexports.DeviceList = DeviceList;\n\nclass DeviceListUpdateSerialiser {\n  /*\n   * @param {object} baseApis Base API object\n   * @param {object} olmDevice The Olm Device\n   * @param {object} deviceList The device list object\n   */\n  constructor(baseApis, olmDevice, deviceList) {\n    this._baseApis = baseApis;\n    this._olmDevice = olmDevice;\n    this._deviceList = deviceList; // the device list to be updated\n\n    this._downloadInProgress = false; // users which are queued for download\n    // userId -> true\n\n    this._keyDownloadsQueuedByUser = {}; // deferred which is resolved when the queued users are downloaded.\n    //\n    // non-null indicates that we have users queued for download.\n\n    this._queuedQueryDeferred = null;\n    this._syncToken = null; // The sync token we send with the requests\n  }\n  /**\n   * Make a key query request for the given users\n   *\n   * @param {String[]} users list of user ids\n   *\n   * @param {String} syncToken sync token to pass in the query request, to\n   *     help the HS give the most recent results\n   *\n   * @return {module:client.Promise} resolves when all the users listed have\n   *     been updated. rejects if there was a problem updating any of the\n   *     users.\n   */\n\n\n  updateDevicesForUsers(users, syncToken) {\n    users.forEach(u => {\n      this._keyDownloadsQueuedByUser[u] = true;\n    });\n\n    if (!this._queuedQueryDeferred) {\n      this._queuedQueryDeferred = (0, _utils.defer)();\n    } // We always take the new sync token and just use the latest one we've\n    // been given, since it just needs to be at least as recent as the\n    // sync response the device invalidation message arrived in\n\n\n    this._syncToken = syncToken;\n\n    if (this._downloadInProgress) {\n      // just queue up these users\n      _logger.logger.log('Queued key download for', users);\n\n      return this._queuedQueryDeferred.promise;\n    } // start a new download.\n\n\n    return this._doQueuedQueries();\n  }\n\n  _doQueuedQueries() {\n    if (this._downloadInProgress) {\n      throw new Error(\"DeviceListUpdateSerialiser._doQueuedQueries called with request active\");\n    }\n\n    const downloadUsers = Object.keys(this._keyDownloadsQueuedByUser);\n    this._keyDownloadsQueuedByUser = {};\n    const deferred = this._queuedQueryDeferred;\n    this._queuedQueryDeferred = null;\n\n    _logger.logger.log('Starting key download for', downloadUsers);\n\n    this._downloadInProgress = true;\n    const opts = {};\n\n    if (this._syncToken) {\n      opts.token = this._syncToken;\n    }\n\n    this._baseApis.downloadKeysForUsers(downloadUsers, opts).then(res => {\n      const dk = res.device_keys || {};\n      const masterKeys = res.master_keys || {};\n      const ssks = res.self_signing_keys || {};\n      const usks = res.user_signing_keys || {}; // do each user in a separate promise, to avoid wedging the CPU\n      // (https://github.com/vector-im/riot-web/issues/3158)\n      //\n      // of course we ought to do this in a web worker or similar, but\n      // this serves as an easy solution for now.\n\n      let prom = Promise.resolve();\n\n      for (const userId of downloadUsers) {\n        prom = prom.then((0, _utils.sleep)(5)).then(() => {\n          return this._processQueryResponseForUser(userId, dk[userId], {\n            master: masterKeys[userId],\n            self_signing: ssks[userId],\n            user_signing: usks[userId]\n          });\n        });\n      }\n\n      return prom;\n    }).then(() => {\n      _logger.logger.log('Completed key download for ' + downloadUsers);\n\n      this._downloadInProgress = false;\n      deferred.resolve(); // if we have queued users, fire off another request.\n\n      if (this._queuedQueryDeferred) {\n        this._doQueuedQueries();\n      }\n    }, e => {\n      _logger.logger.warn('Error downloading keys for ' + downloadUsers + ':', e);\n\n      this._downloadInProgress = false;\n      deferred.reject(e);\n    });\n\n    return deferred.promise;\n  }\n\n  async _processQueryResponseForUser(userId, dkResponse, crossSigningResponse, sskResponse) {\n    _logger.logger.log('got device keys for ' + userId + ':', dkResponse);\n\n    _logger.logger.log('got cross-signing keys for ' + userId + ':', crossSigningResponse);\n\n    {\n      // map from deviceid -> deviceinfo for this user\n      const userStore = {};\n\n      const devs = this._deviceList.getRawStoredDevicesForUser(userId);\n\n      if (devs) {\n        Object.keys(devs).forEach(deviceId => {\n          const d = _deviceinfo.DeviceInfo.fromStorage(devs[deviceId], deviceId);\n\n          userStore[deviceId] = d;\n        });\n      }\n\n      await _updateStoredDeviceKeysForUser(this._olmDevice, userId, userStore, dkResponse || {}); // put the updates into the object that will be returned as our results\n\n      const storage = {};\n      Object.keys(userStore).forEach(deviceId => {\n        storage[deviceId] = userStore[deviceId].toStorage();\n      });\n\n      this._deviceList._setRawStoredDevicesForUser(userId, storage);\n    } // now do the same for the cross-signing keys\n\n    {\n      // FIXME: should we be ignoring empty cross-signing responses, or\n      // should we be dropping the keys?\n      if (crossSigningResponse && (crossSigningResponse.master || crossSigningResponse.self_signing || crossSigningResponse.user_signing)) {\n        const crossSigning = this._deviceList.getStoredCrossSigningForUser(userId) || new _CrossSigning.CrossSigningInfo(userId);\n        crossSigning.setKeys(crossSigningResponse);\n\n        this._deviceList.setRawStoredCrossSigningForUser(userId, crossSigning.toStorage()); // NB. Unlike most events in the js-sdk, this one is internal to the\n        // js-sdk and is not re-emitted\n\n\n        this._deviceList.emit('userCrossSigningUpdated', userId);\n      }\n    }\n  }\n\n}\n\nasync function _updateStoredDeviceKeysForUser(_olmDevice, userId, userStore, userResult) {\n  let updated = false; // remove any devices in the store which aren't in the response\n\n  for (const deviceId in userStore) {\n    if (!userStore.hasOwnProperty(deviceId)) {\n      continue;\n    }\n\n    if (!(deviceId in userResult)) {\n      _logger.logger.log(\"Device \" + userId + \":\" + deviceId + \" has been removed\");\n\n      delete userStore[deviceId];\n      updated = true;\n    }\n  }\n\n  for (const deviceId in userResult) {\n    if (!userResult.hasOwnProperty(deviceId)) {\n      continue;\n    }\n\n    const deviceResult = userResult[deviceId]; // check that the user_id and device_id in the response object are\n    // correct\n\n    if (deviceResult.user_id !== userId) {\n      _logger.logger.warn(\"Mismatched user_id \" + deviceResult.user_id + \" in keys from \" + userId + \":\" + deviceId);\n\n      continue;\n    }\n\n    if (deviceResult.device_id !== deviceId) {\n      _logger.logger.warn(\"Mismatched device_id \" + deviceResult.device_id + \" in keys from \" + userId + \":\" + deviceId);\n\n      continue;\n    }\n\n    if (await _storeDeviceKeys(_olmDevice, userStore, deviceResult)) {\n      updated = true;\n    }\n  }\n\n  return updated;\n}\n/*\n * Process a device in a /query response, and add it to the userStore\n *\n * returns (a promise for) true if a change was made, else false\n */\n\n\nasync function _storeDeviceKeys(_olmDevice, userStore, deviceResult) {\n  if (!deviceResult.keys) {\n    // no keys?\n    return false;\n  }\n\n  const deviceId = deviceResult.device_id;\n  const userId = deviceResult.user_id;\n  const signKeyId = \"ed25519:\" + deviceId;\n  const signKey = deviceResult.keys[signKeyId];\n\n  if (!signKey) {\n    _logger.logger.warn(\"Device \" + userId + \":\" + deviceId + \" has no ed25519 key\");\n\n    return false;\n  }\n\n  const unsigned = deviceResult.unsigned || {};\n  const signatures = deviceResult.signatures || {};\n\n  try {\n    await olmlib.verifySignature(_olmDevice, deviceResult, userId, deviceId, signKey);\n  } catch (e) {\n    _logger.logger.warn(\"Unable to verify signature on device \" + userId + \":\" + deviceId + \":\" + e);\n\n    return false;\n  } // DeviceInfo\n\n\n  let deviceStore;\n\n  if (deviceId in userStore) {\n    // already have this device.\n    deviceStore = userStore[deviceId];\n\n    if (deviceStore.getFingerprint() != signKey) {\n      // this should only happen if the list has been MITMed; we are\n      // best off sticking with the original keys.\n      //\n      // Should we warn the user about it somehow?\n      _logger.logger.warn(\"Ed25519 key for device \" + userId + \":\" + deviceId + \" has changed\");\n\n      return false;\n    }\n  } else {\n    userStore[deviceId] = deviceStore = new _deviceinfo.DeviceInfo(deviceId);\n  }\n\n  deviceStore.keys = deviceResult.keys || {};\n  deviceStore.algorithms = deviceResult.algorithms || [];\n  deviceStore.unsigned = unsigned;\n  deviceStore.signatures = signatures;\n  return true;\n}","map":{"version":3,"sources":["/home/kimist/Developpement/React/watcha_client/node_modules/matrix-js-sdk/lib/crypto/DeviceList.js"],"names":["_interopRequireWildcard","require","Object","defineProperty","exports","value","DeviceList","_events","_logger","_deviceinfo","_CrossSigning","olmlib","_indexeddbCryptoStore","_utils","TRACKING_STATUS_NOT_TRACKED","TRACKING_STATUS_PENDING_DOWNLOAD","TRACKING_STATUS_DOWNLOAD_IN_PROGRESS","TRACKING_STATUS_UP_TO_DATE","EventEmitter","constructor","baseApis","cryptoStore","olmDevice","_cryptoStore","_devices","_crossSigningInfo","_userByIdentityKey","_deviceTrackingStatus","_syncToken","_serialiser","DeviceListUpdateSerialiser","_keyDownloadsInProgressByUser","_dirty","_savePromise","_resolveSavePromise","_savePromiseTime","_saveTimer","load","doTxn","IndexedDBCryptoStore","STORE_DEVICE_DATA","txn","getEndToEndDeviceData","deviceData","devices","crossSigningInfo","trackingStatus","syncToken","user","keys","userDevices","device","idKey","undefined","u","stop","clearTimeout","saveIfDirty","delay","Promise","resolve","targetTime","Date","now","savePromise","reject","resolveSavePromise","setTimeout","logger","log","storeEndToEndDeviceData","then","getSyncToken","setSyncToken","st","downloadKeys","userIds","forceDownload","usersToDownload","promises","forEach","push","length","downloadPromise","_doKeyDownload","all","_getDevicesFromStore","stored","self","map","getStoredDevicesForUser","dev","deviceId","userId","devs","res","hasOwnProperty","DeviceInfo","fromStorage","getRawStoredDevicesForUser","getStoredCrossSigningForUser","CrossSigningInfo","storeCrossSigningForUser","info","getStoredDevice","getDeviceByIdentityKey","algorithm","senderKey","OLM_ALGORITHM","MEGOLM_ALGORITHM","keyId","indexOf","deviceKey","storeDevicesForUser","entries","identityKey","startTrackingDeviceList","Error","stopTrackingDeviceList","stopTrackingAllDeviceLists","invalidateUserDeviceList","refreshOutdatedDeviceLists","stat","_setRawStoredDevicesForUser","setRawStoredCrossSigningForUser","users","prom","updateDevicesForUsers","finished","e","error","success","emit","deviceList","_baseApis","_olmDevice","_deviceList","_downloadInProgress","_keyDownloadsQueuedByUser","_queuedQueryDeferred","defer","promise","_doQueuedQueries","downloadUsers","deferred","opts","token","downloadKeysForUsers","dk","device_keys","masterKeys","master_keys","ssks","self_signing_keys","usks","user_signing_keys","sleep","_processQueryResponseForUser","master","self_signing","user_signing","warn","dkResponse","crossSigningResponse","sskResponse","userStore","d","_updateStoredDeviceKeysForUser","storage","toStorage","crossSigning","setKeys","userResult","updated","deviceResult","user_id","device_id","_storeDeviceKeys","signKeyId","signKey","unsigned","signatures","verifySignature","deviceStore","getFingerprint","algorithms"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DeviceList = void 0;\n\nvar _events = require(\"events\");\n\nvar _logger = require(\"../logger\");\n\nvar _deviceinfo = require(\"./deviceinfo\");\n\nvar _CrossSigning = require(\"./CrossSigning\");\n\nvar olmlib = _interopRequireWildcard(require(\"./olmlib\"));\n\nvar _indexeddbCryptoStore = require(\"./store/indexeddb-crypto-store\");\n\nvar _utils = require(\"../utils\");\n\n/*\nCopyright 2017 Vector Creations Ltd\nCopyright 2018, 2019 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * @module crypto/DeviceList\n *\n * Manages the list of other users' devices\n */\n\n/* State transition diagram for DeviceList._deviceTrackingStatus\n *\n *                                |\n *     stopTrackingDeviceList     V\n *   +---------------------> NOT_TRACKED\n *   |                            |\n *   +<--------------------+      | startTrackingDeviceList\n *   |                     |      V\n *   |   +-------------> PENDING_DOWNLOAD <--------------------+-+\n *   |   |                      ^ |                            | |\n *   |   | restart     download | |  start download            | | invalidateUserDeviceList\n *   |   | client        failed | |                            | |\n *   |   |                      | V                            | |\n *   |   +------------ DOWNLOAD_IN_PROGRESS -------------------+ |\n *   |                    |       |                              |\n *   +<-------------------+       |  download successful         |\n *   ^                            V                              |\n *   +----------------------- UP_TO_DATE ------------------------+\n */\n// constants for DeviceList._deviceTrackingStatus\nconst TRACKING_STATUS_NOT_TRACKED = 0;\nconst TRACKING_STATUS_PENDING_DOWNLOAD = 1;\nconst TRACKING_STATUS_DOWNLOAD_IN_PROGRESS = 2;\nconst TRACKING_STATUS_UP_TO_DATE = 3;\n/**\n * @alias module:crypto/DeviceList\n */\n\nclass DeviceList extends _events.EventEmitter {\n  constructor(baseApis, cryptoStore, olmDevice) {\n    super();\n    this._cryptoStore = cryptoStore; // userId -> {\n    //     deviceId -> {\n    //         [device info]\n    //     }\n    // }\n\n    this._devices = {}; // userId -> {\n    //     [key info]\n    // }\n\n    this._crossSigningInfo = {}; // map of identity keys to the user who owns it\n\n    this._userByIdentityKey = {}; // which users we are tracking device status for.\n    // userId -> TRACKING_STATUS_*\n\n    this._deviceTrackingStatus = {}; // loaded from storage in load()\n    // The 'next_batch' sync token at the point the data was writen,\n    // ie. a token representing the point immediately after the\n    // moment represented by the snapshot in the db.\n\n    this._syncToken = null;\n    this._serialiser = new DeviceListUpdateSerialiser(baseApis, olmDevice, this); // userId -> promise\n\n    this._keyDownloadsInProgressByUser = {}; // Set whenever changes are made other than setting the sync token\n\n    this._dirty = false; // Promise resolved when device data is saved\n\n    this._savePromise = null; // Function that resolves the save promise\n\n    this._resolveSavePromise = null; // The time the save is scheduled for\n\n    this._savePromiseTime = null; // The timer used to delay the save\n\n    this._saveTimer = null;\n  }\n  /**\n   * Load the device tracking state from storage\n   */\n\n\n  async load() {\n    await this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_DEVICE_DATA], txn => {\n      this._cryptoStore.getEndToEndDeviceData(txn, deviceData => {\n        this._devices = deviceData ? deviceData.devices : {}, this._crossSigningInfo = deviceData ? deviceData.crossSigningInfo || {} : {};\n        this._deviceTrackingStatus = deviceData ? deviceData.trackingStatus : {};\n        this._syncToken = deviceData ? deviceData.syncToken : null;\n        this._userByIdentityKey = {};\n\n        for (const user of Object.keys(this._devices)) {\n          const userDevices = this._devices[user];\n\n          for (const device of Object.keys(userDevices)) {\n            const idKey = userDevices[device].keys['curve25519:' + device];\n\n            if (idKey !== undefined) {\n              this._userByIdentityKey[idKey] = user;\n            }\n          }\n        }\n      });\n    });\n\n    for (const u of Object.keys(this._deviceTrackingStatus)) {\n      // if a download was in progress when we got shut down, it isn't any more.\n      if (this._deviceTrackingStatus[u] == TRACKING_STATUS_DOWNLOAD_IN_PROGRESS) {\n        this._deviceTrackingStatus[u] = TRACKING_STATUS_PENDING_DOWNLOAD;\n      }\n    }\n  }\n\n  stop() {\n    if (this._saveTimer !== null) {\n      clearTimeout(this._saveTimer);\n    }\n  }\n  /**\n   * Save the device tracking state to storage, if any changes are\n   * pending other than updating the sync token\n   *\n   * The actual save will be delayed by a short amount of time to\n   * aggregate multiple writes to the database.\n   *\n   * @param {integer} delay Time in ms before which the save actually happens.\n   *     By default, the save is delayed for a short period in order to batch\n   *     multiple writes, but this behaviour can be disabled by passing 0.\n   *\n   * @return {Promise<bool>} true if the data was saved, false if\n   *     it was not (eg. because no changes were pending). The promise\n   *     will only resolve once the data is saved, so may take some time\n   *     to resolve.\n   */\n\n\n  async saveIfDirty(delay) {\n    if (!this._dirty) return Promise.resolve(false); // Delay saves for a bit so we can aggregate multiple saves that happen\n    // in quick succession (eg. when a whole room's devices are marked as known)\n\n    if (delay === undefined) delay = 500;\n    const targetTime = Date.now + delay;\n\n    if (this._savePromiseTime && targetTime < this._savePromiseTime) {\n      // There's a save scheduled but for after we would like: cancel\n      // it & schedule one for the time we want\n      clearTimeout(this._saveTimer);\n      this._saveTimer = null;\n      this._savePromiseTime = null; // (but keep the save promise since whatever called save before\n      // will still want to know when the save is done)\n    }\n\n    let savePromise = this._savePromise;\n\n    if (savePromise === null) {\n      savePromise = new Promise((resolve, reject) => {\n        this._resolveSavePromise = resolve;\n      });\n      this._savePromise = savePromise;\n    }\n\n    if (this._saveTimer === null) {\n      const resolveSavePromise = this._resolveSavePromise;\n      this._savePromiseTime = targetTime;\n      this._saveTimer = setTimeout(() => {\n        _logger.logger.log('Saving device tracking data at token ' + this._syncToken); // null out savePromise now (after the delay but before the write),\n        // otherwise we could return the existing promise when the save has\n        // actually already happened. Likewise for the dirty flag.\n\n\n        this._savePromiseTime = null;\n        this._saveTimer = null;\n        this._savePromise = null;\n        this._resolveSavePromise = null;\n        this._dirty = false;\n\n        this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_DEVICE_DATA], txn => {\n          this._cryptoStore.storeEndToEndDeviceData({\n            devices: this._devices,\n            crossSigningInfo: this._crossSigningInfo,\n            trackingStatus: this._deviceTrackingStatus,\n            syncToken: this._syncToken\n          }, txn);\n        }).then(() => {\n          resolveSavePromise();\n        });\n      }, delay);\n    }\n\n    return savePromise;\n  }\n  /**\n   * Gets the sync token last set with setSyncToken\n   *\n   * @return {string} The sync token\n   */\n\n\n  getSyncToken() {\n    return this._syncToken;\n  }\n  /**\n   * Sets the sync token that the app will pass as the 'since' to the /sync\n   * endpoint next time it syncs.\n   * The sync token must always be set after any changes made as a result of\n   * data in that sync since setting the sync token to a newer one will mean\n   * those changed will not be synced from the server if a new client starts\n   * up with that data.\n   *\n   * @param {string} st The sync token\n   */\n\n\n  setSyncToken(st) {\n    this._syncToken = st;\n  }\n  /**\n   * Ensures up to date keys for a list of users are stored in the session store,\n   * downloading and storing them if they're not (or if forceDownload is\n   * true).\n   * @param {Array} userIds The users to fetch.\n   * @param {bool} forceDownload Always download the keys even if cached.\n   *\n   * @return {Promise} A promise which resolves to a map userId->deviceId->{@link\n   * module:crypto/deviceinfo|DeviceInfo}.\n   */\n\n\n  downloadKeys(userIds, forceDownload) {\n    const usersToDownload = [];\n    const promises = [];\n    userIds.forEach(u => {\n      const trackingStatus = this._deviceTrackingStatus[u];\n\n      if (this._keyDownloadsInProgressByUser[u]) {\n        // already a key download in progress/queued for this user; its results\n        // will be good enough for us.\n        _logger.logger.log(`downloadKeys: already have a download in progress for ` + `${u}: awaiting its result`);\n\n        promises.push(this._keyDownloadsInProgressByUser[u]);\n      } else if (forceDownload || trackingStatus != TRACKING_STATUS_UP_TO_DATE) {\n        usersToDownload.push(u);\n      }\n    });\n\n    if (usersToDownload.length != 0) {\n      _logger.logger.log(\"downloadKeys: downloading for\", usersToDownload);\n\n      const downloadPromise = this._doKeyDownload(usersToDownload);\n\n      promises.push(downloadPromise);\n    }\n\n    if (promises.length === 0) {\n      _logger.logger.log(\"downloadKeys: already have all necessary keys\");\n    }\n\n    return Promise.all(promises).then(() => {\n      return this._getDevicesFromStore(userIds);\n    });\n  }\n  /**\n   * Get the stored device keys for a list of user ids\n   *\n   * @param {string[]} userIds the list of users to list keys for.\n   *\n   * @return {Object} userId->deviceId->{@link module:crypto/deviceinfo|DeviceInfo}.\n   */\n\n\n  _getDevicesFromStore(userIds) {\n    const stored = {};\n    const self = this;\n    userIds.map(function (u) {\n      stored[u] = {};\n      const devices = self.getStoredDevicesForUser(u) || [];\n      devices.map(function (dev) {\n        stored[u][dev.deviceId] = dev;\n      });\n    });\n    return stored;\n  }\n  /**\n   * Get the stored device keys for a user id\n   *\n   * @param {string} userId the user to list keys for.\n   *\n   * @return {module:crypto/deviceinfo[]|null} list of devices, or null if we haven't\n   * managed to get a list of devices for this user yet.\n   */\n\n\n  getStoredDevicesForUser(userId) {\n    const devs = this._devices[userId];\n\n    if (!devs) {\n      return null;\n    }\n\n    const res = [];\n\n    for (const deviceId in devs) {\n      if (devs.hasOwnProperty(deviceId)) {\n        res.push(_deviceinfo.DeviceInfo.fromStorage(devs[deviceId], deviceId));\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Get the stored device data for a user, in raw object form\n   *\n   * @param {string} userId the user to get data for\n   *\n   * @return {Object} deviceId->{object} devices, or undefined if\n   * there is no data for this user.\n   */\n\n\n  getRawStoredDevicesForUser(userId) {\n    return this._devices[userId];\n  }\n\n  getStoredCrossSigningForUser(userId) {\n    if (!this._crossSigningInfo[userId]) return null;\n    return _CrossSigning.CrossSigningInfo.fromStorage(this._crossSigningInfo[userId], userId);\n  }\n\n  storeCrossSigningForUser(userId, info) {\n    this._crossSigningInfo[userId] = info;\n    this._dirty = true;\n  }\n  /**\n   * Get the stored keys for a single device\n   *\n   * @param {string} userId\n   * @param {string} deviceId\n   *\n   * @return {module:crypto/deviceinfo?} device, or undefined\n   * if we don't know about this device\n   */\n\n\n  getStoredDevice(userId, deviceId) {\n    const devs = this._devices[userId];\n\n    if (!devs || !devs[deviceId]) {\n      return undefined;\n    }\n\n    return _deviceinfo.DeviceInfo.fromStorage(devs[deviceId], deviceId);\n  }\n  /**\n   * Find a device by curve25519 identity key\n   *\n   * @param {string} algorithm  encryption algorithm\n   * @param {string} senderKey  curve25519 key to match\n   *\n   * @return {module:crypto/deviceinfo?}\n   */\n\n\n  getDeviceByIdentityKey(algorithm, senderKey) {\n    const userId = this._userByIdentityKey[senderKey];\n\n    if (!userId) {\n      return null;\n    }\n\n    if (algorithm !== olmlib.OLM_ALGORITHM && algorithm !== olmlib.MEGOLM_ALGORITHM) {\n      // we only deal in olm keys\n      return null;\n    }\n\n    const devices = this._devices[userId];\n\n    if (!devices) {\n      return null;\n    }\n\n    for (const deviceId in devices) {\n      if (!devices.hasOwnProperty(deviceId)) {\n        continue;\n      }\n\n      const device = devices[deviceId];\n\n      for (const keyId in device.keys) {\n        if (!device.keys.hasOwnProperty(keyId)) {\n          continue;\n        }\n\n        if (keyId.indexOf(\"curve25519:\") !== 0) {\n          continue;\n        }\n\n        const deviceKey = device.keys[keyId];\n\n        if (deviceKey == senderKey) {\n          return _deviceinfo.DeviceInfo.fromStorage(device, deviceId);\n        }\n      }\n    } // doesn't match a known device\n\n\n    return null;\n  }\n  /**\n   * Replaces the list of devices for a user with the given device list\n   *\n   * @param {string} u The user ID\n   * @param {Object} devs New device info for user\n   */\n\n\n  storeDevicesForUser(u, devs) {\n    // remove previous devices from _userByIdentityKey\n    if (this._devices[u] !== undefined) {\n      for (const [deviceId, dev] of Object.entries(this._devices[u])) {\n        const identityKey = dev.keys['curve25519:' + deviceId];\n        delete this._userByIdentityKey[identityKey];\n      }\n    }\n\n    this._devices[u] = devs; // add new ones\n\n    for (const [deviceId, dev] of Object.entries(devs)) {\n      const identityKey = dev.keys['curve25519:' + deviceId];\n      this._userByIdentityKey[identityKey] = u;\n    }\n\n    this._dirty = true;\n  }\n  /**\n   * flag the given user for device-list tracking, if they are not already.\n   *\n   * This will mean that a subsequent call to refreshOutdatedDeviceLists()\n   * will download the device list for the user, and that subsequent calls to\n   * invalidateUserDeviceList will trigger more updates.\n   *\n   * @param {String} userId\n   */\n\n\n  startTrackingDeviceList(userId) {\n    // sanity-check the userId. This is mostly paranoia, but if synapse\n    // can't parse the userId we give it as an mxid, it 500s the whole\n    // request and we can never update the device lists again (because\n    // the broken userId is always 'invalid' and always included in any\n    // refresh request).\n    // By checking it is at least a string, we can eliminate a class of\n    // silly errors.\n    if (typeof userId !== 'string') {\n      throw new Error('userId must be a string; was ' + userId);\n    }\n\n    if (!this._deviceTrackingStatus[userId]) {\n      _logger.logger.log('Now tracking device list for ' + userId);\n\n      this._deviceTrackingStatus[userId] = TRACKING_STATUS_PENDING_DOWNLOAD; // we don't yet persist the tracking status, since there may be a lot\n      // of calls; we save all data together once the sync is done\n\n      this._dirty = true;\n    }\n  }\n  /**\n   * Mark the given user as no longer being tracked for device-list updates.\n   *\n   * This won't affect any in-progress downloads, which will still go on to\n   * complete; it will just mean that we don't think that we have an up-to-date\n   * list for future calls to downloadKeys.\n   *\n   * @param {String} userId\n   */\n\n\n  stopTrackingDeviceList(userId) {\n    if (this._deviceTrackingStatus[userId]) {\n      _logger.logger.log('No longer tracking device list for ' + userId);\n\n      this._deviceTrackingStatus[userId] = TRACKING_STATUS_NOT_TRACKED; // we don't yet persist the tracking status, since there may be a lot\n      // of calls; we save all data together once the sync is done\n\n      this._dirty = true;\n    }\n  }\n  /**\n   * Set all users we're currently tracking to untracked\n   *\n   * This will flag each user whose devices we are tracking as in need of an\n   * update.\n   */\n\n\n  stopTrackingAllDeviceLists() {\n    for (const userId of Object.keys(this._deviceTrackingStatus)) {\n      this._deviceTrackingStatus[userId] = TRACKING_STATUS_NOT_TRACKED;\n    }\n\n    this._dirty = true;\n  }\n  /**\n   * Mark the cached device list for the given user outdated.\n   *\n   * If we are not tracking this user's devices, we'll do nothing. Otherwise\n   * we flag the user as needing an update.\n   *\n   * This doesn't actually set off an update, so that several users can be\n   * batched together. Call refreshOutdatedDeviceLists() for that.\n   *\n   * @param {String} userId\n   */\n\n\n  invalidateUserDeviceList(userId) {\n    if (this._deviceTrackingStatus[userId]) {\n      _logger.logger.log(\"Marking device list outdated for\", userId);\n\n      this._deviceTrackingStatus[userId] = TRACKING_STATUS_PENDING_DOWNLOAD; // we don't yet persist the tracking status, since there may be a lot\n      // of calls; we save all data together once the sync is done\n\n      this._dirty = true;\n    }\n  }\n  /**\n   * If we have users who have outdated device lists, start key downloads for them\n   *\n   * @returns {Promise} which completes when the download completes; normally there\n   *    is no need to wait for this (it's mostly for the unit tests).\n   */\n\n\n  refreshOutdatedDeviceLists() {\n    this.saveIfDirty();\n    const usersToDownload = [];\n\n    for (const userId of Object.keys(this._deviceTrackingStatus)) {\n      const stat = this._deviceTrackingStatus[userId];\n\n      if (stat == TRACKING_STATUS_PENDING_DOWNLOAD) {\n        usersToDownload.push(userId);\n      }\n    }\n\n    return this._doKeyDownload(usersToDownload);\n  }\n  /**\n   * Set the stored device data for a user, in raw object form\n   * Used only by internal class DeviceListUpdateSerialiser\n   *\n   * @param {string} userId the user to get data for\n   *\n   * @param {Object} devices deviceId->{object} the new devices\n   */\n\n\n  _setRawStoredDevicesForUser(userId, devices) {\n    // remove old devices from _userByIdentityKey\n    if (this._devices[userId] !== undefined) {\n      for (const [deviceId, dev] of Object.entries(this._devices[userId])) {\n        const identityKey = dev.keys['curve25519:' + deviceId];\n        delete this._userByIdentityKey[identityKey];\n      }\n    }\n\n    this._devices[userId] = devices; // add new devices into _userByIdentityKey\n\n    for (const [deviceId, dev] of Object.entries(devices)) {\n      const identityKey = dev.keys['curve25519:' + deviceId];\n      this._userByIdentityKey[identityKey] = userId;\n    }\n  }\n\n  setRawStoredCrossSigningForUser(userId, info) {\n    this._crossSigningInfo[userId] = info;\n  }\n  /**\n   * Fire off download update requests for the given users, and update the\n   * device list tracking status for them, and the\n   * _keyDownloadsInProgressByUser map for them.\n   *\n   * @param {String[]} users  list of userIds\n   *\n   * @return {module:client.Promise} resolves when all the users listed have\n   *     been updated. rejects if there was a problem updating any of the\n   *     users.\n   */\n\n\n  _doKeyDownload(users) {\n    if (users.length === 0) {\n      // nothing to do\n      return Promise.resolve();\n    }\n\n    const prom = this._serialiser.updateDevicesForUsers(users, this._syncToken).then(() => {\n      finished(true);\n    }, e => {\n      _logger.logger.error('Error downloading keys for ' + users + \":\", e);\n\n      finished(false);\n      throw e;\n    });\n\n    users.forEach(u => {\n      this._keyDownloadsInProgressByUser[u] = prom;\n      const stat = this._deviceTrackingStatus[u];\n\n      if (stat == TRACKING_STATUS_PENDING_DOWNLOAD) {\n        this._deviceTrackingStatus[u] = TRACKING_STATUS_DOWNLOAD_IN_PROGRESS;\n      }\n    });\n\n    const finished = success => {\n      users.forEach(u => {\n        this._dirty = true; // we may have queued up another download request for this user\n        // since we started this request. If that happens, we should\n        // ignore the completion of the first one.\n\n        if (this._keyDownloadsInProgressByUser[u] !== prom) {\n          _logger.logger.log('Another update in the queue for', u, '- not marking up-to-date');\n\n          return;\n        }\n\n        delete this._keyDownloadsInProgressByUser[u];\n        const stat = this._deviceTrackingStatus[u];\n\n        if (stat == TRACKING_STATUS_DOWNLOAD_IN_PROGRESS) {\n          if (success) {\n            // we didn't get any new invalidations since this download started:\n            // this user's device list is now up to date.\n            this._deviceTrackingStatus[u] = TRACKING_STATUS_UP_TO_DATE;\n\n            _logger.logger.log(\"Device list for\", u, \"now up to date\");\n          } else {\n            this._deviceTrackingStatus[u] = TRACKING_STATUS_PENDING_DOWNLOAD;\n          }\n        }\n      });\n      this.saveIfDirty();\n      this.emit(\"crypto.devicesUpdated\", users);\n    };\n\n    return prom;\n  }\n\n}\n/**\n * Serialises updates to device lists\n *\n * Ensures that results from /keys/query are not overwritten if a second call\n * completes *before* an earlier one.\n *\n * It currently does this by ensuring only one call to /keys/query happens at a\n * time (and queuing other requests up).\n */\n\n\nexports.DeviceList = DeviceList;\n\nclass DeviceListUpdateSerialiser {\n  /*\n   * @param {object} baseApis Base API object\n   * @param {object} olmDevice The Olm Device\n   * @param {object} deviceList The device list object\n   */\n  constructor(baseApis, olmDevice, deviceList) {\n    this._baseApis = baseApis;\n    this._olmDevice = olmDevice;\n    this._deviceList = deviceList; // the device list to be updated\n\n    this._downloadInProgress = false; // users which are queued for download\n    // userId -> true\n\n    this._keyDownloadsQueuedByUser = {}; // deferred which is resolved when the queued users are downloaded.\n    //\n    // non-null indicates that we have users queued for download.\n\n    this._queuedQueryDeferred = null;\n    this._syncToken = null; // The sync token we send with the requests\n  }\n  /**\n   * Make a key query request for the given users\n   *\n   * @param {String[]} users list of user ids\n   *\n   * @param {String} syncToken sync token to pass in the query request, to\n   *     help the HS give the most recent results\n   *\n   * @return {module:client.Promise} resolves when all the users listed have\n   *     been updated. rejects if there was a problem updating any of the\n   *     users.\n   */\n\n\n  updateDevicesForUsers(users, syncToken) {\n    users.forEach(u => {\n      this._keyDownloadsQueuedByUser[u] = true;\n    });\n\n    if (!this._queuedQueryDeferred) {\n      this._queuedQueryDeferred = (0, _utils.defer)();\n    } // We always take the new sync token and just use the latest one we've\n    // been given, since it just needs to be at least as recent as the\n    // sync response the device invalidation message arrived in\n\n\n    this._syncToken = syncToken;\n\n    if (this._downloadInProgress) {\n      // just queue up these users\n      _logger.logger.log('Queued key download for', users);\n\n      return this._queuedQueryDeferred.promise;\n    } // start a new download.\n\n\n    return this._doQueuedQueries();\n  }\n\n  _doQueuedQueries() {\n    if (this._downloadInProgress) {\n      throw new Error(\"DeviceListUpdateSerialiser._doQueuedQueries called with request active\");\n    }\n\n    const downloadUsers = Object.keys(this._keyDownloadsQueuedByUser);\n    this._keyDownloadsQueuedByUser = {};\n    const deferred = this._queuedQueryDeferred;\n    this._queuedQueryDeferred = null;\n\n    _logger.logger.log('Starting key download for', downloadUsers);\n\n    this._downloadInProgress = true;\n    const opts = {};\n\n    if (this._syncToken) {\n      opts.token = this._syncToken;\n    }\n\n    this._baseApis.downloadKeysForUsers(downloadUsers, opts).then(res => {\n      const dk = res.device_keys || {};\n      const masterKeys = res.master_keys || {};\n      const ssks = res.self_signing_keys || {};\n      const usks = res.user_signing_keys || {}; // do each user in a separate promise, to avoid wedging the CPU\n      // (https://github.com/vector-im/riot-web/issues/3158)\n      //\n      // of course we ought to do this in a web worker or similar, but\n      // this serves as an easy solution for now.\n\n      let prom = Promise.resolve();\n\n      for (const userId of downloadUsers) {\n        prom = prom.then((0, _utils.sleep)(5)).then(() => {\n          return this._processQueryResponseForUser(userId, dk[userId], {\n            master: masterKeys[userId],\n            self_signing: ssks[userId],\n            user_signing: usks[userId]\n          });\n        });\n      }\n\n      return prom;\n    }).then(() => {\n      _logger.logger.log('Completed key download for ' + downloadUsers);\n\n      this._downloadInProgress = false;\n      deferred.resolve(); // if we have queued users, fire off another request.\n\n      if (this._queuedQueryDeferred) {\n        this._doQueuedQueries();\n      }\n    }, e => {\n      _logger.logger.warn('Error downloading keys for ' + downloadUsers + ':', e);\n\n      this._downloadInProgress = false;\n      deferred.reject(e);\n    });\n\n    return deferred.promise;\n  }\n\n  async _processQueryResponseForUser(userId, dkResponse, crossSigningResponse, sskResponse) {\n    _logger.logger.log('got device keys for ' + userId + ':', dkResponse);\n\n    _logger.logger.log('got cross-signing keys for ' + userId + ':', crossSigningResponse);\n\n    {\n      // map from deviceid -> deviceinfo for this user\n      const userStore = {};\n\n      const devs = this._deviceList.getRawStoredDevicesForUser(userId);\n\n      if (devs) {\n        Object.keys(devs).forEach(deviceId => {\n          const d = _deviceinfo.DeviceInfo.fromStorage(devs[deviceId], deviceId);\n\n          userStore[deviceId] = d;\n        });\n      }\n\n      await _updateStoredDeviceKeysForUser(this._olmDevice, userId, userStore, dkResponse || {}); // put the updates into the object that will be returned as our results\n\n      const storage = {};\n      Object.keys(userStore).forEach(deviceId => {\n        storage[deviceId] = userStore[deviceId].toStorage();\n      });\n\n      this._deviceList._setRawStoredDevicesForUser(userId, storage);\n    } // now do the same for the cross-signing keys\n\n    {\n      // FIXME: should we be ignoring empty cross-signing responses, or\n      // should we be dropping the keys?\n      if (crossSigningResponse && (crossSigningResponse.master || crossSigningResponse.self_signing || crossSigningResponse.user_signing)) {\n        const crossSigning = this._deviceList.getStoredCrossSigningForUser(userId) || new _CrossSigning.CrossSigningInfo(userId);\n        crossSigning.setKeys(crossSigningResponse);\n\n        this._deviceList.setRawStoredCrossSigningForUser(userId, crossSigning.toStorage()); // NB. Unlike most events in the js-sdk, this one is internal to the\n        // js-sdk and is not re-emitted\n\n\n        this._deviceList.emit('userCrossSigningUpdated', userId);\n      }\n    }\n  }\n\n}\n\nasync function _updateStoredDeviceKeysForUser(_olmDevice, userId, userStore, userResult) {\n  let updated = false; // remove any devices in the store which aren't in the response\n\n  for (const deviceId in userStore) {\n    if (!userStore.hasOwnProperty(deviceId)) {\n      continue;\n    }\n\n    if (!(deviceId in userResult)) {\n      _logger.logger.log(\"Device \" + userId + \":\" + deviceId + \" has been removed\");\n\n      delete userStore[deviceId];\n      updated = true;\n    }\n  }\n\n  for (const deviceId in userResult) {\n    if (!userResult.hasOwnProperty(deviceId)) {\n      continue;\n    }\n\n    const deviceResult = userResult[deviceId]; // check that the user_id and device_id in the response object are\n    // correct\n\n    if (deviceResult.user_id !== userId) {\n      _logger.logger.warn(\"Mismatched user_id \" + deviceResult.user_id + \" in keys from \" + userId + \":\" + deviceId);\n\n      continue;\n    }\n\n    if (deviceResult.device_id !== deviceId) {\n      _logger.logger.warn(\"Mismatched device_id \" + deviceResult.device_id + \" in keys from \" + userId + \":\" + deviceId);\n\n      continue;\n    }\n\n    if (await _storeDeviceKeys(_olmDevice, userStore, deviceResult)) {\n      updated = true;\n    }\n  }\n\n  return updated;\n}\n/*\n * Process a device in a /query response, and add it to the userStore\n *\n * returns (a promise for) true if a change was made, else false\n */\n\n\nasync function _storeDeviceKeys(_olmDevice, userStore, deviceResult) {\n  if (!deviceResult.keys) {\n    // no keys?\n    return false;\n  }\n\n  const deviceId = deviceResult.device_id;\n  const userId = deviceResult.user_id;\n  const signKeyId = \"ed25519:\" + deviceId;\n  const signKey = deviceResult.keys[signKeyId];\n\n  if (!signKey) {\n    _logger.logger.warn(\"Device \" + userId + \":\" + deviceId + \" has no ed25519 key\");\n\n    return false;\n  }\n\n  const unsigned = deviceResult.unsigned || {};\n  const signatures = deviceResult.signatures || {};\n\n  try {\n    await olmlib.verifySignature(_olmDevice, deviceResult, userId, deviceId, signKey);\n  } catch (e) {\n    _logger.logger.warn(\"Unable to verify signature on device \" + userId + \":\" + deviceId + \":\" + e);\n\n    return false;\n  } // DeviceInfo\n\n\n  let deviceStore;\n\n  if (deviceId in userStore) {\n    // already have this device.\n    deviceStore = userStore[deviceId];\n\n    if (deviceStore.getFingerprint() != signKey) {\n      // this should only happen if the list has been MITMed; we are\n      // best off sticking with the original keys.\n      //\n      // Should we warn the user about it somehow?\n      _logger.logger.warn(\"Ed25519 key for device \" + userId + \":\" + deviceId + \" has changed\");\n\n      return false;\n    }\n  } else {\n    userStore[deviceId] = deviceStore = new _deviceinfo.DeviceInfo(deviceId);\n  }\n\n  deviceStore.keys = deviceResult.keys || {};\n  deviceStore.algorithms = deviceResult.algorithms || [];\n  deviceStore.unsigned = unsigned;\n  deviceStore.signatures = signatures;\n  return true;\n}"]},"metadata":{},"sourceType":"script"}