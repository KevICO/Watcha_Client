{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Room = Room;\n\nvar _events = require(\"events\");\n\nvar _eventTimelineSet = require(\"./event-timeline-set\");\n\nvar _eventTimeline = require(\"./event-timeline\");\n\nvar _contentRepo = require(\"../content-repo\");\n\nvar utils = _interopRequireWildcard(require(\"../utils\"));\n\nvar _event = require(\"./event\");\n\nvar _roomMember = require(\"./room-member\");\n\nvar _roomSummary = require(\"./room-summary\");\n\nvar _logger = require(\"../logger\");\n\nvar _ReEmitter = require(\"../ReEmitter\");\n/*\nCopyright 2015, 2016 OpenMarket Ltd\nCopyright 2018, 2019 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * @module models/room\n */\n// These constants are used as sane defaults when the homeserver doesn't support\n// the m.room_versions capability. In practice, KNOWN_SAFE_ROOM_VERSION should be\n// the same as the common default room version whereas SAFE_ROOM_VERSIONS are the\n// room versions which are considered okay for people to run without being asked\n// to upgrade (ie: \"stable\"). Eventually, we should remove these when all homeservers\n// return an m.room_versions capability.\n\n\nconst KNOWN_SAFE_ROOM_VERSION = '5';\nconst SAFE_ROOM_VERSIONS = ['1', '2', '3', '4', '5'];\n\nfunction synthesizeReceipt(userId, event, receiptType) {\n  // console.log(\"synthesizing receipt for \"+event.getId());\n  // This is really ugly because JS has no way to express an object literal\n  // where the name of a key comes from an expression\n  const fakeReceipt = {\n    content: {},\n    type: \"m.receipt\",\n    room_id: event.getRoomId()\n  };\n  fakeReceipt.content[event.getId()] = {};\n  fakeReceipt.content[event.getId()][receiptType] = {};\n  fakeReceipt.content[event.getId()][receiptType][userId] = {\n    ts: event.getTs()\n  };\n  return new _event.MatrixEvent(fakeReceipt);\n}\n/**\n * Construct a new Room.\n *\n * <p>For a room, we store an ordered sequence of timelines, which may or may not\n * be continuous. Each timeline lists a series of events, as well as tracking\n * the room state at the start and the end of the timeline. It also tracks\n * forward and backward pagination tokens, as well as containing links to the\n * next timeline in the sequence.\n *\n * <p>There is one special timeline - the 'live' timeline, which represents the\n * timeline to which events are being added in real-time as they are received\n * from the /sync API. Note that you should not retain references to this\n * timeline - even if it is the current timeline right now, it may not remain\n * so if the server gives us a timeline gap in /sync.\n *\n * <p>In order that we can find events from their ids later, we also maintain a\n * map from event_id to timeline and index.\n *\n * @constructor\n * @alias module:models/room\n * @param {string} roomId Required. The ID of this room.\n * @param {MatrixClient} client Required. The client, used to lazy load members.\n * @param {string} myUserId Required. The ID of the syncing user.\n * @param {Object=} opts Configuration options\n * @param {*} opts.storageToken Optional. The token which a data store can use\n * to remember the state of the room. What this means is dependent on the store\n * implementation.\n *\n * @param {String=} opts.pendingEventOrdering Controls where pending messages\n * appear in a room's timeline. If \"<b>chronological</b>\", messages will appear\n * in the timeline when the call to <code>sendEvent</code> was made. If\n * \"<b>detached</b>\", pending messages will appear in a separate list,\n * accessbile via {@link module:models/room#getPendingEvents}. Default:\n * \"chronological\".\n * @param {boolean} [opts.timelineSupport = false] Set to true to enable improved\n * timeline support.\n * @param {boolean} [opts.unstableClientRelationAggregation = false]\n * Optional. Set to true to enable client-side aggregation of event relations\n * via `EventTimelineSet#getRelationsForEvent`.\n * This feature is currently unstable and the API may change without notice.\n *\n * @prop {string} roomId The ID of this room.\n * @prop {string} name The human-readable display name for this room.\n * @prop {Array<MatrixEvent>} timeline The live event timeline for this room,\n * with the oldest event at index 0. Present for backwards compatibility -\n * prefer getLiveTimeline().getEvents().\n * @prop {object} tags Dict of room tags; the keys are the tag name and the values\n * are any metadata associated with the tag - e.g. { \"fav\" : { order: 1 } }\n * @prop {object} accountData Dict of per-room account_data events; the keys are the\n * event type and the values are the events.\n * @prop {RoomState} oldState The state of the room at the time of the oldest\n * event in the live timeline. Present for backwards compatibility -\n * prefer getLiveTimeline().getState(EventTimeline.BACKWARDS).\n * @prop {RoomState} currentState The state of the room at the time of the\n * newest event in the timeline. Present for backwards compatibility -\n * prefer getLiveTimeline().getState(EventTimeline.FORWARDS).\n * @prop {RoomSummary} summary The room summary.\n * @prop {*} storageToken A token which a data store can use to remember\n * the state of the room.\n */\n\n\nfunction Room(roomId, client, myUserId, opts) {\n  opts = opts || {};\n  opts.pendingEventOrdering = opts.pendingEventOrdering || \"chronological\";\n  this.reEmitter = new _ReEmitter.ReEmitter(this);\n\n  if ([\"chronological\", \"detached\"].indexOf(opts.pendingEventOrdering) === -1) {\n    throw new Error(\"opts.pendingEventOrdering MUST be either 'chronological' or \" + \"'detached'. Got: '\" + opts.pendingEventOrdering + \"'\");\n  }\n\n  this.myUserId = myUserId;\n  this.roomId = roomId;\n  this.name = roomId;\n  this.tags = {// $tagName: { $metadata: $value },\n    // $tagName: { $metadata: $value },\n  };\n  this.accountData = {// $eventType: $event\n  };\n  this.summary = null;\n  this.storageToken = opts.storageToken;\n  this._opts = opts;\n  this._txnToEvent = {}; // Pending in-flight requests { string: MatrixEvent }\n  // receipts should clobber based on receipt_type and user_id pairs hence\n  // the form of this structure. This is sub-optimal for the exposed APIs\n  // which pass in an event ID and get back some receipts, so we also store\n  // a pre-cached list for this purpose.\n\n  this._receipts = {// receipt_type: {\n    //   user_id: {\n    //     eventId: <event_id>,\n    //     data: <receipt_data>\n    //   }\n    // }\n  };\n  this._receiptCacheByEventId = {// $event_id: [{\n    //   type: $type,\n    //   userId: $user_id,\n    //   data: <receipt data>\n    // }]\n  }; // only receipts that came from the server, not synthesized ones\n\n  this._realReceipts = {};\n  this._notificationCounts = {}; // all our per-room timeline sets. the first one is the unfiltered ones;\n  // the subsequent ones are the filtered ones in no particular order.\n\n  this._timelineSets = [new _eventTimelineSet.EventTimelineSet(this, opts)];\n  this.reEmitter.reEmit(this.getUnfilteredTimelineSet(), [\"Room.timeline\", \"Room.timelineReset\"]);\n\n  this._fixUpLegacyTimelineFields(); // any filtered timeline sets we're maintaining for this room\n\n\n  this._filteredTimelineSets = {// filter_id: timelineSet\n  };\n\n  if (this._opts.pendingEventOrdering == \"detached\") {\n    this._pendingEventList = [];\n  } // read by megolm; boolean value - null indicates \"use global value\"\n\n\n  this._blacklistUnverifiedDevices = null;\n  this._selfMembership = null;\n  this._summaryHeroes = null; // awaited by getEncryptionTargetMembers while room members are loading\n\n  this._client = client;\n\n  if (!this._opts.lazyLoadMembers) {\n    this._membersPromise = Promise.resolve();\n  } else {\n    this._membersPromise = null;\n  }\n}\n\nutils.inherits(Room, _events.EventEmitter);\n/**\n * Gets the version of the room\n * @returns {string} The version of the room, or null if it could not be determined\n */\n\nRoom.prototype.getVersion = function () {\n  const createEvent = this.currentState.getStateEvents(\"m.room.create\", \"\");\n\n  if (!createEvent) {\n    _logger.logger.warn(\"Room \" + this.room_id + \" does not have an m.room.create event\");\n\n    return '1';\n  }\n\n  const ver = createEvent.getContent()['room_version'];\n  if (ver === undefined) return '1';\n  return ver;\n};\n/**\n * Determines whether this room needs to be upgraded to a new version\n * @returns {string?} What version the room should be upgraded to, or null if\n *     the room does not require upgrading at this time.\n * @deprecated Use #getRecommendedVersion() instead\n */\n\n\nRoom.prototype.shouldUpgradeToVersion = function () {\n  // TODO: Remove this function.\n  // This makes assumptions about which versions are safe, and can easily\n  // be wrong. Instead, people are encouraged to use getRecommendedVersion\n  // which determines a safer value. This function doesn't use that function\n  // because this is not async-capable, and to avoid breaking the contract\n  // we're deprecating this.\n  if (!SAFE_ROOM_VERSIONS.includes(this.getVersion())) {\n    return KNOWN_SAFE_ROOM_VERSION;\n  }\n\n  return null;\n};\n/**\n * Determines the recommended room version for the room. This returns an\n * object with 3 properties: <code>version</code> as the new version the\n * room should be upgraded to (may be the same as the current version);\n * <code>needsUpgrade</code> to indicate if the room actually can be\n * upgraded (ie: does the current version not match?); and <code>urgent</code>\n * to indicate if the new version patches a vulnerability in a previous\n * version.\n * @returns {Promise<{version: string, needsUpgrade: bool, urgent: bool}>}\n * Resolves to the version the room should be upgraded to.\n */\n\n\nRoom.prototype.getRecommendedVersion = async function () {\n  const capabilities = await this._client.getCapabilities();\n  let versionCap = capabilities[\"m.room_versions\"];\n\n  if (!versionCap) {\n    versionCap = {\n      default: KNOWN_SAFE_ROOM_VERSION,\n      available: {}\n    };\n\n    for (const safeVer of SAFE_ROOM_VERSIONS) {\n      versionCap.available[safeVer] = \"stable\";\n    }\n  }\n\n  let result = this._checkVersionAgainstCapability(versionCap);\n\n  if (result.urgent && result.needsUpgrade) {\n    // Something doesn't feel right: we shouldn't need to update\n    // because the version we're on should be in the protocol's\n    // namespace. This usually means that the server was updated\n    // before the client was, making us think the newest possible\n    // room version is not stable. As a solution, we'll refresh\n    // the capability we're using to determine this.\n    _logger.logger.warn(\"Refreshing room version capability because the server looks \" + \"to be supporting a newer room version we don't know about.\");\n\n    const caps = await this._client.getCapabilities(true);\n    versionCap = caps[\"m.room_versions\"];\n\n    if (!versionCap) {\n      _logger.logger.warn(\"No room version capability - assuming upgrade required.\");\n\n      return result;\n    } else {\n      result = this._checkVersionAgainstCapability(versionCap);\n    }\n  }\n\n  return result;\n};\n\nRoom.prototype._checkVersionAgainstCapability = function (versionCap) {\n  const currentVersion = this.getVersion();\n\n  _logger.logger.log(`[${this.roomId}] Current version: ${currentVersion}`);\n\n  _logger.logger.log(`[${this.roomId}] Version capability: `, versionCap);\n\n  const result = {\n    version: currentVersion,\n    needsUpgrade: false,\n    urgent: false\n  }; // If the room is on the default version then nothing needs to change\n\n  if (currentVersion === versionCap.default) return result;\n  const stableVersions = Object.keys(versionCap.available).filter(v => versionCap.available[v] === 'stable'); // Check if the room is on an unstable version. We determine urgency based\n  // off the version being in the Matrix spec namespace or not (if the version\n  // is in the current namespace and unstable, the room is probably vulnerable).\n\n  if (!stableVersions.includes(currentVersion)) {\n    result.version = versionCap.default;\n    result.needsUpgrade = true;\n    result.urgent = !!this.getVersion().match(/^[0-9]+[0-9.]*$/g);\n\n    if (result.urgent) {\n      _logger.logger.warn(`URGENT upgrade required on ${this.roomId}`);\n    } else {\n      _logger.logger.warn(`Non-urgent upgrade required on ${this.roomId}`);\n    }\n\n    return result;\n  } // The room is on a stable, but non-default, version by this point.\n  // No upgrade needed.\n\n\n  return result;\n};\n/**\n * Determines whether the given user is permitted to perform a room upgrade\n * @param {String} userId The ID of the user to test against\n * @returns {bool} True if the given user is permitted to upgrade the room\n */\n\n\nRoom.prototype.userMayUpgradeRoom = function (userId) {\n  return this.currentState.maySendStateEvent(\"m.room.tombstone\", userId);\n};\n/**\n * Get the list of pending sent events for this room\n *\n * @return {module:models/event.MatrixEvent[]} A list of the sent events\n * waiting for remote echo.\n *\n * @throws If <code>opts.pendingEventOrdering</code> was not 'detached'\n */\n\n\nRoom.prototype.getPendingEvents = function () {\n  if (this._opts.pendingEventOrdering !== \"detached\") {\n    throw new Error(\"Cannot call getPendingEvents with pendingEventOrdering == \" + this._opts.pendingEventOrdering);\n  }\n\n  return this._pendingEventList;\n};\n/**\n * Check whether the pending event list contains a given event by ID.\n *\n * @param {string} eventId The event ID to check for.\n * @return {boolean}\n * @throws If <code>opts.pendingEventOrdering</code> was not 'detached'\n */\n\n\nRoom.prototype.hasPendingEvent = function (eventId) {\n  if (this._opts.pendingEventOrdering !== \"detached\") {\n    throw new Error(\"Cannot call hasPendingEvent with pendingEventOrdering == \" + this._opts.pendingEventOrdering);\n  }\n\n  return this._pendingEventList.some(event => event.getId() === eventId);\n};\n/**\n * Get the live unfiltered timeline for this room.\n *\n * @return {module:models/event-timeline~EventTimeline} live timeline\n */\n\n\nRoom.prototype.getLiveTimeline = function () {\n  return this.getUnfilteredTimelineSet().getLiveTimeline();\n};\n/**\n * Get the timestamp of the last message in the room\n *\n * @return {number} the timestamp of the last message in the room\n */\n\n\nRoom.prototype.getLastActiveTimestamp = function () {\n  const timeline = this.getLiveTimeline();\n  const events = timeline.getEvents();\n\n  if (events.length) {\n    const lastEvent = events[events.length - 1];\n    return lastEvent.getTs();\n  } else {\n    return Number.MIN_SAFE_INTEGER;\n  }\n};\n/**\n * @param {string} myUserId the user id for the logged in member\n * @return {string} the membership type (join | leave | invite) for the logged in user\n */\n\n\nRoom.prototype.getMyMembership = function () {\n  return this._selfMembership;\n};\n/**\n * If this room is a DM we're invited to,\n * try to find out who invited us\n * @return {string} user id of the inviter\n */\n\n\nRoom.prototype.getDMInviter = function () {\n  if (this.myUserId) {\n    const me = this.getMember(this.myUserId);\n\n    if (me) {\n      return me.getDMInviter();\n    }\n  }\n\n  if (this._selfMembership === \"invite\") {\n    // fall back to summary information\n    const memberCount = this.getInvitedAndJoinedMemberCount();\n\n    if (memberCount == 2 && this._summaryHeroes.length) {\n      return this._summaryHeroes[0];\n    }\n  }\n};\n/**\n * Assuming this room is a DM room, tries to guess with which user.\n * @return {string} user id of the other member (could be syncing user)\n */\n\n\nRoom.prototype.guessDMUserId = function () {\n  const me = this.getMember(this.myUserId);\n\n  if (me) {\n    const inviterId = me.getDMInviter();\n\n    if (inviterId) {\n      return inviterId;\n    }\n  } // remember, we're assuming this room is a DM,\n  // so returning the first member we find should be fine\n\n\n  const hasHeroes = Array.isArray(this._summaryHeroes) && this._summaryHeroes.length;\n\n  if (hasHeroes) {\n    return this._summaryHeroes[0];\n  }\n\n  const members = this.currentState.getMembers();\n  const anyMember = members.find(m => m.userId !== this.myUserId);\n\n  if (anyMember) {\n    return anyMember.userId;\n  } // it really seems like I'm the only user in the room\n  // so I probably created a room with just me in it\n  // and marked it as a DM. Ok then\n\n\n  return this.myUserId;\n};\n\nRoom.prototype.getAvatarFallbackMember = function () {\n  const memberCount = this.getInvitedAndJoinedMemberCount();\n\n  if (memberCount > 2) {\n    return;\n  }\n\n  const hasHeroes = Array.isArray(this._summaryHeroes) && this._summaryHeroes.length;\n\n  if (hasHeroes) {\n    const availableMember = this._summaryHeroes.map(userId => {\n      return this.getMember(userId);\n    }).find(member => !!member);\n\n    if (availableMember) {\n      return availableMember;\n    }\n  }\n\n  const members = this.currentState.getMembers(); // could be different than memberCount\n  // as this includes left members\n\n  if (members.length <= 2) {\n    const availableMember = members.find(m => {\n      return m.userId !== this.myUserId;\n    });\n\n    if (availableMember) {\n      return availableMember;\n    }\n  } // if all else fails, try falling back to a user,\n  // and create a one-off member for it\n\n\n  if (hasHeroes) {\n    const availableUser = this._summaryHeroes.map(userId => {\n      return this._client.getUser(userId);\n    }).find(user => !!user);\n\n    if (availableUser) {\n      const member = new _roomMember.RoomMember(this.roomId, availableUser.userId);\n      member.user = availableUser;\n      return member;\n    }\n  }\n};\n/**\n * Sets the membership this room was received as during sync\n * @param {string} membership join | leave | invite\n */\n\n\nRoom.prototype.updateMyMembership = function (membership) {\n  const prevMembership = this._selfMembership;\n  this._selfMembership = membership;\n\n  if (prevMembership !== membership) {\n    if (membership === \"leave\") {\n      this._cleanupAfterLeaving();\n    }\n\n    this.emit(\"Room.myMembership\", this, membership, prevMembership);\n  }\n};\n\nRoom.prototype._loadMembersFromServer = async function () {\n  const lastSyncToken = this._client.store.getSyncToken();\n\n  const queryString = utils.encodeParams({\n    not_membership: \"leave\",\n    at: lastSyncToken\n  });\n  const path = utils.encodeUri(\"/rooms/$roomId/members?\" + queryString, {\n    $roomId: this.roomId\n  });\n  const http = this._client._http;\n  const response = await http.authedRequest(undefined, \"GET\", path);\n  return response.chunk;\n};\n\nRoom.prototype._loadMembers = async function () {\n  // were the members loaded from the server?\n  let fromServer = false;\n  let rawMembersEvents = await this._client.store.getOutOfBandMembers(this.roomId);\n\n  if (rawMembersEvents === null) {\n    fromServer = true;\n    rawMembersEvents = await this._loadMembersFromServer();\n\n    _logger.logger.log(`LL: got ${rawMembersEvents.length} ` + `members from server for room ${this.roomId}`);\n  }\n\n  const memberEvents = rawMembersEvents.map(this._client.getEventMapper());\n  return {\n    memberEvents,\n    fromServer\n  };\n};\n/**\n * Preloads the member list in case lazy loading\n * of memberships is in use. Can be called multiple times,\n * it will only preload once.\n * @return {Promise} when preloading is done and\n * accessing the members on the room will take\n * all members in the room into account\n */\n\n\nRoom.prototype.loadMembersIfNeeded = function () {\n  if (this._membersPromise) {\n    return this._membersPromise;\n  } // mark the state so that incoming messages while\n  // the request is in flight get marked as superseding\n  // the OOB members\n\n\n  this.currentState.markOutOfBandMembersStarted();\n\n  const inMemoryUpdate = this._loadMembers().then(result => {\n    this.currentState.setOutOfBandMembers(result.memberEvents); // now the members are loaded, start to track the e2e devices if needed\n\n    if (this._client.isCryptoEnabled() && this._client.isRoomEncrypted(this.roomId)) {\n      this._client._crypto.trackRoomDevices(this.roomId);\n    }\n\n    return result.fromServer;\n  }).catch(err => {\n    // allow retries on fail\n    this._membersPromise = null;\n    this.currentState.markOutOfBandMembersFailed();\n    throw err;\n  }); // update members in storage, but don't wait for it\n\n\n  inMemoryUpdate.then(fromServer => {\n    if (fromServer) {\n      const oobMembers = this.currentState.getMembers().filter(m => m.isOutOfBand()).map(m => m.events.member.event);\n\n      _logger.logger.log(`LL: telling store to write ${oobMembers.length}` + ` members for room ${this.roomId}`);\n\n      const store = this._client.store;\n      return store.setOutOfBandMembers(this.roomId, oobMembers) // swallow any IDB error as we don't want to fail\n      // because of this\n      .catch(err => {\n        _logger.logger.log(\"LL: storing OOB room members failed, oh well\", err);\n      });\n    }\n  }).catch(err => {\n    // as this is not awaited anywhere,\n    // at least show the error in the console\n    _logger.logger.error(err);\n  });\n  this._membersPromise = inMemoryUpdate;\n  return this._membersPromise;\n};\n/**\n * Removes the lazily loaded members from storage if needed\n */\n\n\nRoom.prototype.clearLoadedMembersIfNeeded = async function () {\n  if (this._opts.lazyLoadMembers && this._membersPromise) {\n    await this.loadMembersIfNeeded();\n    await this._client.store.clearOutOfBandMembers(this.roomId);\n    this.currentState.clearOutOfBandMembers();\n    this._membersPromise = null;\n  }\n};\n/**\n * called when sync receives this room in the leave section\n * to do cleanup after leaving a room. Possibly called multiple times.\n */\n\n\nRoom.prototype._cleanupAfterLeaving = function () {\n  this.clearLoadedMembersIfNeeded().catch(err => {\n    _logger.logger.error(`error after clearing loaded members from ` + `room ${this.roomId} after leaving`);\n\n    _logger.logger.log(err);\n  });\n};\n/**\n * Reset the live timeline of all timelineSets, and start new ones.\n *\n * <p>This is used when /sync returns a 'limited' timeline.\n *\n * @param {string=} backPaginationToken   token for back-paginating the new timeline\n * @param {string=} forwardPaginationToken token for forward-paginating the old live timeline,\n * if absent or null, all timelines are reset, removing old ones (including the previous live\n * timeline which would otherwise be unable to paginate forwards without this token).\n * Removing just the old live timeline whilst preserving previous ones is not supported.\n */\n\n\nRoom.prototype.resetLiveTimeline = function (backPaginationToken, forwardPaginationToken) {\n  for (let i = 0; i < this._timelineSets.length; i++) {\n    this._timelineSets[i].resetLiveTimeline(backPaginationToken, forwardPaginationToken);\n  }\n\n  this._fixUpLegacyTimelineFields();\n};\n/**\n * Fix up this.timeline, this.oldState and this.currentState\n *\n * @private\n */\n\n\nRoom.prototype._fixUpLegacyTimelineFields = function () {\n  // maintain this.timeline as a reference to the live timeline,\n  // and this.oldState and this.currentState as references to the\n  // state at the start and end of that timeline. These are more\n  // for backwards-compatibility than anything else.\n  this.timeline = this.getLiveTimeline().getEvents();\n  this.oldState = this.getLiveTimeline().getState(_eventTimeline.EventTimeline.BACKWARDS);\n  this.currentState = this.getLiveTimeline().getState(_eventTimeline.EventTimeline.FORWARDS);\n};\n/**\n * Returns whether there are any devices in the room that are unverified\n *\n * Note: Callers should first check if crypto is enabled on this device. If it is\n * disabled, then we aren't tracking room devices at all, so we can't answer this, and an\n * error will be thrown.\n *\n * @return {bool} the result\n */\n\n\nRoom.prototype.hasUnverifiedDevices = async function () {\n  if (!this._client.isRoomEncrypted(this.roomId)) {\n    return false;\n  }\n\n  const e2eMembers = await this.getEncryptionTargetMembers();\n\n  for (const member of e2eMembers) {\n    const devices = await this._client.getStoredDevicesForUser(member.userId);\n\n    if (devices.some(device => device.isUnverified())) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Return the timeline sets for this room.\n * @return {EventTimelineSet[]} array of timeline sets for this room\n */\n\n\nRoom.prototype.getTimelineSets = function () {\n  return this._timelineSets;\n};\n/**\n * Helper to return the main unfiltered timeline set for this room\n * @return {EventTimelineSet} room's unfiltered timeline set\n */\n\n\nRoom.prototype.getUnfilteredTimelineSet = function () {\n  return this._timelineSets[0];\n};\n/**\n * Get the timeline which contains the given event from the unfiltered set, if any\n *\n * @param {string} eventId  event ID to look for\n * @return {?module:models/event-timeline~EventTimeline} timeline containing\n * the given event, or null if unknown\n */\n\n\nRoom.prototype.getTimelineForEvent = function (eventId) {\n  return this.getUnfilteredTimelineSet().getTimelineForEvent(eventId);\n};\n/**\n * Add a new timeline to this room's unfiltered timeline set\n *\n * @return {module:models/event-timeline~EventTimeline} newly-created timeline\n */\n\n\nRoom.prototype.addTimeline = function () {\n  return this.getUnfilteredTimelineSet().addTimeline();\n};\n/**\n * Get an event which is stored in our unfiltered timeline set\n *\n * @param {string} eventId  event ID to look for\n * @return {?module:models/event.MatrixEvent} the given event, or undefined if unknown\n */\n\n\nRoom.prototype.findEventById = function (eventId) {\n  return this.getUnfilteredTimelineSet().findEventById(eventId);\n};\n/**\n * Get one of the notification counts for this room\n * @param {String} type The type of notification count to get. default: 'total'\n * @return {Number} The notification count, or undefined if there is no count\n *                  for this type.\n */\n\n\nRoom.prototype.getUnreadNotificationCount = function (type) {\n  type = type || 'total';\n  return this._notificationCounts[type];\n};\n/**\n * Set one of the notification counts for this room\n * @param {String} type The type of notification count to set.\n * @param {Number} count The new count\n */\n\n\nRoom.prototype.setUnreadNotificationCount = function (type, count) {\n  this._notificationCounts[type] = count;\n};\n\nRoom.prototype.setSummary = function (summary) {\n  const heroes = summary[\"m.heroes\"];\n  const joinedCount = summary[\"m.joined_member_count\"];\n  const invitedCount = summary[\"m.invited_member_count\"];\n\n  if (Number.isInteger(joinedCount)) {\n    this.currentState.setJoinedMemberCount(joinedCount);\n  }\n\n  if (Number.isInteger(invitedCount)) {\n    this.currentState.setInvitedMemberCount(invitedCount);\n  }\n\n  if (Array.isArray(heroes)) {\n    // be cautious about trusting server values,\n    // and make sure heroes doesn't contain our own id\n    // just to be sure\n    this._summaryHeroes = heroes.filter(userId => {\n      return userId !== this.myUserId;\n    });\n  }\n};\n/**\n * Whether to send encrypted messages to devices within this room.\n * @param {Boolean} value true to blacklist unverified devices, null\n * to use the global value for this room.\n */\n\n\nRoom.prototype.setBlacklistUnverifiedDevices = function (value) {\n  this._blacklistUnverifiedDevices = value;\n};\n/**\n * Whether to send encrypted messages to devices within this room.\n * @return {Boolean} true if blacklisting unverified devices, null\n * if the global value should be used for this room.\n */\n\n\nRoom.prototype.getBlacklistUnverifiedDevices = function () {\n  return this._blacklistUnverifiedDevices;\n};\n/**\n * Get the avatar URL for a room if one was set.\n * @param {String} baseUrl The homeserver base URL. See\n * {@link module:client~MatrixClient#getHomeserverUrl}.\n * @param {Number} width The desired width of the thumbnail.\n * @param {Number} height The desired height of the thumbnail.\n * @param {string} resizeMethod The thumbnail resize method to use, either\n * \"crop\" or \"scale\".\n * @param {boolean} allowDefault True to allow an identicon for this room if an\n * avatar URL wasn't explicitly set. Default: true. (Deprecated)\n * @return {?string} the avatar URL or null.\n */\n\n\nRoom.prototype.getAvatarUrl = function (baseUrl, width, height, resizeMethod, allowDefault) {\n  const roomAvatarEvent = this.currentState.getStateEvents(\"m.room.avatar\", \"\");\n\n  if (allowDefault === undefined) {\n    allowDefault = true;\n  }\n\n  if (!roomAvatarEvent && !allowDefault) {\n    return null;\n  }\n\n  const mainUrl = roomAvatarEvent ? roomAvatarEvent.getContent().url : null;\n\n  if (mainUrl) {\n    return (0, _contentRepo.getHttpUriForMxc)(baseUrl, mainUrl, width, height, resizeMethod);\n  } else if (allowDefault) {\n    return (0, _contentRepo.getIdenticonUri)(baseUrl, this.roomId, width, height);\n  }\n\n  return null;\n};\n/**\n * Get the aliases this room has according to the room's state\n * The aliases returned by this function may not necessarily\n * still point to this room.\n * @return {array} The room's alias as an array of strings\n */\n\n\nRoom.prototype.getAliases = function () {\n  const aliasStrings = [];\n  const aliasEvents = this.currentState.getStateEvents(\"m.room.aliases\");\n\n  if (aliasEvents) {\n    for (let i = 0; i < aliasEvents.length; ++i) {\n      const aliasEvent = aliasEvents[i];\n\n      if (utils.isArray(aliasEvent.getContent().aliases)) {\n        const filteredAliases = aliasEvent.getContent().aliases.filter(a => {\n          if (typeof a !== \"string\") return false;\n          if (a[0] !== '#') return false;\n          if (!a.endsWith(`:${aliasEvent.getStateKey()}`)) return false; // It's probably valid by here.\n\n          return true;\n        });\n        Array.prototype.push.apply(aliasStrings, filteredAliases);\n      }\n    }\n  }\n\n  return aliasStrings;\n};\n/**\n * Get this room's canonical alias\n * The alias returned by this function may not necessarily\n * still point to this room.\n * @return {?string} The room's canonical alias, or null if there is none\n */\n\n\nRoom.prototype.getCanonicalAlias = function () {\n  const canonicalAlias = this.currentState.getStateEvents(\"m.room.canonical_alias\", \"\");\n\n  if (canonicalAlias) {\n    return canonicalAlias.getContent().alias;\n  }\n\n  return null;\n};\n/**\n * Add events to a timeline\n *\n * <p>Will fire \"Room.timeline\" for each event added.\n *\n * @param {MatrixEvent[]} events A list of events to add.\n *\n * @param {boolean} toStartOfTimeline   True to add these events to the start\n * (oldest) instead of the end (newest) of the timeline. If true, the oldest\n * event will be the <b>last</b> element of 'events'.\n *\n * @param {module:models/event-timeline~EventTimeline} timeline   timeline to\n *    add events to.\n *\n * @param {string=} paginationToken   token for the next batch of events\n *\n * @fires module:client~MatrixClient#event:\"Room.timeline\"\n *\n */\n\n\nRoom.prototype.addEventsToTimeline = function (events, toStartOfTimeline, timeline, paginationToken) {\n  timeline.getTimelineSet().addEventsToTimeline(events, toStartOfTimeline, timeline, paginationToken);\n};\n/**\n * Get a member from the current room state.\n * @param {string} userId The user ID of the member.\n * @return {RoomMember} The member or <code>null</code>.\n */\n\n\nRoom.prototype.getMember = function (userId) {\n  return this.currentState.getMember(userId);\n};\n/**\n * Get a list of members whose membership state is \"join\".\n * @return {RoomMember[]} A list of currently joined members.\n */\n\n\nRoom.prototype.getJoinedMembers = function () {\n  return this.getMembersWithMembership(\"join\");\n};\n/**\n * Returns the number of joined members in this room\n * This method caches the result.\n * This is a wrapper around the method of the same name in roomState, returning\n * its result for the room's current state.\n * @return {integer} The number of members in this room whose membership is 'join'\n */\n\n\nRoom.prototype.getJoinedMemberCount = function () {\n  return this.currentState.getJoinedMemberCount();\n};\n/**\n * Returns the number of invited members in this room\n * @return {integer} The number of members in this room whose membership is 'invite'\n */\n\n\nRoom.prototype.getInvitedMemberCount = function () {\n  return this.currentState.getInvitedMemberCount();\n};\n/**\n * Returns the number of invited + joined members in this room\n * @return {integer} The number of members in this room whose membership is 'invite' or 'join'\n */\n\n\nRoom.prototype.getInvitedAndJoinedMemberCount = function () {\n  return this.getInvitedMemberCount() + this.getJoinedMemberCount();\n};\n/**\n * Get a list of members with given membership state.\n * @param {string} membership The membership state.\n * @return {RoomMember[]} A list of members with the given membership state.\n */\n\n\nRoom.prototype.getMembersWithMembership = function (membership) {\n  return utils.filter(this.currentState.getMembers(), function (m) {\n    return m.membership === membership;\n  });\n};\n/**\n * Get a list of members we should be encrypting for in this room\n * @return {Promise<RoomMember[]>} A list of members who\n * we should encrypt messages for in this room.\n */\n\n\nRoom.prototype.getEncryptionTargetMembers = async function () {\n  await this.loadMembersIfNeeded();\n  let members = this.getMembersWithMembership(\"join\");\n\n  if (this.shouldEncryptForInvitedMembers()) {\n    members = members.concat(this.getMembersWithMembership(\"invite\"));\n  }\n\n  return members;\n};\n/**\n * Determine whether we should encrypt messages for invited users in this room\n * @return {boolean} if we should encrypt messages for invited users\n */\n\n\nRoom.prototype.shouldEncryptForInvitedMembers = function () {\n  const ev = this.currentState.getStateEvents(\"m.room.history_visibility\", \"\");\n  return ev && ev.getContent() && ev.getContent().history_visibility !== \"joined\";\n};\n/**\n * Get the default room name (i.e. what a given user would see if the\n * room had no m.room.name)\n * @param {string} userId The userId from whose perspective we want\n * to calculate the default name\n * @return {string} The default room name\n */\n\n\nRoom.prototype.getDefaultRoomName = function (userId) {\n  return calculateRoomName(this, userId, true);\n};\n/**\n* Check if the given user_id has the given membership state.\n* @param {string} userId The user ID to check.\n* @param {string} membership The membership e.g. <code>'join'</code>\n* @return {boolean} True if this user_id has the given membership state.\n*/\n\n\nRoom.prototype.hasMembershipState = function (userId, membership) {\n  const member = this.getMember(userId);\n\n  if (!member) {\n    return false;\n  }\n\n  return member.membership === membership;\n};\n/**\n * Add a timelineSet for this room with the given filter\n * @param {Filter} filter  The filter to be applied to this timelineSet\n * @return {EventTimelineSet}  The timelineSet\n */\n\n\nRoom.prototype.getOrCreateFilteredTimelineSet = function (filter) {\n  if (this._filteredTimelineSets[filter.filterId]) {\n    return this._filteredTimelineSets[filter.filterId];\n  }\n\n  const opts = Object.assign({\n    filter: filter\n  }, this._opts);\n  const timelineSet = new _eventTimelineSet.EventTimelineSet(this, opts);\n  this.reEmitter.reEmit(timelineSet, [\"Room.timeline\", \"Room.timelineReset\"]);\n  this._filteredTimelineSets[filter.filterId] = timelineSet;\n\n  this._timelineSets.push(timelineSet); // populate up the new timelineSet with filtered events from our live\n  // unfiltered timeline.\n  //\n  // XXX: This is risky as our timeline\n  // may have grown huge and so take a long time to filter.\n  // see https://github.com/vector-im/vector-web/issues/2109\n\n\n  const unfilteredLiveTimeline = this.getLiveTimeline();\n  unfilteredLiveTimeline.getEvents().forEach(function (event) {\n    timelineSet.addLiveEvent(event);\n  }); // find the earliest unfiltered timeline\n\n  let timeline = unfilteredLiveTimeline;\n\n  while (timeline.getNeighbouringTimeline(_eventTimeline.EventTimeline.BACKWARDS)) {\n    timeline = timeline.getNeighbouringTimeline(_eventTimeline.EventTimeline.BACKWARDS);\n  }\n\n  timelineSet.getLiveTimeline().setPaginationToken(timeline.getPaginationToken(_eventTimeline.EventTimeline.BACKWARDS), _eventTimeline.EventTimeline.BACKWARDS); // alternatively, we could try to do something like this to try and re-paginate\n  // in the filtered events from nothing, but Mark says it's an abuse of the API\n  // to do so:\n  //\n  // timelineSet.resetLiveTimeline(\n  //      unfilteredLiveTimeline.getPaginationToken(EventTimeline.FORWARDS)\n  // );\n\n  return timelineSet;\n};\n/**\n * Forget the timelineSet for this room with the given filter\n *\n * @param {Filter} filter  the filter whose timelineSet is to be forgotten\n */\n\n\nRoom.prototype.removeFilteredTimelineSet = function (filter) {\n  const timelineSet = this._filteredTimelineSets[filter.filterId];\n  delete this._filteredTimelineSets[filter.filterId];\n\n  const i = this._timelineSets.indexOf(timelineSet);\n\n  if (i > -1) {\n    this._timelineSets.splice(i, 1);\n  }\n};\n/**\n * Add an event to the end of this room's live timelines. Will fire\n * \"Room.timeline\".\n *\n * @param {MatrixEvent} event Event to be added\n * @param {string?} duplicateStrategy 'ignore' or 'replace'\n * @fires module:client~MatrixClient#event:\"Room.timeline\"\n * @private\n */\n\n\nRoom.prototype._addLiveEvent = function (event, duplicateStrategy) {\n  if (event.isRedaction()) {\n    const redactId = event.event.redacts; // if we know about this event, redact its contents now.\n\n    const redactedEvent = this.getUnfilteredTimelineSet().findEventById(redactId);\n\n    if (redactedEvent) {\n      redactedEvent.makeRedacted(event); // If this is in the current state, replace it with the redacted version\n\n      if (redactedEvent.getStateKey()) {\n        const currentStateEvent = this.currentState.getStateEvents(redactedEvent.getType(), redactedEvent.getStateKey());\n\n        if (currentStateEvent.getId() === redactedEvent.getId()) {\n          this.currentState.setStateEvents([redactedEvent]);\n        }\n      }\n\n      this.emit(\"Room.redaction\", event, this); // TODO: we stash user displaynames (among other things) in\n      // RoomMember objects which are then attached to other events\n      // (in the sender and target fields). We should get those\n      // RoomMember objects to update themselves when the events that\n      // they are based on are changed.\n    } // FIXME: apply redactions to notification list\n    // NB: We continue to add the redaction event to the timeline so\n    // clients can say \"so and so redacted an event\" if they wish to. Also\n    // this may be needed to trigger an update.\n\n  }\n\n  if (event.getUnsigned().transaction_id) {\n    const existingEvent = this._txnToEvent[event.getUnsigned().transaction_id];\n\n    if (existingEvent) {\n      // remote echo of an event we sent earlier\n      this._handleRemoteEcho(event, existingEvent);\n\n      return;\n    }\n  } // add to our timeline sets\n\n\n  for (let i = 0; i < this._timelineSets.length; i++) {\n    this._timelineSets[i].addLiveEvent(event, duplicateStrategy);\n  } // synthesize and inject implicit read receipts\n  // Done after adding the event because otherwise the app would get a read receipt\n  // pointing to an event that wasn't yet in the timeline\n  // Don't synthesize RR for m.room.redaction as this causes the RR to go missing.\n\n\n  if (event.sender && event.getType() !== \"m.room.redaction\") {\n    this.addReceipt(synthesizeReceipt(event.sender.userId, event, \"m.read\"), true); // Any live events from a user could be taken as implicit\n    // presence information: evidence that they are currently active.\n    // ...except in a world where we use 'user.currentlyActive' to reduce\n    // presence spam, this isn't very useful - we'll get a transition when\n    // they are no longer currently active anyway. So don't bother to\n    // reset the lastActiveAgo and lastPresenceTs from the RoomState's user.\n  }\n};\n/**\n * Add a pending outgoing event to this room.\n *\n * <p>The event is added to either the pendingEventList, or the live timeline,\n * depending on the setting of opts.pendingEventOrdering.\n *\n * <p>This is an internal method, intended for use by MatrixClient.\n *\n * @param {module:models/event.MatrixEvent} event The event to add.\n *\n * @param {string} txnId   Transaction id for this outgoing event\n *\n * @fires module:client~MatrixClient#event:\"Room.localEchoUpdated\"\n *\n * @throws if the event doesn't have status SENDING, or we aren't given a\n * unique transaction id.\n */\n\n\nRoom.prototype.addPendingEvent = function (event, txnId) {\n  if (event.status !== _event.EventStatus.SENDING) {\n    throw new Error(\"addPendingEvent called on an event with status \" + event.status);\n  }\n\n  if (this._txnToEvent[txnId]) {\n    throw new Error(\"addPendingEvent called on an event with known txnId \" + txnId);\n  } // call setEventMetadata to set up event.sender etc\n  // as event is shared over all timelineSets, we set up its metadata based\n  // on the unfiltered timelineSet.\n\n\n  _eventTimeline.EventTimeline.setEventMetadata(event, this.getLiveTimeline().getState(_eventTimeline.EventTimeline.FORWARDS), false);\n\n  this._txnToEvent[txnId] = event;\n\n  if (this._opts.pendingEventOrdering == \"detached\") {\n    if (this._pendingEventList.some(e => e.status === _event.EventStatus.NOT_SENT)) {\n      _logger.logger.warn(\"Setting event as NOT_SENT due to messages in the same state\");\n\n      event.setStatus(_event.EventStatus.NOT_SENT);\n    }\n\n    this._pendingEventList.push(event);\n\n    if (event.isRelation()) {\n      // For pending events, add them to the relations collection immediately.\n      // (The alternate case below already covers this as part of adding to\n      // the timeline set.)\n      this._aggregateNonLiveRelation(event);\n    }\n\n    if (event.isRedaction()) {\n      const redactId = event.event.redacts;\n\n      let redactedEvent = this._pendingEventList && this._pendingEventList.find(e => e.getId() === redactId);\n\n      if (!redactedEvent) {\n        redactedEvent = this.getUnfilteredTimelineSet().findEventById(redactId);\n      }\n\n      if (redactedEvent) {\n        redactedEvent.markLocallyRedacted(event);\n        this.emit(\"Room.redaction\", event, this);\n      }\n    }\n  } else {\n    for (let i = 0; i < this._timelineSets.length; i++) {\n      const timelineSet = this._timelineSets[i];\n\n      if (timelineSet.getFilter()) {\n        if (timelineSet.getFilter().filterRoomTimeline([event]).length) {\n          timelineSet.addEventToTimeline(event, timelineSet.getLiveTimeline(), false);\n        }\n      } else {\n        timelineSet.addEventToTimeline(event, timelineSet.getLiveTimeline(), false);\n      }\n    }\n  }\n\n  this.emit(\"Room.localEchoUpdated\", event, this, null, null);\n};\n/**\n * Used to aggregate the local echo for a relation, and also\n * for re-applying a relation after it's redaction has been cancelled,\n * as the local echo for the redaction of the relation would have\n * un-aggregated the relation. Note that this is different from regular messages,\n * which are just kept detached for their local echo.\n *\n * Also note that live events are aggregated in the live EventTimelineSet.\n * @param {module:models/event.MatrixEvent} event the relation event that needs to be aggregated.\n */\n\n\nRoom.prototype._aggregateNonLiveRelation = function (event) {\n  // TODO: We should consider whether this means it would be a better\n  // design to lift the relations handling up to the room instead.\n  for (let i = 0; i < this._timelineSets.length; i++) {\n    const timelineSet = this._timelineSets[i];\n\n    if (timelineSet.getFilter()) {\n      if (timelineSet.getFilter().filterRoomTimeline([event]).length) {\n        timelineSet.aggregateRelations(event);\n      }\n    } else {\n      timelineSet.aggregateRelations(event);\n    }\n  }\n};\n/**\n * Deal with the echo of a message we sent.\n *\n * <p>We move the event to the live timeline if it isn't there already, and\n * update it.\n *\n * @param {module:models/event.MatrixEvent} remoteEvent   The event received from\n *    /sync\n * @param {module:models/event.MatrixEvent} localEvent    The local echo, which\n *    should be either in the _pendingEventList or the timeline.\n *\n * @fires module:client~MatrixClient#event:\"Room.localEchoUpdated\"\n * @private\n */\n\n\nRoom.prototype._handleRemoteEcho = function (remoteEvent, localEvent) {\n  const oldEventId = localEvent.getId();\n  const newEventId = remoteEvent.getId();\n  const oldStatus = localEvent.status; // no longer pending\n\n  delete this._txnToEvent[remoteEvent.getUnsigned().transaction_id]; // if it's in the pending list, remove it\n\n  if (this._pendingEventList) {\n    utils.removeElement(this._pendingEventList, function (ev) {\n      return ev.getId() == oldEventId;\n    }, false);\n  } // replace the event source (this will preserve the plaintext payload if\n  // any, which is good, because we don't want to try decoding it again).\n\n\n  localEvent.handleRemoteEcho(remoteEvent.event);\n\n  for (let i = 0; i < this._timelineSets.length; i++) {\n    const timelineSet = this._timelineSets[i]; // if it's already in the timeline, update the timeline map. If it's not, add it.\n\n    timelineSet.handleRemoteEcho(localEvent, oldEventId, newEventId);\n  }\n\n  this.emit(\"Room.localEchoUpdated\", localEvent, this, oldEventId, oldStatus);\n};\n/* a map from current event status to a list of allowed next statuses\n */\n\n\nconst ALLOWED_TRANSITIONS = {};\nALLOWED_TRANSITIONS[_event.EventStatus.ENCRYPTING] = [_event.EventStatus.SENDING, _event.EventStatus.NOT_SENT];\nALLOWED_TRANSITIONS[_event.EventStatus.SENDING] = [_event.EventStatus.ENCRYPTING, _event.EventStatus.QUEUED, _event.EventStatus.NOT_SENT, _event.EventStatus.SENT];\nALLOWED_TRANSITIONS[_event.EventStatus.QUEUED] = [_event.EventStatus.SENDING, _event.EventStatus.CANCELLED];\nALLOWED_TRANSITIONS[_event.EventStatus.SENT] = [];\nALLOWED_TRANSITIONS[_event.EventStatus.NOT_SENT] = [_event.EventStatus.SENDING, _event.EventStatus.QUEUED, _event.EventStatus.CANCELLED];\nALLOWED_TRANSITIONS[_event.EventStatus.CANCELLED] = [];\n/**\n * Update the status / event id on a pending event, to reflect its transmission\n * progress.\n *\n * <p>This is an internal method.\n *\n * @param {MatrixEvent} event      local echo event\n * @param {EventStatus} newStatus  status to assign\n * @param {string} newEventId      new event id to assign. Ignored unless\n *    newStatus == EventStatus.SENT.\n * @fires module:client~MatrixClient#event:\"Room.localEchoUpdated\"\n */\n\nRoom.prototype.updatePendingEvent = function (event, newStatus, newEventId) {\n  _logger.logger.log(`setting pendingEvent status to ${newStatus} in ${event.getRoomId()}`); // if the message was sent, we expect an event id\n\n\n  if (newStatus == _event.EventStatus.SENT && !newEventId) {\n    throw new Error(\"updatePendingEvent called with status=SENT, \" + \"but no new event id\");\n  } // SENT races against /sync, so we have to special-case it.\n\n\n  if (newStatus == _event.EventStatus.SENT) {\n    const timeline = this.getUnfilteredTimelineSet().eventIdToTimeline(newEventId);\n\n    if (timeline) {\n      // we've already received the event via the event stream.\n      // nothing more to do here.\n      return;\n    }\n  }\n\n  const oldStatus = event.status;\n  const oldEventId = event.getId();\n\n  if (!oldStatus) {\n    throw new Error(\"updatePendingEventStatus called on an event which is \" + \"not a local echo.\");\n  }\n\n  const allowed = ALLOWED_TRANSITIONS[oldStatus];\n\n  if (!allowed || allowed.indexOf(newStatus) < 0) {\n    throw new Error(\"Invalid EventStatus transition \" + oldStatus + \"->\" + newStatus);\n  }\n\n  event.setStatus(newStatus);\n\n  if (newStatus == _event.EventStatus.SENT) {\n    // update the event id\n    event.replaceLocalEventId(newEventId); // if the event was already in the timeline (which will be the case if\n    // opts.pendingEventOrdering==chronological), we need to update the\n    // timeline map.\n\n    for (let i = 0; i < this._timelineSets.length; i++) {\n      this._timelineSets[i].replaceEventId(oldEventId, newEventId);\n    }\n  } else if (newStatus == _event.EventStatus.CANCELLED) {\n    // remove it from the pending event list, or the timeline.\n    if (this._pendingEventList) {\n      const idx = this._pendingEventList.findIndex(ev => ev.getId() === oldEventId);\n\n      if (idx !== -1) {\n        const [removedEvent] = this._pendingEventList.splice(idx, 1);\n\n        if (removedEvent.isRedaction()) {\n          this._revertRedactionLocalEcho(removedEvent);\n        }\n      }\n    }\n\n    this.removeEvent(oldEventId);\n  }\n\n  this.emit(\"Room.localEchoUpdated\", event, this, oldEventId, oldStatus);\n};\n\nRoom.prototype._revertRedactionLocalEcho = function (redactionEvent) {\n  const redactId = redactionEvent.event.redacts;\n\n  if (!redactId) {\n    return;\n  }\n\n  const redactedEvent = this.getUnfilteredTimelineSet().findEventById(redactId);\n\n  if (redactedEvent) {\n    redactedEvent.unmarkLocallyRedacted(); // re-render after undoing redaction\n\n    this.emit(\"Room.redactionCancelled\", redactionEvent, this); // reapply relation now redaction failed\n\n    if (redactedEvent.isRelation()) {\n      this._aggregateNonLiveRelation(redactedEvent);\n    }\n  }\n};\n/**\n * Add some events to this room. This can include state events, message\n * events and typing notifications. These events are treated as \"live\" so\n * they will go to the end of the timeline.\n *\n * @param {MatrixEvent[]} events A list of events to add.\n *\n * @param {string} duplicateStrategy Optional. Applies to events in the\n * timeline only. If this is 'replace' then if a duplicate is encountered, the\n * event passed to this function will replace the existing event in the\n * timeline. If this is not specified, or is 'ignore', then the event passed to\n * this function will be ignored entirely, preserving the existing event in the\n * timeline. Events are identical based on their event ID <b>only</b>.\n *\n * @throws If <code>duplicateStrategy</code> is not falsey, 'replace' or 'ignore'.\n */\n\n\nRoom.prototype.addLiveEvents = function (events, duplicateStrategy) {\n  let i;\n\n  if (duplicateStrategy && [\"replace\", \"ignore\"].indexOf(duplicateStrategy) === -1) {\n    throw new Error(\"duplicateStrategy MUST be either 'replace' or 'ignore'\");\n  } // sanity check that the live timeline is still live\n\n\n  for (i = 0; i < this._timelineSets.length; i++) {\n    const liveTimeline = this._timelineSets[i].getLiveTimeline();\n\n    if (liveTimeline.getPaginationToken(_eventTimeline.EventTimeline.FORWARDS)) {\n      throw new Error(\"live timeline \" + i + \" is no longer live - it has a pagination token \" + \"(\" + liveTimeline.getPaginationToken(_eventTimeline.EventTimeline.FORWARDS) + \")\");\n    }\n\n    if (liveTimeline.getNeighbouringTimeline(_eventTimeline.EventTimeline.FORWARDS)) {\n      throw new Error(\"live timeline \" + i + \" is no longer live - \" + \"it has a neighbouring timeline\");\n    }\n  }\n\n  for (i = 0; i < events.length; i++) {\n    // TODO: We should have a filter to say \"only add state event\n    // types X Y Z to the timeline\".\n    this._addLiveEvent(events[i], duplicateStrategy);\n  }\n};\n/**\n * Adds/handles ephemeral events such as typing notifications and read receipts.\n * @param {MatrixEvent[]} events A list of events to process\n */\n\n\nRoom.prototype.addEphemeralEvents = function (events) {\n  for (const event of events) {\n    if (event.getType() === 'm.typing') {\n      this.currentState.setTypingEvent(event);\n    } else if (event.getType() === 'm.receipt') {\n      this.addReceipt(event);\n    } // else ignore - life is too short for us to care about these events\n\n  }\n};\n/**\n * Removes events from this room.\n * @param {String[]} eventIds A list of eventIds to remove.\n */\n\n\nRoom.prototype.removeEvents = function (eventIds) {\n  for (let i = 0; i < eventIds.length; ++i) {\n    this.removeEvent(eventIds[i]);\n  }\n};\n/**\n * Removes a single event from this room.\n *\n * @param {String} eventId  The id of the event to remove\n *\n * @return {bool} true if the event was removed from any of the room's timeline sets\n */\n\n\nRoom.prototype.removeEvent = function (eventId) {\n  let removedAny = false;\n\n  for (let i = 0; i < this._timelineSets.length; i++) {\n    const removed = this._timelineSets[i].removeEvent(eventId);\n\n    if (removed) {\n      if (removed.isRedaction()) {\n        this._revertRedactionLocalEcho(removed);\n      }\n\n      removedAny = true;\n    }\n  }\n\n  return removedAny;\n};\n/**\n * Recalculate various aspects of the room, including the room name and\n * room summary. Call this any time the room's current state is modified.\n * May fire \"Room.name\" if the room name is updated.\n * @fires module:client~MatrixClient#event:\"Room.name\"\n */\n\n\nRoom.prototype.recalculate = function () {\n  // set fake stripped state events if this is an invite room so logic remains\n  // consistent elsewhere.\n  const self = this;\n  const membershipEvent = this.currentState.getStateEvents(\"m.room.member\", this.myUserId);\n\n  if (membershipEvent && membershipEvent.getContent().membership === \"invite\") {\n    const strippedStateEvents = membershipEvent.event.invite_room_state || [];\n    utils.forEach(strippedStateEvents, function (strippedEvent) {\n      const existingEvent = self.currentState.getStateEvents(strippedEvent.type, strippedEvent.state_key);\n\n      if (!existingEvent) {\n        // set the fake stripped event instead\n        self.currentState.setStateEvents([new _event.MatrixEvent({\n          type: strippedEvent.type,\n          state_key: strippedEvent.state_key,\n          content: strippedEvent.content,\n          event_id: \"$fake\" + Date.now(),\n          room_id: self.roomId,\n          user_id: self.myUserId // technically a lie\n\n        })]);\n      }\n    });\n  }\n\n  const oldName = this.name;\n  this.name = calculateRoomName(this, this.myUserId);\n  this.summary = new _roomSummary.RoomSummary(this.roomId, {\n    title: this.name\n  });\n\n  if (oldName !== this.name) {\n    this.emit(\"Room.name\", this);\n  }\n};\n/**\n * Get a list of user IDs who have <b>read up to</b> the given event.\n * @param {MatrixEvent} event the event to get read receipts for.\n * @return {String[]} A list of user IDs.\n */\n\n\nRoom.prototype.getUsersReadUpTo = function (event) {\n  return this.getReceiptsForEvent(event).filter(function (receipt) {\n    return receipt.type === \"m.read\";\n  }).map(function (receipt) {\n    return receipt.userId;\n  });\n};\n/**\n * Get the ID of the event that a given user has read up to, or null if we\n * have received no read receipts from them.\n * @param {String} userId The user ID to get read receipt event ID for\n * @param {Boolean} ignoreSynthesized If true, return only receipts that have been\n *                                    sent by the server, not implicit ones generated\n *                                    by the JS SDK.\n * @return {String} ID of the latest event that the given user has read, or null.\n */\n\n\nRoom.prototype.getEventReadUpTo = function (userId, ignoreSynthesized) {\n  let receipts = this._receipts;\n\n  if (ignoreSynthesized) {\n    receipts = this._realReceipts;\n  }\n\n  if (receipts[\"m.read\"] === undefined || receipts[\"m.read\"][userId] === undefined) {\n    return null;\n  }\n\n  return receipts[\"m.read\"][userId].eventId;\n};\n/**\n * Determines if the given user has read a particular event ID with the known\n * history of the room. This is not a definitive check as it relies only on\n * what is available to the room at the time of execution.\n * @param {String} userId The user ID to check the read state of.\n * @param {String} eventId The event ID to check if the user read.\n * @returns {Boolean} True if the user has read the event, false otherwise.\n */\n\n\nRoom.prototype.hasUserReadEvent = function (userId, eventId) {\n  const readUpToId = this.getEventReadUpTo(userId, false);\n  if (readUpToId === eventId) return true;\n\n  if (this.timeline.length && this.timeline[this.timeline.length - 1].getSender() && this.timeline[this.timeline.length - 1].getSender() === userId) {\n    // It doesn't matter where the event is in the timeline, the user has read\n    // it because they've sent the latest event.\n    return true;\n  }\n\n  for (let i = this.timeline.length - 1; i >= 0; --i) {\n    const ev = this.timeline[i]; // If we encounter the target event first, the user hasn't read it\n    // however if we encounter the readUpToId first then the user has read\n    // it. These rules apply because we're iterating bottom-up.\n\n    if (ev.getId() === eventId) return false;\n    if (ev.getId() === readUpToId) return true;\n  } // We don't know if the user has read it, so assume not.\n\n\n  return false;\n};\n/**\n * Get a list of receipts for the given event.\n * @param {MatrixEvent} event the event to get receipts for\n * @return {Object[]} A list of receipts with a userId, type and data keys or\n * an empty list.\n */\n\n\nRoom.prototype.getReceiptsForEvent = function (event) {\n  return this._receiptCacheByEventId[event.getId()] || [];\n};\n/**\n * Add a receipt event to the room.\n * @param {MatrixEvent} event The m.receipt event.\n * @param {Boolean} fake True if this event is implicit\n */\n\n\nRoom.prototype.addReceipt = function (event, fake) {\n  // event content looks like:\n  // content: {\n  //   $event_id: {\n  //     $receipt_type: {\n  //       $user_id: {\n  //         ts: $timestamp\n  //       }\n  //     }\n  //   }\n  // }\n  if (fake === undefined) {\n    fake = false;\n  }\n\n  if (!fake) {\n    this._addReceiptsToStructure(event, this._realReceipts); // we don't bother caching real receipts by event ID\n    // as there's nothing that would read it.\n\n  }\n\n  this._addReceiptsToStructure(event, this._receipts);\n\n  this._receiptCacheByEventId = this._buildReceiptCache(this._receipts); // send events after we've regenerated the cache, otherwise things that\n  // listened for the event would read from a stale cache\n\n  this.emit(\"Room.receipt\", event, this);\n};\n/**\n * Add a receipt event to the room.\n * @param {MatrixEvent} event The m.receipt event.\n * @param {Object} receipts The object to add receipts to\n */\n\n\nRoom.prototype._addReceiptsToStructure = function (event, receipts) {\n  const self = this;\n  utils.keys(event.getContent()).forEach(function (eventId) {\n    utils.keys(event.getContent()[eventId]).forEach(function (receiptType) {\n      utils.keys(event.getContent()[eventId][receiptType]).forEach(function (userId) {\n        const receipt = event.getContent()[eventId][receiptType][userId];\n\n        if (!receipts[receiptType]) {\n          receipts[receiptType] = {};\n        }\n\n        const existingReceipt = receipts[receiptType][userId];\n\n        if (!existingReceipt) {\n          receipts[receiptType][userId] = {};\n        } else {\n          // we only want to add this receipt if we think it is later\n          // than the one we already have. (This is managed\n          // server-side, but because we synthesize RRs locally we\n          // have to do it here too.)\n          const ordering = self.getUnfilteredTimelineSet().compareEventOrdering(existingReceipt.eventId, eventId);\n\n          if (ordering !== null && ordering >= 0) {\n            return;\n          }\n        }\n\n        receipts[receiptType][userId] = {\n          eventId: eventId,\n          data: receipt\n        };\n      });\n    });\n  });\n};\n/**\n * Build and return a map of receipts by event ID\n * @param {Object} receipts A map of receipts\n * @return {Object} Map of receipts by event ID\n */\n\n\nRoom.prototype._buildReceiptCache = function (receipts) {\n  const receiptCacheByEventId = {};\n  utils.keys(receipts).forEach(function (receiptType) {\n    utils.keys(receipts[receiptType]).forEach(function (userId) {\n      const receipt = receipts[receiptType][userId];\n\n      if (!receiptCacheByEventId[receipt.eventId]) {\n        receiptCacheByEventId[receipt.eventId] = [];\n      }\n\n      receiptCacheByEventId[receipt.eventId].push({\n        userId: userId,\n        type: receiptType,\n        data: receipt.data\n      });\n    });\n  });\n  return receiptCacheByEventId;\n};\n/**\n * Add a temporary local-echo receipt to the room to reflect in the\n * client the fact that we've sent one.\n * @param {string} userId The user ID if the receipt sender\n * @param {MatrixEvent} e The event that is to be acknowledged\n * @param {string} receiptType The type of receipt\n */\n\n\nRoom.prototype._addLocalEchoReceipt = function (userId, e, receiptType) {\n  this.addReceipt(synthesizeReceipt(userId, e, receiptType), true);\n};\n/**\n * Update the room-tag event for the room.  The previous one is overwritten.\n * @param {MatrixEvent} event the m.tag event\n */\n\n\nRoom.prototype.addTags = function (event) {\n  // event content looks like:\n  // content: {\n  //    tags: {\n  //       $tagName: { $metadata: $value },\n  //       $tagName: { $metadata: $value },\n  //    }\n  // }\n  // XXX: do we need to deep copy here?\n  this.tags = event.getContent().tags || {}; // XXX: we could do a deep-comparison to see if the tags have really\n  // changed - but do we want to bother?\n\n  this.emit(\"Room.tags\", event, this);\n};\n/**\n * Update the account_data events for this room, overwriting events of the same type.\n * @param {Array<MatrixEvent>} events an array of account_data events to add\n */\n\n\nRoom.prototype.addAccountData = function (events) {\n  for (let i = 0; i < events.length; i++) {\n    const event = events[i];\n\n    if (event.getType() === \"m.tag\") {\n      this.addTags(event);\n    }\n\n    this.accountData[event.getType()] = event;\n    this.emit(\"Room.accountData\", event, this);\n  }\n};\n/**\n * Access account_data event of given event type for this room\n * @param {string} type the type of account_data event to be accessed\n * @return {?MatrixEvent} the account_data event in question\n */\n\n\nRoom.prototype.getAccountData = function (type) {\n  return this.accountData[type];\n};\n/**\n * Returns wheter the syncing user has permission to send a message in the room\n * @return {boolean} true if the user should be permitted to send\n *                   message events into the room.\n */\n\n\nRoom.prototype.maySendMessage = function () {\n  return this.getMyMembership() === 'join' && this.currentState.maySendEvent('m.room.message', this.myUserId);\n};\n/**\n * This is an internal method. Calculates the name of the room from the current\n * room state.\n * @param {Room} room The matrix room.\n * @param {string} userId The client's user ID. Used to filter room members\n * correctly.\n * @param {bool} ignoreRoomNameEvent Return the implicit room name that we'd see if there\n * was no m.room.name event.\n * @return {string} The calculated room name.\n */\n\n\nfunction calculateRoomName(room, userId, ignoreRoomNameEvent) {\n  if (!ignoreRoomNameEvent) {\n    // check for an alias, if any. for now, assume first alias is the\n    // official one.\n    const mRoomName = room.currentState.getStateEvents(\"m.room.name\", \"\");\n\n    if (mRoomName && mRoomName.getContent() && mRoomName.getContent().name) {\n      return mRoomName.getContent().name;\n    }\n  }\n\n  let alias = room.getCanonicalAlias();\n\n  if (!alias) {\n    const aliases = room.getAliases();\n\n    if (aliases.length) {\n      alias = aliases[0];\n    }\n  }\n\n  if (alias) {\n    return alias;\n  }\n\n  const joinedMemberCount = room.currentState.getJoinedMemberCount();\n  const invitedMemberCount = room.currentState.getInvitedMemberCount(); // -1 because these numbers include the syncing user\n\n  const inviteJoinCount = joinedMemberCount + invitedMemberCount - 1; // get members that are NOT ourselves and are actually in the room.\n\n  let otherNames = null;\n\n  if (room._summaryHeroes) {\n    // if we have a summary, the member state events\n    // should be in the room state\n    otherNames = room._summaryHeroes.map(userId => {\n      const member = room.getMember(userId);\n      return member ? member.name : userId;\n    });\n  } else {\n    let otherMembers = room.currentState.getMembers().filter(m => {\n      return m.userId !== userId && (m.membership === \"invite\" || m.membership === \"join\");\n    }); // make sure members have stable order\n\n    otherMembers.sort((a, b) => a.userId.localeCompare(b.userId)); // only 5 first members, immitate _summaryHeroes\n\n    otherMembers = otherMembers.slice(0, 5);\n    otherNames = otherMembers.map(m => m.name);\n  }\n\n  if (inviteJoinCount) {\n    return memberNamesToRoomName(otherNames, inviteJoinCount);\n  }\n\n  const myMembership = room.getMyMembership(); // if I have created a room and invited people throuh\n  // 3rd party invites\n\n  if (myMembership == 'join') {\n    const thirdPartyInvites = room.currentState.getStateEvents(\"m.room.third_party_invite\");\n\n    if (thirdPartyInvites && thirdPartyInvites.length) {\n      const thirdPartyNames = thirdPartyInvites.map(i => {\n        return i.getContent().display_name;\n      });\n      return `Inviting ${memberNamesToRoomName(thirdPartyNames)}`;\n    }\n  } // let's try to figure out who was here before\n\n\n  let leftNames = otherNames; // if we didn't have heroes, try finding them in the room state\n\n  if (!leftNames.length) {\n    leftNames = room.currentState.getMembers().filter(m => {\n      return m.userId !== userId && m.membership !== \"invite\" && m.membership !== \"join\";\n    }).map(m => m.name);\n  }\n\n  if (leftNames.length) {\n    return `Empty room (was ${memberNamesToRoomName(leftNames)})`;\n  } else {\n    return \"Empty room\";\n  }\n}\n\nfunction memberNamesToRoomName(names, count = names.length + 1) {\n  const countWithoutMe = count - 1;\n\n  if (!names.length) {\n    return \"Empty room\";\n  } else if (names.length === 1 && countWithoutMe <= 1) {\n    return names[0];\n  } else if (names.length === 2 && countWithoutMe <= 2) {\n    return `${names[0]} and ${names[1]}`;\n  } else {\n    const plural = countWithoutMe > 1;\n\n    if (plural) {\n      return `${names[0]} and ${countWithoutMe} others`;\n    } else {\n      return `${names[0]} and 1 other`;\n    }\n  }\n}\n/**\n * Fires when an event we had previously received is redacted.\n *\n * (Note this is *not* fired when the redaction happens before we receive the\n * event).\n *\n * @event module:client~MatrixClient#\"Room.redaction\"\n * @param {MatrixEvent} event The matrix redaction event\n * @param {Room} room The room containing the redacted event\n */\n\n/**\n * Fires when an event that was previously redacted isn't anymore.\n * This happens when the redaction couldn't be sent and\n * was subsequently cancelled by the user. Redactions have a local echo\n * which is undone in this scenario.\n *\n * @event module:client~MatrixClient#\"Room.redactionCancelled\"\n * @param {MatrixEvent} event The matrix redaction event that was cancelled.\n * @param {Room} room The room containing the unredacted event\n */\n\n/**\n * Fires whenever the name of a room is updated.\n * @event module:client~MatrixClient#\"Room.name\"\n * @param {Room} room The room whose Room.name was updated.\n * @example\n * matrixClient.on(\"Room.name\", function(room){\n *   var newName = room.name;\n * });\n */\n\n/**\n * Fires whenever a receipt is received for a room\n * @event module:client~MatrixClient#\"Room.receipt\"\n * @param {event} event The receipt event\n * @param {Room} room The room whose receipts was updated.\n * @example\n * matrixClient.on(\"Room.receipt\", function(event, room){\n *   var receiptContent = event.getContent();\n * });\n */\n\n/**\n * Fires whenever a room's tags are updated.\n * @event module:client~MatrixClient#\"Room.tags\"\n * @param {event} event The tags event\n * @param {Room} room The room whose Room.tags was updated.\n * @example\n * matrixClient.on(\"Room.tags\", function(event, room){\n *   var newTags = event.getContent().tags;\n *   if (newTags[\"favourite\"]) showStar(room);\n * });\n */\n\n/**\n * Fires whenever a room's account_data is updated.\n * @event module:client~MatrixClient#\"Room.accountData\"\n * @param {event} event The account_data event\n * @param {Room} room The room whose account_data was updated.\n * @example\n * matrixClient.on(\"Room.accountData\", function(event, room){\n *   if (event.getType() === \"m.room.colorscheme\") {\n *       applyColorScheme(event.getContents());\n *   }\n * });\n */\n\n/**\n * Fires when the status of a transmitted event is updated.\n *\n * <p>When an event is first transmitted, a temporary copy of the event is\n * inserted into the timeline, with a temporary event id, and a status of\n * 'SENDING'.\n *\n * <p>Once the echo comes back from the server, the content of the event\n * (MatrixEvent.event) is replaced by the complete event from the homeserver,\n * thus updating its event id, as well as server-generated fields such as the\n * timestamp. Its status is set to null.\n *\n * <p>Once the /send request completes, if the remote echo has not already\n * arrived, the event is updated with a new event id and the status is set to\n * 'SENT'. The server-generated fields are of course not updated yet.\n *\n * <p>If the /send fails, In this case, the event's status is set to\n * 'NOT_SENT'. If it is later resent, the process starts again, setting the\n * status to 'SENDING'. Alternatively, the message may be cancelled, which\n * removes the event from the room, and sets the status to 'CANCELLED'.\n *\n * <p>This event is raised to reflect each of the transitions above.\n *\n * @event module:client~MatrixClient#\"Room.localEchoUpdated\"\n *\n * @param {MatrixEvent} event The matrix event which has been updated\n *\n * @param {Room} room The room containing the redacted event\n *\n * @param {string} oldEventId The previous event id (the temporary event id,\n *    except when updating a successfully-sent event when its echo arrives)\n *\n * @param {EventStatus} oldStatus The previous event status.\n */","map":{"version":3,"sources":["/home/kimist/Developpement/React/watcha_client/node_modules/matrix-js-sdk/lib/models/room.js"],"names":["_interopRequireWildcard","require","Object","defineProperty","exports","value","Room","_events","_eventTimelineSet","_eventTimeline","_contentRepo","utils","_event","_roomMember","_roomSummary","_logger","_ReEmitter","KNOWN_SAFE_ROOM_VERSION","SAFE_ROOM_VERSIONS","synthesizeReceipt","userId","event","receiptType","fakeReceipt","content","type","room_id","getRoomId","getId","ts","getTs","MatrixEvent","roomId","client","myUserId","opts","pendingEventOrdering","reEmitter","ReEmitter","indexOf","Error","name","tags","accountData","summary","storageToken","_opts","_txnToEvent","_receipts","_receiptCacheByEventId","_realReceipts","_notificationCounts","_timelineSets","EventTimelineSet","reEmit","getUnfilteredTimelineSet","_fixUpLegacyTimelineFields","_filteredTimelineSets","_pendingEventList","_blacklistUnverifiedDevices","_selfMembership","_summaryHeroes","_client","lazyLoadMembers","_membersPromise","Promise","resolve","inherits","EventEmitter","prototype","getVersion","createEvent","currentState","getStateEvents","logger","warn","ver","getContent","undefined","shouldUpgradeToVersion","includes","getRecommendedVersion","capabilities","getCapabilities","versionCap","default","available","safeVer","result","_checkVersionAgainstCapability","urgent","needsUpgrade","caps","currentVersion","log","version","stableVersions","keys","filter","v","match","userMayUpgradeRoom","maySendStateEvent","getPendingEvents","hasPendingEvent","eventId","some","getLiveTimeline","getLastActiveTimestamp","timeline","events","getEvents","length","lastEvent","Number","MIN_SAFE_INTEGER","getMyMembership","getDMInviter","me","getMember","memberCount","getInvitedAndJoinedMemberCount","guessDMUserId","inviterId","hasHeroes","Array","isArray","members","getMembers","anyMember","find","m","getAvatarFallbackMember","availableMember","map","member","availableUser","getUser","user","RoomMember","updateMyMembership","membership","prevMembership","_cleanupAfterLeaving","emit","_loadMembersFromServer","lastSyncToken","store","getSyncToken","queryString","encodeParams","not_membership","at","path","encodeUri","$roomId","http","_http","response","authedRequest","chunk","_loadMembers","fromServer","rawMembersEvents","getOutOfBandMembers","memberEvents","getEventMapper","loadMembersIfNeeded","markOutOfBandMembersStarted","inMemoryUpdate","then","setOutOfBandMembers","isCryptoEnabled","isRoomEncrypted","_crypto","trackRoomDevices","catch","err","markOutOfBandMembersFailed","oobMembers","isOutOfBand","error","clearLoadedMembersIfNeeded","clearOutOfBandMembers","resetLiveTimeline","backPaginationToken","forwardPaginationToken","i","oldState","getState","EventTimeline","BACKWARDS","FORWARDS","hasUnverifiedDevices","e2eMembers","getEncryptionTargetMembers","devices","getStoredDevicesForUser","device","isUnverified","getTimelineSets","getTimelineForEvent","addTimeline","findEventById","getUnreadNotificationCount","setUnreadNotificationCount","count","setSummary","heroes","joinedCount","invitedCount","isInteger","setJoinedMemberCount","setInvitedMemberCount","setBlacklistUnverifiedDevices","getBlacklistUnverifiedDevices","getAvatarUrl","baseUrl","width","height","resizeMethod","allowDefault","roomAvatarEvent","mainUrl","url","getHttpUriForMxc","getIdenticonUri","getAliases","aliasStrings","aliasEvents","aliasEvent","aliases","filteredAliases","a","endsWith","getStateKey","push","apply","getCanonicalAlias","canonicalAlias","alias","addEventsToTimeline","toStartOfTimeline","paginationToken","getTimelineSet","getJoinedMembers","getMembersWithMembership","getJoinedMemberCount","getInvitedMemberCount","shouldEncryptForInvitedMembers","concat","ev","history_visibility","getDefaultRoomName","calculateRoomName","hasMembershipState","getOrCreateFilteredTimelineSet","filterId","assign","timelineSet","unfilteredLiveTimeline","forEach","addLiveEvent","getNeighbouringTimeline","setPaginationToken","getPaginationToken","removeFilteredTimelineSet","splice","_addLiveEvent","duplicateStrategy","isRedaction","redactId","redacts","redactedEvent","makeRedacted","currentStateEvent","getType","setStateEvents","getUnsigned","transaction_id","existingEvent","_handleRemoteEcho","sender","addReceipt","addPendingEvent","txnId","status","EventStatus","SENDING","setEventMetadata","e","NOT_SENT","setStatus","isRelation","_aggregateNonLiveRelation","markLocallyRedacted","getFilter","filterRoomTimeline","addEventToTimeline","aggregateRelations","remoteEvent","localEvent","oldEventId","newEventId","oldStatus","removeElement","handleRemoteEcho","ALLOWED_TRANSITIONS","ENCRYPTING","QUEUED","SENT","CANCELLED","updatePendingEvent","newStatus","eventIdToTimeline","allowed","replaceLocalEventId","replaceEventId","idx","findIndex","removedEvent","_revertRedactionLocalEcho","removeEvent","redactionEvent","unmarkLocallyRedacted","addLiveEvents","liveTimeline","addEphemeralEvents","setTypingEvent","removeEvents","eventIds","removedAny","removed","recalculate","self","membershipEvent","strippedStateEvents","invite_room_state","strippedEvent","state_key","event_id","Date","now","user_id","oldName","RoomSummary","title","getUsersReadUpTo","getReceiptsForEvent","receipt","getEventReadUpTo","ignoreSynthesized","receipts","hasUserReadEvent","readUpToId","getSender","fake","_addReceiptsToStructure","_buildReceiptCache","existingReceipt","ordering","compareEventOrdering","data","receiptCacheByEventId","_addLocalEchoReceipt","addTags","addAccountData","getAccountData","maySendMessage","maySendEvent","room","ignoreRoomNameEvent","mRoomName","joinedMemberCount","invitedMemberCount","inviteJoinCount","otherNames","otherMembers","sort","b","localeCompare","slice","memberNamesToRoomName","myMembership","thirdPartyInvites","thirdPartyNames","display_name","leftNames","names","countWithoutMe","plural"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Room = Room;\n\nvar _events = require(\"events\");\n\nvar _eventTimelineSet = require(\"./event-timeline-set\");\n\nvar _eventTimeline = require(\"./event-timeline\");\n\nvar _contentRepo = require(\"../content-repo\");\n\nvar utils = _interopRequireWildcard(require(\"../utils\"));\n\nvar _event = require(\"./event\");\n\nvar _roomMember = require(\"./room-member\");\n\nvar _roomSummary = require(\"./room-summary\");\n\nvar _logger = require(\"../logger\");\n\nvar _ReEmitter = require(\"../ReEmitter\");\n\n/*\nCopyright 2015, 2016 OpenMarket Ltd\nCopyright 2018, 2019 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * @module models/room\n */\n// These constants are used as sane defaults when the homeserver doesn't support\n// the m.room_versions capability. In practice, KNOWN_SAFE_ROOM_VERSION should be\n// the same as the common default room version whereas SAFE_ROOM_VERSIONS are the\n// room versions which are considered okay for people to run without being asked\n// to upgrade (ie: \"stable\"). Eventually, we should remove these when all homeservers\n// return an m.room_versions capability.\nconst KNOWN_SAFE_ROOM_VERSION = '5';\nconst SAFE_ROOM_VERSIONS = ['1', '2', '3', '4', '5'];\n\nfunction synthesizeReceipt(userId, event, receiptType) {\n  // console.log(\"synthesizing receipt for \"+event.getId());\n  // This is really ugly because JS has no way to express an object literal\n  // where the name of a key comes from an expression\n  const fakeReceipt = {\n    content: {},\n    type: \"m.receipt\",\n    room_id: event.getRoomId()\n  };\n  fakeReceipt.content[event.getId()] = {};\n  fakeReceipt.content[event.getId()][receiptType] = {};\n  fakeReceipt.content[event.getId()][receiptType][userId] = {\n    ts: event.getTs()\n  };\n  return new _event.MatrixEvent(fakeReceipt);\n}\n/**\n * Construct a new Room.\n *\n * <p>For a room, we store an ordered sequence of timelines, which may or may not\n * be continuous. Each timeline lists a series of events, as well as tracking\n * the room state at the start and the end of the timeline. It also tracks\n * forward and backward pagination tokens, as well as containing links to the\n * next timeline in the sequence.\n *\n * <p>There is one special timeline - the 'live' timeline, which represents the\n * timeline to which events are being added in real-time as they are received\n * from the /sync API. Note that you should not retain references to this\n * timeline - even if it is the current timeline right now, it may not remain\n * so if the server gives us a timeline gap in /sync.\n *\n * <p>In order that we can find events from their ids later, we also maintain a\n * map from event_id to timeline and index.\n *\n * @constructor\n * @alias module:models/room\n * @param {string} roomId Required. The ID of this room.\n * @param {MatrixClient} client Required. The client, used to lazy load members.\n * @param {string} myUserId Required. The ID of the syncing user.\n * @param {Object=} opts Configuration options\n * @param {*} opts.storageToken Optional. The token which a data store can use\n * to remember the state of the room. What this means is dependent on the store\n * implementation.\n *\n * @param {String=} opts.pendingEventOrdering Controls where pending messages\n * appear in a room's timeline. If \"<b>chronological</b>\", messages will appear\n * in the timeline when the call to <code>sendEvent</code> was made. If\n * \"<b>detached</b>\", pending messages will appear in a separate list,\n * accessbile via {@link module:models/room#getPendingEvents}. Default:\n * \"chronological\".\n * @param {boolean} [opts.timelineSupport = false] Set to true to enable improved\n * timeline support.\n * @param {boolean} [opts.unstableClientRelationAggregation = false]\n * Optional. Set to true to enable client-side aggregation of event relations\n * via `EventTimelineSet#getRelationsForEvent`.\n * This feature is currently unstable and the API may change without notice.\n *\n * @prop {string} roomId The ID of this room.\n * @prop {string} name The human-readable display name for this room.\n * @prop {Array<MatrixEvent>} timeline The live event timeline for this room,\n * with the oldest event at index 0. Present for backwards compatibility -\n * prefer getLiveTimeline().getEvents().\n * @prop {object} tags Dict of room tags; the keys are the tag name and the values\n * are any metadata associated with the tag - e.g. { \"fav\" : { order: 1 } }\n * @prop {object} accountData Dict of per-room account_data events; the keys are the\n * event type and the values are the events.\n * @prop {RoomState} oldState The state of the room at the time of the oldest\n * event in the live timeline. Present for backwards compatibility -\n * prefer getLiveTimeline().getState(EventTimeline.BACKWARDS).\n * @prop {RoomState} currentState The state of the room at the time of the\n * newest event in the timeline. Present for backwards compatibility -\n * prefer getLiveTimeline().getState(EventTimeline.FORWARDS).\n * @prop {RoomSummary} summary The room summary.\n * @prop {*} storageToken A token which a data store can use to remember\n * the state of the room.\n */\n\n\nfunction Room(roomId, client, myUserId, opts) {\n  opts = opts || {};\n  opts.pendingEventOrdering = opts.pendingEventOrdering || \"chronological\";\n  this.reEmitter = new _ReEmitter.ReEmitter(this);\n\n  if ([\"chronological\", \"detached\"].indexOf(opts.pendingEventOrdering) === -1) {\n    throw new Error(\"opts.pendingEventOrdering MUST be either 'chronological' or \" + \"'detached'. Got: '\" + opts.pendingEventOrdering + \"'\");\n  }\n\n  this.myUserId = myUserId;\n  this.roomId = roomId;\n  this.name = roomId;\n  this.tags = {// $tagName: { $metadata: $value },\n    // $tagName: { $metadata: $value },\n  };\n  this.accountData = {// $eventType: $event\n  };\n  this.summary = null;\n  this.storageToken = opts.storageToken;\n  this._opts = opts;\n  this._txnToEvent = {}; // Pending in-flight requests { string: MatrixEvent }\n  // receipts should clobber based on receipt_type and user_id pairs hence\n  // the form of this structure. This is sub-optimal for the exposed APIs\n  // which pass in an event ID and get back some receipts, so we also store\n  // a pre-cached list for this purpose.\n\n  this._receipts = {// receipt_type: {\n    //   user_id: {\n    //     eventId: <event_id>,\n    //     data: <receipt_data>\n    //   }\n    // }\n  };\n  this._receiptCacheByEventId = {// $event_id: [{\n    //   type: $type,\n    //   userId: $user_id,\n    //   data: <receipt data>\n    // }]\n  }; // only receipts that came from the server, not synthesized ones\n\n  this._realReceipts = {};\n  this._notificationCounts = {}; // all our per-room timeline sets. the first one is the unfiltered ones;\n  // the subsequent ones are the filtered ones in no particular order.\n\n  this._timelineSets = [new _eventTimelineSet.EventTimelineSet(this, opts)];\n  this.reEmitter.reEmit(this.getUnfilteredTimelineSet(), [\"Room.timeline\", \"Room.timelineReset\"]);\n\n  this._fixUpLegacyTimelineFields(); // any filtered timeline sets we're maintaining for this room\n\n\n  this._filteredTimelineSets = {// filter_id: timelineSet\n  };\n\n  if (this._opts.pendingEventOrdering == \"detached\") {\n    this._pendingEventList = [];\n  } // read by megolm; boolean value - null indicates \"use global value\"\n\n\n  this._blacklistUnverifiedDevices = null;\n  this._selfMembership = null;\n  this._summaryHeroes = null; // awaited by getEncryptionTargetMembers while room members are loading\n\n  this._client = client;\n\n  if (!this._opts.lazyLoadMembers) {\n    this._membersPromise = Promise.resolve();\n  } else {\n    this._membersPromise = null;\n  }\n}\n\nutils.inherits(Room, _events.EventEmitter);\n/**\n * Gets the version of the room\n * @returns {string} The version of the room, or null if it could not be determined\n */\n\nRoom.prototype.getVersion = function () {\n  const createEvent = this.currentState.getStateEvents(\"m.room.create\", \"\");\n\n  if (!createEvent) {\n    _logger.logger.warn(\"Room \" + this.room_id + \" does not have an m.room.create event\");\n\n    return '1';\n  }\n\n  const ver = createEvent.getContent()['room_version'];\n  if (ver === undefined) return '1';\n  return ver;\n};\n/**\n * Determines whether this room needs to be upgraded to a new version\n * @returns {string?} What version the room should be upgraded to, or null if\n *     the room does not require upgrading at this time.\n * @deprecated Use #getRecommendedVersion() instead\n */\n\n\nRoom.prototype.shouldUpgradeToVersion = function () {\n  // TODO: Remove this function.\n  // This makes assumptions about which versions are safe, and can easily\n  // be wrong. Instead, people are encouraged to use getRecommendedVersion\n  // which determines a safer value. This function doesn't use that function\n  // because this is not async-capable, and to avoid breaking the contract\n  // we're deprecating this.\n  if (!SAFE_ROOM_VERSIONS.includes(this.getVersion())) {\n    return KNOWN_SAFE_ROOM_VERSION;\n  }\n\n  return null;\n};\n/**\n * Determines the recommended room version for the room. This returns an\n * object with 3 properties: <code>version</code> as the new version the\n * room should be upgraded to (may be the same as the current version);\n * <code>needsUpgrade</code> to indicate if the room actually can be\n * upgraded (ie: does the current version not match?); and <code>urgent</code>\n * to indicate if the new version patches a vulnerability in a previous\n * version.\n * @returns {Promise<{version: string, needsUpgrade: bool, urgent: bool}>}\n * Resolves to the version the room should be upgraded to.\n */\n\n\nRoom.prototype.getRecommendedVersion = async function () {\n  const capabilities = await this._client.getCapabilities();\n  let versionCap = capabilities[\"m.room_versions\"];\n\n  if (!versionCap) {\n    versionCap = {\n      default: KNOWN_SAFE_ROOM_VERSION,\n      available: {}\n    };\n\n    for (const safeVer of SAFE_ROOM_VERSIONS) {\n      versionCap.available[safeVer] = \"stable\";\n    }\n  }\n\n  let result = this._checkVersionAgainstCapability(versionCap);\n\n  if (result.urgent && result.needsUpgrade) {\n    // Something doesn't feel right: we shouldn't need to update\n    // because the version we're on should be in the protocol's\n    // namespace. This usually means that the server was updated\n    // before the client was, making us think the newest possible\n    // room version is not stable. As a solution, we'll refresh\n    // the capability we're using to determine this.\n    _logger.logger.warn(\"Refreshing room version capability because the server looks \" + \"to be supporting a newer room version we don't know about.\");\n\n    const caps = await this._client.getCapabilities(true);\n    versionCap = caps[\"m.room_versions\"];\n\n    if (!versionCap) {\n      _logger.logger.warn(\"No room version capability - assuming upgrade required.\");\n\n      return result;\n    } else {\n      result = this._checkVersionAgainstCapability(versionCap);\n    }\n  }\n\n  return result;\n};\n\nRoom.prototype._checkVersionAgainstCapability = function (versionCap) {\n  const currentVersion = this.getVersion();\n\n  _logger.logger.log(`[${this.roomId}] Current version: ${currentVersion}`);\n\n  _logger.logger.log(`[${this.roomId}] Version capability: `, versionCap);\n\n  const result = {\n    version: currentVersion,\n    needsUpgrade: false,\n    urgent: false\n  }; // If the room is on the default version then nothing needs to change\n\n  if (currentVersion === versionCap.default) return result;\n  const stableVersions = Object.keys(versionCap.available).filter(v => versionCap.available[v] === 'stable'); // Check if the room is on an unstable version. We determine urgency based\n  // off the version being in the Matrix spec namespace or not (if the version\n  // is in the current namespace and unstable, the room is probably vulnerable).\n\n  if (!stableVersions.includes(currentVersion)) {\n    result.version = versionCap.default;\n    result.needsUpgrade = true;\n    result.urgent = !!this.getVersion().match(/^[0-9]+[0-9.]*$/g);\n\n    if (result.urgent) {\n      _logger.logger.warn(`URGENT upgrade required on ${this.roomId}`);\n    } else {\n      _logger.logger.warn(`Non-urgent upgrade required on ${this.roomId}`);\n    }\n\n    return result;\n  } // The room is on a stable, but non-default, version by this point.\n  // No upgrade needed.\n\n\n  return result;\n};\n/**\n * Determines whether the given user is permitted to perform a room upgrade\n * @param {String} userId The ID of the user to test against\n * @returns {bool} True if the given user is permitted to upgrade the room\n */\n\n\nRoom.prototype.userMayUpgradeRoom = function (userId) {\n  return this.currentState.maySendStateEvent(\"m.room.tombstone\", userId);\n};\n/**\n * Get the list of pending sent events for this room\n *\n * @return {module:models/event.MatrixEvent[]} A list of the sent events\n * waiting for remote echo.\n *\n * @throws If <code>opts.pendingEventOrdering</code> was not 'detached'\n */\n\n\nRoom.prototype.getPendingEvents = function () {\n  if (this._opts.pendingEventOrdering !== \"detached\") {\n    throw new Error(\"Cannot call getPendingEvents with pendingEventOrdering == \" + this._opts.pendingEventOrdering);\n  }\n\n  return this._pendingEventList;\n};\n/**\n * Check whether the pending event list contains a given event by ID.\n *\n * @param {string} eventId The event ID to check for.\n * @return {boolean}\n * @throws If <code>opts.pendingEventOrdering</code> was not 'detached'\n */\n\n\nRoom.prototype.hasPendingEvent = function (eventId) {\n  if (this._opts.pendingEventOrdering !== \"detached\") {\n    throw new Error(\"Cannot call hasPendingEvent with pendingEventOrdering == \" + this._opts.pendingEventOrdering);\n  }\n\n  return this._pendingEventList.some(event => event.getId() === eventId);\n};\n/**\n * Get the live unfiltered timeline for this room.\n *\n * @return {module:models/event-timeline~EventTimeline} live timeline\n */\n\n\nRoom.prototype.getLiveTimeline = function () {\n  return this.getUnfilteredTimelineSet().getLiveTimeline();\n};\n/**\n * Get the timestamp of the last message in the room\n *\n * @return {number} the timestamp of the last message in the room\n */\n\n\nRoom.prototype.getLastActiveTimestamp = function () {\n  const timeline = this.getLiveTimeline();\n  const events = timeline.getEvents();\n\n  if (events.length) {\n    const lastEvent = events[events.length - 1];\n    return lastEvent.getTs();\n  } else {\n    return Number.MIN_SAFE_INTEGER;\n  }\n};\n/**\n * @param {string} myUserId the user id for the logged in member\n * @return {string} the membership type (join | leave | invite) for the logged in user\n */\n\n\nRoom.prototype.getMyMembership = function () {\n  return this._selfMembership;\n};\n/**\n * If this room is a DM we're invited to,\n * try to find out who invited us\n * @return {string} user id of the inviter\n */\n\n\nRoom.prototype.getDMInviter = function () {\n  if (this.myUserId) {\n    const me = this.getMember(this.myUserId);\n\n    if (me) {\n      return me.getDMInviter();\n    }\n  }\n\n  if (this._selfMembership === \"invite\") {\n    // fall back to summary information\n    const memberCount = this.getInvitedAndJoinedMemberCount();\n\n    if (memberCount == 2 && this._summaryHeroes.length) {\n      return this._summaryHeroes[0];\n    }\n  }\n};\n/**\n * Assuming this room is a DM room, tries to guess with which user.\n * @return {string} user id of the other member (could be syncing user)\n */\n\n\nRoom.prototype.guessDMUserId = function () {\n  const me = this.getMember(this.myUserId);\n\n  if (me) {\n    const inviterId = me.getDMInviter();\n\n    if (inviterId) {\n      return inviterId;\n    }\n  } // remember, we're assuming this room is a DM,\n  // so returning the first member we find should be fine\n\n\n  const hasHeroes = Array.isArray(this._summaryHeroes) && this._summaryHeroes.length;\n\n  if (hasHeroes) {\n    return this._summaryHeroes[0];\n  }\n\n  const members = this.currentState.getMembers();\n  const anyMember = members.find(m => m.userId !== this.myUserId);\n\n  if (anyMember) {\n    return anyMember.userId;\n  } // it really seems like I'm the only user in the room\n  // so I probably created a room with just me in it\n  // and marked it as a DM. Ok then\n\n\n  return this.myUserId;\n};\n\nRoom.prototype.getAvatarFallbackMember = function () {\n  const memberCount = this.getInvitedAndJoinedMemberCount();\n\n  if (memberCount > 2) {\n    return;\n  }\n\n  const hasHeroes = Array.isArray(this._summaryHeroes) && this._summaryHeroes.length;\n\n  if (hasHeroes) {\n    const availableMember = this._summaryHeroes.map(userId => {\n      return this.getMember(userId);\n    }).find(member => !!member);\n\n    if (availableMember) {\n      return availableMember;\n    }\n  }\n\n  const members = this.currentState.getMembers(); // could be different than memberCount\n  // as this includes left members\n\n  if (members.length <= 2) {\n    const availableMember = members.find(m => {\n      return m.userId !== this.myUserId;\n    });\n\n    if (availableMember) {\n      return availableMember;\n    }\n  } // if all else fails, try falling back to a user,\n  // and create a one-off member for it\n\n\n  if (hasHeroes) {\n    const availableUser = this._summaryHeroes.map(userId => {\n      return this._client.getUser(userId);\n    }).find(user => !!user);\n\n    if (availableUser) {\n      const member = new _roomMember.RoomMember(this.roomId, availableUser.userId);\n      member.user = availableUser;\n      return member;\n    }\n  }\n};\n/**\n * Sets the membership this room was received as during sync\n * @param {string} membership join | leave | invite\n */\n\n\nRoom.prototype.updateMyMembership = function (membership) {\n  const prevMembership = this._selfMembership;\n  this._selfMembership = membership;\n\n  if (prevMembership !== membership) {\n    if (membership === \"leave\") {\n      this._cleanupAfterLeaving();\n    }\n\n    this.emit(\"Room.myMembership\", this, membership, prevMembership);\n  }\n};\n\nRoom.prototype._loadMembersFromServer = async function () {\n  const lastSyncToken = this._client.store.getSyncToken();\n\n  const queryString = utils.encodeParams({\n    not_membership: \"leave\",\n    at: lastSyncToken\n  });\n  const path = utils.encodeUri(\"/rooms/$roomId/members?\" + queryString, {\n    $roomId: this.roomId\n  });\n  const http = this._client._http;\n  const response = await http.authedRequest(undefined, \"GET\", path);\n  return response.chunk;\n};\n\nRoom.prototype._loadMembers = async function () {\n  // were the members loaded from the server?\n  let fromServer = false;\n  let rawMembersEvents = await this._client.store.getOutOfBandMembers(this.roomId);\n\n  if (rawMembersEvents === null) {\n    fromServer = true;\n    rawMembersEvents = await this._loadMembersFromServer();\n\n    _logger.logger.log(`LL: got ${rawMembersEvents.length} ` + `members from server for room ${this.roomId}`);\n  }\n\n  const memberEvents = rawMembersEvents.map(this._client.getEventMapper());\n  return {\n    memberEvents,\n    fromServer\n  };\n};\n/**\n * Preloads the member list in case lazy loading\n * of memberships is in use. Can be called multiple times,\n * it will only preload once.\n * @return {Promise} when preloading is done and\n * accessing the members on the room will take\n * all members in the room into account\n */\n\n\nRoom.prototype.loadMembersIfNeeded = function () {\n  if (this._membersPromise) {\n    return this._membersPromise;\n  } // mark the state so that incoming messages while\n  // the request is in flight get marked as superseding\n  // the OOB members\n\n\n  this.currentState.markOutOfBandMembersStarted();\n\n  const inMemoryUpdate = this._loadMembers().then(result => {\n    this.currentState.setOutOfBandMembers(result.memberEvents); // now the members are loaded, start to track the e2e devices if needed\n\n    if (this._client.isCryptoEnabled() && this._client.isRoomEncrypted(this.roomId)) {\n      this._client._crypto.trackRoomDevices(this.roomId);\n    }\n\n    return result.fromServer;\n  }).catch(err => {\n    // allow retries on fail\n    this._membersPromise = null;\n    this.currentState.markOutOfBandMembersFailed();\n    throw err;\n  }); // update members in storage, but don't wait for it\n\n\n  inMemoryUpdate.then(fromServer => {\n    if (fromServer) {\n      const oobMembers = this.currentState.getMembers().filter(m => m.isOutOfBand()).map(m => m.events.member.event);\n\n      _logger.logger.log(`LL: telling store to write ${oobMembers.length}` + ` members for room ${this.roomId}`);\n\n      const store = this._client.store;\n      return store.setOutOfBandMembers(this.roomId, oobMembers) // swallow any IDB error as we don't want to fail\n      // because of this\n      .catch(err => {\n        _logger.logger.log(\"LL: storing OOB room members failed, oh well\", err);\n      });\n    }\n  }).catch(err => {\n    // as this is not awaited anywhere,\n    // at least show the error in the console\n    _logger.logger.error(err);\n  });\n  this._membersPromise = inMemoryUpdate;\n  return this._membersPromise;\n};\n/**\n * Removes the lazily loaded members from storage if needed\n */\n\n\nRoom.prototype.clearLoadedMembersIfNeeded = async function () {\n  if (this._opts.lazyLoadMembers && this._membersPromise) {\n    await this.loadMembersIfNeeded();\n    await this._client.store.clearOutOfBandMembers(this.roomId);\n    this.currentState.clearOutOfBandMembers();\n    this._membersPromise = null;\n  }\n};\n/**\n * called when sync receives this room in the leave section\n * to do cleanup after leaving a room. Possibly called multiple times.\n */\n\n\nRoom.prototype._cleanupAfterLeaving = function () {\n  this.clearLoadedMembersIfNeeded().catch(err => {\n    _logger.logger.error(`error after clearing loaded members from ` + `room ${this.roomId} after leaving`);\n\n    _logger.logger.log(err);\n  });\n};\n/**\n * Reset the live timeline of all timelineSets, and start new ones.\n *\n * <p>This is used when /sync returns a 'limited' timeline.\n *\n * @param {string=} backPaginationToken   token for back-paginating the new timeline\n * @param {string=} forwardPaginationToken token for forward-paginating the old live timeline,\n * if absent or null, all timelines are reset, removing old ones (including the previous live\n * timeline which would otherwise be unable to paginate forwards without this token).\n * Removing just the old live timeline whilst preserving previous ones is not supported.\n */\n\n\nRoom.prototype.resetLiveTimeline = function (backPaginationToken, forwardPaginationToken) {\n  for (let i = 0; i < this._timelineSets.length; i++) {\n    this._timelineSets[i].resetLiveTimeline(backPaginationToken, forwardPaginationToken);\n  }\n\n  this._fixUpLegacyTimelineFields();\n};\n/**\n * Fix up this.timeline, this.oldState and this.currentState\n *\n * @private\n */\n\n\nRoom.prototype._fixUpLegacyTimelineFields = function () {\n  // maintain this.timeline as a reference to the live timeline,\n  // and this.oldState and this.currentState as references to the\n  // state at the start and end of that timeline. These are more\n  // for backwards-compatibility than anything else.\n  this.timeline = this.getLiveTimeline().getEvents();\n  this.oldState = this.getLiveTimeline().getState(_eventTimeline.EventTimeline.BACKWARDS);\n  this.currentState = this.getLiveTimeline().getState(_eventTimeline.EventTimeline.FORWARDS);\n};\n/**\n * Returns whether there are any devices in the room that are unverified\n *\n * Note: Callers should first check if crypto is enabled on this device. If it is\n * disabled, then we aren't tracking room devices at all, so we can't answer this, and an\n * error will be thrown.\n *\n * @return {bool} the result\n */\n\n\nRoom.prototype.hasUnverifiedDevices = async function () {\n  if (!this._client.isRoomEncrypted(this.roomId)) {\n    return false;\n  }\n\n  const e2eMembers = await this.getEncryptionTargetMembers();\n\n  for (const member of e2eMembers) {\n    const devices = await this._client.getStoredDevicesForUser(member.userId);\n\n    if (devices.some(device => device.isUnverified())) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Return the timeline sets for this room.\n * @return {EventTimelineSet[]} array of timeline sets for this room\n */\n\n\nRoom.prototype.getTimelineSets = function () {\n  return this._timelineSets;\n};\n/**\n * Helper to return the main unfiltered timeline set for this room\n * @return {EventTimelineSet} room's unfiltered timeline set\n */\n\n\nRoom.prototype.getUnfilteredTimelineSet = function () {\n  return this._timelineSets[0];\n};\n/**\n * Get the timeline which contains the given event from the unfiltered set, if any\n *\n * @param {string} eventId  event ID to look for\n * @return {?module:models/event-timeline~EventTimeline} timeline containing\n * the given event, or null if unknown\n */\n\n\nRoom.prototype.getTimelineForEvent = function (eventId) {\n  return this.getUnfilteredTimelineSet().getTimelineForEvent(eventId);\n};\n/**\n * Add a new timeline to this room's unfiltered timeline set\n *\n * @return {module:models/event-timeline~EventTimeline} newly-created timeline\n */\n\n\nRoom.prototype.addTimeline = function () {\n  return this.getUnfilteredTimelineSet().addTimeline();\n};\n/**\n * Get an event which is stored in our unfiltered timeline set\n *\n * @param {string} eventId  event ID to look for\n * @return {?module:models/event.MatrixEvent} the given event, or undefined if unknown\n */\n\n\nRoom.prototype.findEventById = function (eventId) {\n  return this.getUnfilteredTimelineSet().findEventById(eventId);\n};\n/**\n * Get one of the notification counts for this room\n * @param {String} type The type of notification count to get. default: 'total'\n * @return {Number} The notification count, or undefined if there is no count\n *                  for this type.\n */\n\n\nRoom.prototype.getUnreadNotificationCount = function (type) {\n  type = type || 'total';\n  return this._notificationCounts[type];\n};\n/**\n * Set one of the notification counts for this room\n * @param {String} type The type of notification count to set.\n * @param {Number} count The new count\n */\n\n\nRoom.prototype.setUnreadNotificationCount = function (type, count) {\n  this._notificationCounts[type] = count;\n};\n\nRoom.prototype.setSummary = function (summary) {\n  const heroes = summary[\"m.heroes\"];\n  const joinedCount = summary[\"m.joined_member_count\"];\n  const invitedCount = summary[\"m.invited_member_count\"];\n\n  if (Number.isInteger(joinedCount)) {\n    this.currentState.setJoinedMemberCount(joinedCount);\n  }\n\n  if (Number.isInteger(invitedCount)) {\n    this.currentState.setInvitedMemberCount(invitedCount);\n  }\n\n  if (Array.isArray(heroes)) {\n    // be cautious about trusting server values,\n    // and make sure heroes doesn't contain our own id\n    // just to be sure\n    this._summaryHeroes = heroes.filter(userId => {\n      return userId !== this.myUserId;\n    });\n  }\n};\n/**\n * Whether to send encrypted messages to devices within this room.\n * @param {Boolean} value true to blacklist unverified devices, null\n * to use the global value for this room.\n */\n\n\nRoom.prototype.setBlacklistUnverifiedDevices = function (value) {\n  this._blacklistUnverifiedDevices = value;\n};\n/**\n * Whether to send encrypted messages to devices within this room.\n * @return {Boolean} true if blacklisting unverified devices, null\n * if the global value should be used for this room.\n */\n\n\nRoom.prototype.getBlacklistUnverifiedDevices = function () {\n  return this._blacklistUnverifiedDevices;\n};\n/**\n * Get the avatar URL for a room if one was set.\n * @param {String} baseUrl The homeserver base URL. See\n * {@link module:client~MatrixClient#getHomeserverUrl}.\n * @param {Number} width The desired width of the thumbnail.\n * @param {Number} height The desired height of the thumbnail.\n * @param {string} resizeMethod The thumbnail resize method to use, either\n * \"crop\" or \"scale\".\n * @param {boolean} allowDefault True to allow an identicon for this room if an\n * avatar URL wasn't explicitly set. Default: true. (Deprecated)\n * @return {?string} the avatar URL or null.\n */\n\n\nRoom.prototype.getAvatarUrl = function (baseUrl, width, height, resizeMethod, allowDefault) {\n  const roomAvatarEvent = this.currentState.getStateEvents(\"m.room.avatar\", \"\");\n\n  if (allowDefault === undefined) {\n    allowDefault = true;\n  }\n\n  if (!roomAvatarEvent && !allowDefault) {\n    return null;\n  }\n\n  const mainUrl = roomAvatarEvent ? roomAvatarEvent.getContent().url : null;\n\n  if (mainUrl) {\n    return (0, _contentRepo.getHttpUriForMxc)(baseUrl, mainUrl, width, height, resizeMethod);\n  } else if (allowDefault) {\n    return (0, _contentRepo.getIdenticonUri)(baseUrl, this.roomId, width, height);\n  }\n\n  return null;\n};\n/**\n * Get the aliases this room has according to the room's state\n * The aliases returned by this function may not necessarily\n * still point to this room.\n * @return {array} The room's alias as an array of strings\n */\n\n\nRoom.prototype.getAliases = function () {\n  const aliasStrings = [];\n  const aliasEvents = this.currentState.getStateEvents(\"m.room.aliases\");\n\n  if (aliasEvents) {\n    for (let i = 0; i < aliasEvents.length; ++i) {\n      const aliasEvent = aliasEvents[i];\n\n      if (utils.isArray(aliasEvent.getContent().aliases)) {\n        const filteredAliases = aliasEvent.getContent().aliases.filter(a => {\n          if (typeof a !== \"string\") return false;\n          if (a[0] !== '#') return false;\n          if (!a.endsWith(`:${aliasEvent.getStateKey()}`)) return false; // It's probably valid by here.\n\n          return true;\n        });\n        Array.prototype.push.apply(aliasStrings, filteredAliases);\n      }\n    }\n  }\n\n  return aliasStrings;\n};\n/**\n * Get this room's canonical alias\n * The alias returned by this function may not necessarily\n * still point to this room.\n * @return {?string} The room's canonical alias, or null if there is none\n */\n\n\nRoom.prototype.getCanonicalAlias = function () {\n  const canonicalAlias = this.currentState.getStateEvents(\"m.room.canonical_alias\", \"\");\n\n  if (canonicalAlias) {\n    return canonicalAlias.getContent().alias;\n  }\n\n  return null;\n};\n/**\n * Add events to a timeline\n *\n * <p>Will fire \"Room.timeline\" for each event added.\n *\n * @param {MatrixEvent[]} events A list of events to add.\n *\n * @param {boolean} toStartOfTimeline   True to add these events to the start\n * (oldest) instead of the end (newest) of the timeline. If true, the oldest\n * event will be the <b>last</b> element of 'events'.\n *\n * @param {module:models/event-timeline~EventTimeline} timeline   timeline to\n *    add events to.\n *\n * @param {string=} paginationToken   token for the next batch of events\n *\n * @fires module:client~MatrixClient#event:\"Room.timeline\"\n *\n */\n\n\nRoom.prototype.addEventsToTimeline = function (events, toStartOfTimeline, timeline, paginationToken) {\n  timeline.getTimelineSet().addEventsToTimeline(events, toStartOfTimeline, timeline, paginationToken);\n};\n/**\n * Get a member from the current room state.\n * @param {string} userId The user ID of the member.\n * @return {RoomMember} The member or <code>null</code>.\n */\n\n\nRoom.prototype.getMember = function (userId) {\n  return this.currentState.getMember(userId);\n};\n/**\n * Get a list of members whose membership state is \"join\".\n * @return {RoomMember[]} A list of currently joined members.\n */\n\n\nRoom.prototype.getJoinedMembers = function () {\n  return this.getMembersWithMembership(\"join\");\n};\n/**\n * Returns the number of joined members in this room\n * This method caches the result.\n * This is a wrapper around the method of the same name in roomState, returning\n * its result for the room's current state.\n * @return {integer} The number of members in this room whose membership is 'join'\n */\n\n\nRoom.prototype.getJoinedMemberCount = function () {\n  return this.currentState.getJoinedMemberCount();\n};\n/**\n * Returns the number of invited members in this room\n * @return {integer} The number of members in this room whose membership is 'invite'\n */\n\n\nRoom.prototype.getInvitedMemberCount = function () {\n  return this.currentState.getInvitedMemberCount();\n};\n/**\n * Returns the number of invited + joined members in this room\n * @return {integer} The number of members in this room whose membership is 'invite' or 'join'\n */\n\n\nRoom.prototype.getInvitedAndJoinedMemberCount = function () {\n  return this.getInvitedMemberCount() + this.getJoinedMemberCount();\n};\n/**\n * Get a list of members with given membership state.\n * @param {string} membership The membership state.\n * @return {RoomMember[]} A list of members with the given membership state.\n */\n\n\nRoom.prototype.getMembersWithMembership = function (membership) {\n  return utils.filter(this.currentState.getMembers(), function (m) {\n    return m.membership === membership;\n  });\n};\n/**\n * Get a list of members we should be encrypting for in this room\n * @return {Promise<RoomMember[]>} A list of members who\n * we should encrypt messages for in this room.\n */\n\n\nRoom.prototype.getEncryptionTargetMembers = async function () {\n  await this.loadMembersIfNeeded();\n  let members = this.getMembersWithMembership(\"join\");\n\n  if (this.shouldEncryptForInvitedMembers()) {\n    members = members.concat(this.getMembersWithMembership(\"invite\"));\n  }\n\n  return members;\n};\n/**\n * Determine whether we should encrypt messages for invited users in this room\n * @return {boolean} if we should encrypt messages for invited users\n */\n\n\nRoom.prototype.shouldEncryptForInvitedMembers = function () {\n  const ev = this.currentState.getStateEvents(\"m.room.history_visibility\", \"\");\n  return ev && ev.getContent() && ev.getContent().history_visibility !== \"joined\";\n};\n/**\n * Get the default room name (i.e. what a given user would see if the\n * room had no m.room.name)\n * @param {string} userId The userId from whose perspective we want\n * to calculate the default name\n * @return {string} The default room name\n */\n\n\nRoom.prototype.getDefaultRoomName = function (userId) {\n  return calculateRoomName(this, userId, true);\n};\n/**\n* Check if the given user_id has the given membership state.\n* @param {string} userId The user ID to check.\n* @param {string} membership The membership e.g. <code>'join'</code>\n* @return {boolean} True if this user_id has the given membership state.\n*/\n\n\nRoom.prototype.hasMembershipState = function (userId, membership) {\n  const member = this.getMember(userId);\n\n  if (!member) {\n    return false;\n  }\n\n  return member.membership === membership;\n};\n/**\n * Add a timelineSet for this room with the given filter\n * @param {Filter} filter  The filter to be applied to this timelineSet\n * @return {EventTimelineSet}  The timelineSet\n */\n\n\nRoom.prototype.getOrCreateFilteredTimelineSet = function (filter) {\n  if (this._filteredTimelineSets[filter.filterId]) {\n    return this._filteredTimelineSets[filter.filterId];\n  }\n\n  const opts = Object.assign({\n    filter: filter\n  }, this._opts);\n  const timelineSet = new _eventTimelineSet.EventTimelineSet(this, opts);\n  this.reEmitter.reEmit(timelineSet, [\"Room.timeline\", \"Room.timelineReset\"]);\n  this._filteredTimelineSets[filter.filterId] = timelineSet;\n\n  this._timelineSets.push(timelineSet); // populate up the new timelineSet with filtered events from our live\n  // unfiltered timeline.\n  //\n  // XXX: This is risky as our timeline\n  // may have grown huge and so take a long time to filter.\n  // see https://github.com/vector-im/vector-web/issues/2109\n\n\n  const unfilteredLiveTimeline = this.getLiveTimeline();\n  unfilteredLiveTimeline.getEvents().forEach(function (event) {\n    timelineSet.addLiveEvent(event);\n  }); // find the earliest unfiltered timeline\n\n  let timeline = unfilteredLiveTimeline;\n\n  while (timeline.getNeighbouringTimeline(_eventTimeline.EventTimeline.BACKWARDS)) {\n    timeline = timeline.getNeighbouringTimeline(_eventTimeline.EventTimeline.BACKWARDS);\n  }\n\n  timelineSet.getLiveTimeline().setPaginationToken(timeline.getPaginationToken(_eventTimeline.EventTimeline.BACKWARDS), _eventTimeline.EventTimeline.BACKWARDS); // alternatively, we could try to do something like this to try and re-paginate\n  // in the filtered events from nothing, but Mark says it's an abuse of the API\n  // to do so:\n  //\n  // timelineSet.resetLiveTimeline(\n  //      unfilteredLiveTimeline.getPaginationToken(EventTimeline.FORWARDS)\n  // );\n\n  return timelineSet;\n};\n/**\n * Forget the timelineSet for this room with the given filter\n *\n * @param {Filter} filter  the filter whose timelineSet is to be forgotten\n */\n\n\nRoom.prototype.removeFilteredTimelineSet = function (filter) {\n  const timelineSet = this._filteredTimelineSets[filter.filterId];\n  delete this._filteredTimelineSets[filter.filterId];\n\n  const i = this._timelineSets.indexOf(timelineSet);\n\n  if (i > -1) {\n    this._timelineSets.splice(i, 1);\n  }\n};\n/**\n * Add an event to the end of this room's live timelines. Will fire\n * \"Room.timeline\".\n *\n * @param {MatrixEvent} event Event to be added\n * @param {string?} duplicateStrategy 'ignore' or 'replace'\n * @fires module:client~MatrixClient#event:\"Room.timeline\"\n * @private\n */\n\n\nRoom.prototype._addLiveEvent = function (event, duplicateStrategy) {\n  if (event.isRedaction()) {\n    const redactId = event.event.redacts; // if we know about this event, redact its contents now.\n\n    const redactedEvent = this.getUnfilteredTimelineSet().findEventById(redactId);\n\n    if (redactedEvent) {\n      redactedEvent.makeRedacted(event); // If this is in the current state, replace it with the redacted version\n\n      if (redactedEvent.getStateKey()) {\n        const currentStateEvent = this.currentState.getStateEvents(redactedEvent.getType(), redactedEvent.getStateKey());\n\n        if (currentStateEvent.getId() === redactedEvent.getId()) {\n          this.currentState.setStateEvents([redactedEvent]);\n        }\n      }\n\n      this.emit(\"Room.redaction\", event, this); // TODO: we stash user displaynames (among other things) in\n      // RoomMember objects which are then attached to other events\n      // (in the sender and target fields). We should get those\n      // RoomMember objects to update themselves when the events that\n      // they are based on are changed.\n    } // FIXME: apply redactions to notification list\n    // NB: We continue to add the redaction event to the timeline so\n    // clients can say \"so and so redacted an event\" if they wish to. Also\n    // this may be needed to trigger an update.\n\n  }\n\n  if (event.getUnsigned().transaction_id) {\n    const existingEvent = this._txnToEvent[event.getUnsigned().transaction_id];\n\n    if (existingEvent) {\n      // remote echo of an event we sent earlier\n      this._handleRemoteEcho(event, existingEvent);\n\n      return;\n    }\n  } // add to our timeline sets\n\n\n  for (let i = 0; i < this._timelineSets.length; i++) {\n    this._timelineSets[i].addLiveEvent(event, duplicateStrategy);\n  } // synthesize and inject implicit read receipts\n  // Done after adding the event because otherwise the app would get a read receipt\n  // pointing to an event that wasn't yet in the timeline\n  // Don't synthesize RR for m.room.redaction as this causes the RR to go missing.\n\n\n  if (event.sender && event.getType() !== \"m.room.redaction\") {\n    this.addReceipt(synthesizeReceipt(event.sender.userId, event, \"m.read\"), true); // Any live events from a user could be taken as implicit\n    // presence information: evidence that they are currently active.\n    // ...except in a world where we use 'user.currentlyActive' to reduce\n    // presence spam, this isn't very useful - we'll get a transition when\n    // they are no longer currently active anyway. So don't bother to\n    // reset the lastActiveAgo and lastPresenceTs from the RoomState's user.\n  }\n};\n/**\n * Add a pending outgoing event to this room.\n *\n * <p>The event is added to either the pendingEventList, or the live timeline,\n * depending on the setting of opts.pendingEventOrdering.\n *\n * <p>This is an internal method, intended for use by MatrixClient.\n *\n * @param {module:models/event.MatrixEvent} event The event to add.\n *\n * @param {string} txnId   Transaction id for this outgoing event\n *\n * @fires module:client~MatrixClient#event:\"Room.localEchoUpdated\"\n *\n * @throws if the event doesn't have status SENDING, or we aren't given a\n * unique transaction id.\n */\n\n\nRoom.prototype.addPendingEvent = function (event, txnId) {\n  if (event.status !== _event.EventStatus.SENDING) {\n    throw new Error(\"addPendingEvent called on an event with status \" + event.status);\n  }\n\n  if (this._txnToEvent[txnId]) {\n    throw new Error(\"addPendingEvent called on an event with known txnId \" + txnId);\n  } // call setEventMetadata to set up event.sender etc\n  // as event is shared over all timelineSets, we set up its metadata based\n  // on the unfiltered timelineSet.\n\n\n  _eventTimeline.EventTimeline.setEventMetadata(event, this.getLiveTimeline().getState(_eventTimeline.EventTimeline.FORWARDS), false);\n\n  this._txnToEvent[txnId] = event;\n\n  if (this._opts.pendingEventOrdering == \"detached\") {\n    if (this._pendingEventList.some(e => e.status === _event.EventStatus.NOT_SENT)) {\n      _logger.logger.warn(\"Setting event as NOT_SENT due to messages in the same state\");\n\n      event.setStatus(_event.EventStatus.NOT_SENT);\n    }\n\n    this._pendingEventList.push(event);\n\n    if (event.isRelation()) {\n      // For pending events, add them to the relations collection immediately.\n      // (The alternate case below already covers this as part of adding to\n      // the timeline set.)\n      this._aggregateNonLiveRelation(event);\n    }\n\n    if (event.isRedaction()) {\n      const redactId = event.event.redacts;\n\n      let redactedEvent = this._pendingEventList && this._pendingEventList.find(e => e.getId() === redactId);\n\n      if (!redactedEvent) {\n        redactedEvent = this.getUnfilteredTimelineSet().findEventById(redactId);\n      }\n\n      if (redactedEvent) {\n        redactedEvent.markLocallyRedacted(event);\n        this.emit(\"Room.redaction\", event, this);\n      }\n    }\n  } else {\n    for (let i = 0; i < this._timelineSets.length; i++) {\n      const timelineSet = this._timelineSets[i];\n\n      if (timelineSet.getFilter()) {\n        if (timelineSet.getFilter().filterRoomTimeline([event]).length) {\n          timelineSet.addEventToTimeline(event, timelineSet.getLiveTimeline(), false);\n        }\n      } else {\n        timelineSet.addEventToTimeline(event, timelineSet.getLiveTimeline(), false);\n      }\n    }\n  }\n\n  this.emit(\"Room.localEchoUpdated\", event, this, null, null);\n};\n/**\n * Used to aggregate the local echo for a relation, and also\n * for re-applying a relation after it's redaction has been cancelled,\n * as the local echo for the redaction of the relation would have\n * un-aggregated the relation. Note that this is different from regular messages,\n * which are just kept detached for their local echo.\n *\n * Also note that live events are aggregated in the live EventTimelineSet.\n * @param {module:models/event.MatrixEvent} event the relation event that needs to be aggregated.\n */\n\n\nRoom.prototype._aggregateNonLiveRelation = function (event) {\n  // TODO: We should consider whether this means it would be a better\n  // design to lift the relations handling up to the room instead.\n  for (let i = 0; i < this._timelineSets.length; i++) {\n    const timelineSet = this._timelineSets[i];\n\n    if (timelineSet.getFilter()) {\n      if (timelineSet.getFilter().filterRoomTimeline([event]).length) {\n        timelineSet.aggregateRelations(event);\n      }\n    } else {\n      timelineSet.aggregateRelations(event);\n    }\n  }\n};\n/**\n * Deal with the echo of a message we sent.\n *\n * <p>We move the event to the live timeline if it isn't there already, and\n * update it.\n *\n * @param {module:models/event.MatrixEvent} remoteEvent   The event received from\n *    /sync\n * @param {module:models/event.MatrixEvent} localEvent    The local echo, which\n *    should be either in the _pendingEventList or the timeline.\n *\n * @fires module:client~MatrixClient#event:\"Room.localEchoUpdated\"\n * @private\n */\n\n\nRoom.prototype._handleRemoteEcho = function (remoteEvent, localEvent) {\n  const oldEventId = localEvent.getId();\n  const newEventId = remoteEvent.getId();\n  const oldStatus = localEvent.status; // no longer pending\n\n  delete this._txnToEvent[remoteEvent.getUnsigned().transaction_id]; // if it's in the pending list, remove it\n\n  if (this._pendingEventList) {\n    utils.removeElement(this._pendingEventList, function (ev) {\n      return ev.getId() == oldEventId;\n    }, false);\n  } // replace the event source (this will preserve the plaintext payload if\n  // any, which is good, because we don't want to try decoding it again).\n\n\n  localEvent.handleRemoteEcho(remoteEvent.event);\n\n  for (let i = 0; i < this._timelineSets.length; i++) {\n    const timelineSet = this._timelineSets[i]; // if it's already in the timeline, update the timeline map. If it's not, add it.\n\n    timelineSet.handleRemoteEcho(localEvent, oldEventId, newEventId);\n  }\n\n  this.emit(\"Room.localEchoUpdated\", localEvent, this, oldEventId, oldStatus);\n};\n/* a map from current event status to a list of allowed next statuses\n */\n\n\nconst ALLOWED_TRANSITIONS = {};\nALLOWED_TRANSITIONS[_event.EventStatus.ENCRYPTING] = [_event.EventStatus.SENDING, _event.EventStatus.NOT_SENT];\nALLOWED_TRANSITIONS[_event.EventStatus.SENDING] = [_event.EventStatus.ENCRYPTING, _event.EventStatus.QUEUED, _event.EventStatus.NOT_SENT, _event.EventStatus.SENT];\nALLOWED_TRANSITIONS[_event.EventStatus.QUEUED] = [_event.EventStatus.SENDING, _event.EventStatus.CANCELLED];\nALLOWED_TRANSITIONS[_event.EventStatus.SENT] = [];\nALLOWED_TRANSITIONS[_event.EventStatus.NOT_SENT] = [_event.EventStatus.SENDING, _event.EventStatus.QUEUED, _event.EventStatus.CANCELLED];\nALLOWED_TRANSITIONS[_event.EventStatus.CANCELLED] = [];\n/**\n * Update the status / event id on a pending event, to reflect its transmission\n * progress.\n *\n * <p>This is an internal method.\n *\n * @param {MatrixEvent} event      local echo event\n * @param {EventStatus} newStatus  status to assign\n * @param {string} newEventId      new event id to assign. Ignored unless\n *    newStatus == EventStatus.SENT.\n * @fires module:client~MatrixClient#event:\"Room.localEchoUpdated\"\n */\n\nRoom.prototype.updatePendingEvent = function (event, newStatus, newEventId) {\n  _logger.logger.log(`setting pendingEvent status to ${newStatus} in ${event.getRoomId()}`); // if the message was sent, we expect an event id\n\n\n  if (newStatus == _event.EventStatus.SENT && !newEventId) {\n    throw new Error(\"updatePendingEvent called with status=SENT, \" + \"but no new event id\");\n  } // SENT races against /sync, so we have to special-case it.\n\n\n  if (newStatus == _event.EventStatus.SENT) {\n    const timeline = this.getUnfilteredTimelineSet().eventIdToTimeline(newEventId);\n\n    if (timeline) {\n      // we've already received the event via the event stream.\n      // nothing more to do here.\n      return;\n    }\n  }\n\n  const oldStatus = event.status;\n  const oldEventId = event.getId();\n\n  if (!oldStatus) {\n    throw new Error(\"updatePendingEventStatus called on an event which is \" + \"not a local echo.\");\n  }\n\n  const allowed = ALLOWED_TRANSITIONS[oldStatus];\n\n  if (!allowed || allowed.indexOf(newStatus) < 0) {\n    throw new Error(\"Invalid EventStatus transition \" + oldStatus + \"->\" + newStatus);\n  }\n\n  event.setStatus(newStatus);\n\n  if (newStatus == _event.EventStatus.SENT) {\n    // update the event id\n    event.replaceLocalEventId(newEventId); // if the event was already in the timeline (which will be the case if\n    // opts.pendingEventOrdering==chronological), we need to update the\n    // timeline map.\n\n    for (let i = 0; i < this._timelineSets.length; i++) {\n      this._timelineSets[i].replaceEventId(oldEventId, newEventId);\n    }\n  } else if (newStatus == _event.EventStatus.CANCELLED) {\n    // remove it from the pending event list, or the timeline.\n    if (this._pendingEventList) {\n      const idx = this._pendingEventList.findIndex(ev => ev.getId() === oldEventId);\n\n      if (idx !== -1) {\n        const [removedEvent] = this._pendingEventList.splice(idx, 1);\n\n        if (removedEvent.isRedaction()) {\n          this._revertRedactionLocalEcho(removedEvent);\n        }\n      }\n    }\n\n    this.removeEvent(oldEventId);\n  }\n\n  this.emit(\"Room.localEchoUpdated\", event, this, oldEventId, oldStatus);\n};\n\nRoom.prototype._revertRedactionLocalEcho = function (redactionEvent) {\n  const redactId = redactionEvent.event.redacts;\n\n  if (!redactId) {\n    return;\n  }\n\n  const redactedEvent = this.getUnfilteredTimelineSet().findEventById(redactId);\n\n  if (redactedEvent) {\n    redactedEvent.unmarkLocallyRedacted(); // re-render after undoing redaction\n\n    this.emit(\"Room.redactionCancelled\", redactionEvent, this); // reapply relation now redaction failed\n\n    if (redactedEvent.isRelation()) {\n      this._aggregateNonLiveRelation(redactedEvent);\n    }\n  }\n};\n/**\n * Add some events to this room. This can include state events, message\n * events and typing notifications. These events are treated as \"live\" so\n * they will go to the end of the timeline.\n *\n * @param {MatrixEvent[]} events A list of events to add.\n *\n * @param {string} duplicateStrategy Optional. Applies to events in the\n * timeline only. If this is 'replace' then if a duplicate is encountered, the\n * event passed to this function will replace the existing event in the\n * timeline. If this is not specified, or is 'ignore', then the event passed to\n * this function will be ignored entirely, preserving the existing event in the\n * timeline. Events are identical based on their event ID <b>only</b>.\n *\n * @throws If <code>duplicateStrategy</code> is not falsey, 'replace' or 'ignore'.\n */\n\n\nRoom.prototype.addLiveEvents = function (events, duplicateStrategy) {\n  let i;\n\n  if (duplicateStrategy && [\"replace\", \"ignore\"].indexOf(duplicateStrategy) === -1) {\n    throw new Error(\"duplicateStrategy MUST be either 'replace' or 'ignore'\");\n  } // sanity check that the live timeline is still live\n\n\n  for (i = 0; i < this._timelineSets.length; i++) {\n    const liveTimeline = this._timelineSets[i].getLiveTimeline();\n\n    if (liveTimeline.getPaginationToken(_eventTimeline.EventTimeline.FORWARDS)) {\n      throw new Error(\"live timeline \" + i + \" is no longer live - it has a pagination token \" + \"(\" + liveTimeline.getPaginationToken(_eventTimeline.EventTimeline.FORWARDS) + \")\");\n    }\n\n    if (liveTimeline.getNeighbouringTimeline(_eventTimeline.EventTimeline.FORWARDS)) {\n      throw new Error(\"live timeline \" + i + \" is no longer live - \" + \"it has a neighbouring timeline\");\n    }\n  }\n\n  for (i = 0; i < events.length; i++) {\n    // TODO: We should have a filter to say \"only add state event\n    // types X Y Z to the timeline\".\n    this._addLiveEvent(events[i], duplicateStrategy);\n  }\n};\n/**\n * Adds/handles ephemeral events such as typing notifications and read receipts.\n * @param {MatrixEvent[]} events A list of events to process\n */\n\n\nRoom.prototype.addEphemeralEvents = function (events) {\n  for (const event of events) {\n    if (event.getType() === 'm.typing') {\n      this.currentState.setTypingEvent(event);\n    } else if (event.getType() === 'm.receipt') {\n      this.addReceipt(event);\n    } // else ignore - life is too short for us to care about these events\n\n  }\n};\n/**\n * Removes events from this room.\n * @param {String[]} eventIds A list of eventIds to remove.\n */\n\n\nRoom.prototype.removeEvents = function (eventIds) {\n  for (let i = 0; i < eventIds.length; ++i) {\n    this.removeEvent(eventIds[i]);\n  }\n};\n/**\n * Removes a single event from this room.\n *\n * @param {String} eventId  The id of the event to remove\n *\n * @return {bool} true if the event was removed from any of the room's timeline sets\n */\n\n\nRoom.prototype.removeEvent = function (eventId) {\n  let removedAny = false;\n\n  for (let i = 0; i < this._timelineSets.length; i++) {\n    const removed = this._timelineSets[i].removeEvent(eventId);\n\n    if (removed) {\n      if (removed.isRedaction()) {\n        this._revertRedactionLocalEcho(removed);\n      }\n\n      removedAny = true;\n    }\n  }\n\n  return removedAny;\n};\n/**\n * Recalculate various aspects of the room, including the room name and\n * room summary. Call this any time the room's current state is modified.\n * May fire \"Room.name\" if the room name is updated.\n * @fires module:client~MatrixClient#event:\"Room.name\"\n */\n\n\nRoom.prototype.recalculate = function () {\n  // set fake stripped state events if this is an invite room so logic remains\n  // consistent elsewhere.\n  const self = this;\n  const membershipEvent = this.currentState.getStateEvents(\"m.room.member\", this.myUserId);\n\n  if (membershipEvent && membershipEvent.getContent().membership === \"invite\") {\n    const strippedStateEvents = membershipEvent.event.invite_room_state || [];\n    utils.forEach(strippedStateEvents, function (strippedEvent) {\n      const existingEvent = self.currentState.getStateEvents(strippedEvent.type, strippedEvent.state_key);\n\n      if (!existingEvent) {\n        // set the fake stripped event instead\n        self.currentState.setStateEvents([new _event.MatrixEvent({\n          type: strippedEvent.type,\n          state_key: strippedEvent.state_key,\n          content: strippedEvent.content,\n          event_id: \"$fake\" + Date.now(),\n          room_id: self.roomId,\n          user_id: self.myUserId // technically a lie\n\n        })]);\n      }\n    });\n  }\n\n  const oldName = this.name;\n  this.name = calculateRoomName(this, this.myUserId);\n  this.summary = new _roomSummary.RoomSummary(this.roomId, {\n    title: this.name\n  });\n\n  if (oldName !== this.name) {\n    this.emit(\"Room.name\", this);\n  }\n};\n/**\n * Get a list of user IDs who have <b>read up to</b> the given event.\n * @param {MatrixEvent} event the event to get read receipts for.\n * @return {String[]} A list of user IDs.\n */\n\n\nRoom.prototype.getUsersReadUpTo = function (event) {\n  return this.getReceiptsForEvent(event).filter(function (receipt) {\n    return receipt.type === \"m.read\";\n  }).map(function (receipt) {\n    return receipt.userId;\n  });\n};\n/**\n * Get the ID of the event that a given user has read up to, or null if we\n * have received no read receipts from them.\n * @param {String} userId The user ID to get read receipt event ID for\n * @param {Boolean} ignoreSynthesized If true, return only receipts that have been\n *                                    sent by the server, not implicit ones generated\n *                                    by the JS SDK.\n * @return {String} ID of the latest event that the given user has read, or null.\n */\n\n\nRoom.prototype.getEventReadUpTo = function (userId, ignoreSynthesized) {\n  let receipts = this._receipts;\n\n  if (ignoreSynthesized) {\n    receipts = this._realReceipts;\n  }\n\n  if (receipts[\"m.read\"] === undefined || receipts[\"m.read\"][userId] === undefined) {\n    return null;\n  }\n\n  return receipts[\"m.read\"][userId].eventId;\n};\n/**\n * Determines if the given user has read a particular event ID with the known\n * history of the room. This is not a definitive check as it relies only on\n * what is available to the room at the time of execution.\n * @param {String} userId The user ID to check the read state of.\n * @param {String} eventId The event ID to check if the user read.\n * @returns {Boolean} True if the user has read the event, false otherwise.\n */\n\n\nRoom.prototype.hasUserReadEvent = function (userId, eventId) {\n  const readUpToId = this.getEventReadUpTo(userId, false);\n  if (readUpToId === eventId) return true;\n\n  if (this.timeline.length && this.timeline[this.timeline.length - 1].getSender() && this.timeline[this.timeline.length - 1].getSender() === userId) {\n    // It doesn't matter where the event is in the timeline, the user has read\n    // it because they've sent the latest event.\n    return true;\n  }\n\n  for (let i = this.timeline.length - 1; i >= 0; --i) {\n    const ev = this.timeline[i]; // If we encounter the target event first, the user hasn't read it\n    // however if we encounter the readUpToId first then the user has read\n    // it. These rules apply because we're iterating bottom-up.\n\n    if (ev.getId() === eventId) return false;\n    if (ev.getId() === readUpToId) return true;\n  } // We don't know if the user has read it, so assume not.\n\n\n  return false;\n};\n/**\n * Get a list of receipts for the given event.\n * @param {MatrixEvent} event the event to get receipts for\n * @return {Object[]} A list of receipts with a userId, type and data keys or\n * an empty list.\n */\n\n\nRoom.prototype.getReceiptsForEvent = function (event) {\n  return this._receiptCacheByEventId[event.getId()] || [];\n};\n/**\n * Add a receipt event to the room.\n * @param {MatrixEvent} event The m.receipt event.\n * @param {Boolean} fake True if this event is implicit\n */\n\n\nRoom.prototype.addReceipt = function (event, fake) {\n  // event content looks like:\n  // content: {\n  //   $event_id: {\n  //     $receipt_type: {\n  //       $user_id: {\n  //         ts: $timestamp\n  //       }\n  //     }\n  //   }\n  // }\n  if (fake === undefined) {\n    fake = false;\n  }\n\n  if (!fake) {\n    this._addReceiptsToStructure(event, this._realReceipts); // we don't bother caching real receipts by event ID\n    // as there's nothing that would read it.\n\n  }\n\n  this._addReceiptsToStructure(event, this._receipts);\n\n  this._receiptCacheByEventId = this._buildReceiptCache(this._receipts); // send events after we've regenerated the cache, otherwise things that\n  // listened for the event would read from a stale cache\n\n  this.emit(\"Room.receipt\", event, this);\n};\n/**\n * Add a receipt event to the room.\n * @param {MatrixEvent} event The m.receipt event.\n * @param {Object} receipts The object to add receipts to\n */\n\n\nRoom.prototype._addReceiptsToStructure = function (event, receipts) {\n  const self = this;\n  utils.keys(event.getContent()).forEach(function (eventId) {\n    utils.keys(event.getContent()[eventId]).forEach(function (receiptType) {\n      utils.keys(event.getContent()[eventId][receiptType]).forEach(function (userId) {\n        const receipt = event.getContent()[eventId][receiptType][userId];\n\n        if (!receipts[receiptType]) {\n          receipts[receiptType] = {};\n        }\n\n        const existingReceipt = receipts[receiptType][userId];\n\n        if (!existingReceipt) {\n          receipts[receiptType][userId] = {};\n        } else {\n          // we only want to add this receipt if we think it is later\n          // than the one we already have. (This is managed\n          // server-side, but because we synthesize RRs locally we\n          // have to do it here too.)\n          const ordering = self.getUnfilteredTimelineSet().compareEventOrdering(existingReceipt.eventId, eventId);\n\n          if (ordering !== null && ordering >= 0) {\n            return;\n          }\n        }\n\n        receipts[receiptType][userId] = {\n          eventId: eventId,\n          data: receipt\n        };\n      });\n    });\n  });\n};\n/**\n * Build and return a map of receipts by event ID\n * @param {Object} receipts A map of receipts\n * @return {Object} Map of receipts by event ID\n */\n\n\nRoom.prototype._buildReceiptCache = function (receipts) {\n  const receiptCacheByEventId = {};\n  utils.keys(receipts).forEach(function (receiptType) {\n    utils.keys(receipts[receiptType]).forEach(function (userId) {\n      const receipt = receipts[receiptType][userId];\n\n      if (!receiptCacheByEventId[receipt.eventId]) {\n        receiptCacheByEventId[receipt.eventId] = [];\n      }\n\n      receiptCacheByEventId[receipt.eventId].push({\n        userId: userId,\n        type: receiptType,\n        data: receipt.data\n      });\n    });\n  });\n  return receiptCacheByEventId;\n};\n/**\n * Add a temporary local-echo receipt to the room to reflect in the\n * client the fact that we've sent one.\n * @param {string} userId The user ID if the receipt sender\n * @param {MatrixEvent} e The event that is to be acknowledged\n * @param {string} receiptType The type of receipt\n */\n\n\nRoom.prototype._addLocalEchoReceipt = function (userId, e, receiptType) {\n  this.addReceipt(synthesizeReceipt(userId, e, receiptType), true);\n};\n/**\n * Update the room-tag event for the room.  The previous one is overwritten.\n * @param {MatrixEvent} event the m.tag event\n */\n\n\nRoom.prototype.addTags = function (event) {\n  // event content looks like:\n  // content: {\n  //    tags: {\n  //       $tagName: { $metadata: $value },\n  //       $tagName: { $metadata: $value },\n  //    }\n  // }\n  // XXX: do we need to deep copy here?\n  this.tags = event.getContent().tags || {}; // XXX: we could do a deep-comparison to see if the tags have really\n  // changed - but do we want to bother?\n\n  this.emit(\"Room.tags\", event, this);\n};\n/**\n * Update the account_data events for this room, overwriting events of the same type.\n * @param {Array<MatrixEvent>} events an array of account_data events to add\n */\n\n\nRoom.prototype.addAccountData = function (events) {\n  for (let i = 0; i < events.length; i++) {\n    const event = events[i];\n\n    if (event.getType() === \"m.tag\") {\n      this.addTags(event);\n    }\n\n    this.accountData[event.getType()] = event;\n    this.emit(\"Room.accountData\", event, this);\n  }\n};\n/**\n * Access account_data event of given event type for this room\n * @param {string} type the type of account_data event to be accessed\n * @return {?MatrixEvent} the account_data event in question\n */\n\n\nRoom.prototype.getAccountData = function (type) {\n  return this.accountData[type];\n};\n/**\n * Returns wheter the syncing user has permission to send a message in the room\n * @return {boolean} true if the user should be permitted to send\n *                   message events into the room.\n */\n\n\nRoom.prototype.maySendMessage = function () {\n  return this.getMyMembership() === 'join' && this.currentState.maySendEvent('m.room.message', this.myUserId);\n};\n/**\n * This is an internal method. Calculates the name of the room from the current\n * room state.\n * @param {Room} room The matrix room.\n * @param {string} userId The client's user ID. Used to filter room members\n * correctly.\n * @param {bool} ignoreRoomNameEvent Return the implicit room name that we'd see if there\n * was no m.room.name event.\n * @return {string} The calculated room name.\n */\n\n\nfunction calculateRoomName(room, userId, ignoreRoomNameEvent) {\n  if (!ignoreRoomNameEvent) {\n    // check for an alias, if any. for now, assume first alias is the\n    // official one.\n    const mRoomName = room.currentState.getStateEvents(\"m.room.name\", \"\");\n\n    if (mRoomName && mRoomName.getContent() && mRoomName.getContent().name) {\n      return mRoomName.getContent().name;\n    }\n  }\n\n  let alias = room.getCanonicalAlias();\n\n  if (!alias) {\n    const aliases = room.getAliases();\n\n    if (aliases.length) {\n      alias = aliases[0];\n    }\n  }\n\n  if (alias) {\n    return alias;\n  }\n\n  const joinedMemberCount = room.currentState.getJoinedMemberCount();\n  const invitedMemberCount = room.currentState.getInvitedMemberCount(); // -1 because these numbers include the syncing user\n\n  const inviteJoinCount = joinedMemberCount + invitedMemberCount - 1; // get members that are NOT ourselves and are actually in the room.\n\n  let otherNames = null;\n\n  if (room._summaryHeroes) {\n    // if we have a summary, the member state events\n    // should be in the room state\n    otherNames = room._summaryHeroes.map(userId => {\n      const member = room.getMember(userId);\n      return member ? member.name : userId;\n    });\n  } else {\n    let otherMembers = room.currentState.getMembers().filter(m => {\n      return m.userId !== userId && (m.membership === \"invite\" || m.membership === \"join\");\n    }); // make sure members have stable order\n\n    otherMembers.sort((a, b) => a.userId.localeCompare(b.userId)); // only 5 first members, immitate _summaryHeroes\n\n    otherMembers = otherMembers.slice(0, 5);\n    otherNames = otherMembers.map(m => m.name);\n  }\n\n  if (inviteJoinCount) {\n    return memberNamesToRoomName(otherNames, inviteJoinCount);\n  }\n\n  const myMembership = room.getMyMembership(); // if I have created a room and invited people throuh\n  // 3rd party invites\n\n  if (myMembership == 'join') {\n    const thirdPartyInvites = room.currentState.getStateEvents(\"m.room.third_party_invite\");\n\n    if (thirdPartyInvites && thirdPartyInvites.length) {\n      const thirdPartyNames = thirdPartyInvites.map(i => {\n        return i.getContent().display_name;\n      });\n      return `Inviting ${memberNamesToRoomName(thirdPartyNames)}`;\n    }\n  } // let's try to figure out who was here before\n\n\n  let leftNames = otherNames; // if we didn't have heroes, try finding them in the room state\n\n  if (!leftNames.length) {\n    leftNames = room.currentState.getMembers().filter(m => {\n      return m.userId !== userId && m.membership !== \"invite\" && m.membership !== \"join\";\n    }).map(m => m.name);\n  }\n\n  if (leftNames.length) {\n    return `Empty room (was ${memberNamesToRoomName(leftNames)})`;\n  } else {\n    return \"Empty room\";\n  }\n}\n\nfunction memberNamesToRoomName(names, count = names.length + 1) {\n  const countWithoutMe = count - 1;\n\n  if (!names.length) {\n    return \"Empty room\";\n  } else if (names.length === 1 && countWithoutMe <= 1) {\n    return names[0];\n  } else if (names.length === 2 && countWithoutMe <= 2) {\n    return `${names[0]} and ${names[1]}`;\n  } else {\n    const plural = countWithoutMe > 1;\n\n    if (plural) {\n      return `${names[0]} and ${countWithoutMe} others`;\n    } else {\n      return `${names[0]} and 1 other`;\n    }\n  }\n}\n/**\n * Fires when an event we had previously received is redacted.\n *\n * (Note this is *not* fired when the redaction happens before we receive the\n * event).\n *\n * @event module:client~MatrixClient#\"Room.redaction\"\n * @param {MatrixEvent} event The matrix redaction event\n * @param {Room} room The room containing the redacted event\n */\n\n/**\n * Fires when an event that was previously redacted isn't anymore.\n * This happens when the redaction couldn't be sent and\n * was subsequently cancelled by the user. Redactions have a local echo\n * which is undone in this scenario.\n *\n * @event module:client~MatrixClient#\"Room.redactionCancelled\"\n * @param {MatrixEvent} event The matrix redaction event that was cancelled.\n * @param {Room} room The room containing the unredacted event\n */\n\n/**\n * Fires whenever the name of a room is updated.\n * @event module:client~MatrixClient#\"Room.name\"\n * @param {Room} room The room whose Room.name was updated.\n * @example\n * matrixClient.on(\"Room.name\", function(room){\n *   var newName = room.name;\n * });\n */\n\n/**\n * Fires whenever a receipt is received for a room\n * @event module:client~MatrixClient#\"Room.receipt\"\n * @param {event} event The receipt event\n * @param {Room} room The room whose receipts was updated.\n * @example\n * matrixClient.on(\"Room.receipt\", function(event, room){\n *   var receiptContent = event.getContent();\n * });\n */\n\n/**\n * Fires whenever a room's tags are updated.\n * @event module:client~MatrixClient#\"Room.tags\"\n * @param {event} event The tags event\n * @param {Room} room The room whose Room.tags was updated.\n * @example\n * matrixClient.on(\"Room.tags\", function(event, room){\n *   var newTags = event.getContent().tags;\n *   if (newTags[\"favourite\"]) showStar(room);\n * });\n */\n\n/**\n * Fires whenever a room's account_data is updated.\n * @event module:client~MatrixClient#\"Room.accountData\"\n * @param {event} event The account_data event\n * @param {Room} room The room whose account_data was updated.\n * @example\n * matrixClient.on(\"Room.accountData\", function(event, room){\n *   if (event.getType() === \"m.room.colorscheme\") {\n *       applyColorScheme(event.getContents());\n *   }\n * });\n */\n\n/**\n * Fires when the status of a transmitted event is updated.\n *\n * <p>When an event is first transmitted, a temporary copy of the event is\n * inserted into the timeline, with a temporary event id, and a status of\n * 'SENDING'.\n *\n * <p>Once the echo comes back from the server, the content of the event\n * (MatrixEvent.event) is replaced by the complete event from the homeserver,\n * thus updating its event id, as well as server-generated fields such as the\n * timestamp. Its status is set to null.\n *\n * <p>Once the /send request completes, if the remote echo has not already\n * arrived, the event is updated with a new event id and the status is set to\n * 'SENT'. The server-generated fields are of course not updated yet.\n *\n * <p>If the /send fails, In this case, the event's status is set to\n * 'NOT_SENT'. If it is later resent, the process starts again, setting the\n * status to 'SENDING'. Alternatively, the message may be cancelled, which\n * removes the event from the room, and sets the status to 'CANCELLED'.\n *\n * <p>This event is raised to reflect each of the transitions above.\n *\n * @event module:client~MatrixClient#\"Room.localEchoUpdated\"\n *\n * @param {MatrixEvent} event The matrix event which has been updated\n *\n * @param {Room} room The room containing the redacted event\n *\n * @param {string} oldEventId The previous event id (the temporary event id,\n *    except when updating a successfully-sent event when its echo arrives)\n *\n * @param {EventStatus} oldStatus The previous event status.\n */"]},"metadata":{},"sourceType":"script"}