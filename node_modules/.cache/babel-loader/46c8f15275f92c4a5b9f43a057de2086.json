{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VerificationBase = void 0;\n\nvar _event = require(\"../../models/event\");\n\nvar _events = require(\"events\");\n\nvar _logger = require(\"../../logger\");\n\nvar _deviceinfo = require(\"../deviceinfo\");\n\nvar _Error = require(\"./Error\");\n/*\nCopyright 2018 New Vector Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Base class for verification methods.\n * @module crypto/verification/Base\n */\n\n\nconst timeoutException = new Error(\"Verification timed out\");\n\nclass VerificationBase extends _events.EventEmitter {\n  /**\n   * Base class for verification methods.\n   *\n   * <p>Once a verifier object is created, the verification can be started by\n   * calling the verify() method, which will return a promise that will\n   * resolve when the verification is completed, or reject if it could not\n   * complete.</p>\n   *\n   * <p>Subclasses must have a NAME class property.</p>\n   *\n   * @class\n   *\n   * @param {module:base-apis~Channel} channel the verification channel to send verification messages over.\n   *\n   * @param {module:base-apis~MatrixBaseApis} baseApis base matrix api interface\n   *\n   * @param {string} userId the user ID that is being verified\n   *\n   * @param {string} deviceId the device ID that is being verified\n   *\n   * @param {object} [startEvent] the m.key.verification.start event that\n   * initiated this verification, if any\n   *\n   * @param {object} [request] the key verification request object related to\n   * this verification, if any\n   */\n  constructor(channel, baseApis, userId, deviceId, startEvent, request) {\n    super();\n    this._channel = channel;\n    this._baseApis = baseApis;\n    this.userId = userId;\n    this.deviceId = deviceId;\n    this.startEvent = startEvent;\n    this.request = request;\n    this.cancelled = false;\n    this._done = false;\n    this._promise = null;\n    this._transactionTimeoutTimer = null; // At this point, the verification request was received so start the timeout timer.\n\n    this._resetTimer();\n  }\n\n  _resetTimer() {\n    _logger.logger.info(\"Refreshing/starting the verification transaction timeout timer\");\n\n    if (this._transactionTimeoutTimer !== null) {\n      clearTimeout(this._transactionTimeoutTimer);\n    }\n\n    this._transactionTimeoutTimer = setTimeout(() => {\n      if (!this._done && !this.cancelled) {\n        _logger.logger.info(\"Triggering verification timeout\");\n\n        this.cancel(timeoutException);\n      }\n    }, 10 * 60 * 1000); // 10 minutes\n  }\n\n  _endTimer() {\n    if (this._transactionTimeoutTimer !== null) {\n      clearTimeout(this._transactionTimeoutTimer);\n      this._transactionTimeoutTimer = null;\n    }\n  }\n\n  _send(type, uncompletedContent) {\n    return this._channel.send(type, uncompletedContent);\n  }\n\n  _waitForEvent(type) {\n    if (this._done) {\n      return Promise.reject(new Error(\"Verification is already done\"));\n    }\n\n    this._expectedEvent = type;\n    return new Promise((resolve, reject) => {\n      this._resolveEvent = resolve;\n      this._rejectEvent = reject;\n    });\n  }\n\n  handleEvent(e) {\n    if (this._done) {\n      return;\n    } else if (e.getType() === this._expectedEvent) {\n      // if we receive an expected m.key.verification.done, then just\n      // ignore it, since we don't need to do anything about it\n      if (this._expectedEvent !== \"m.key.verification.done\") {\n        this._expectedEvent = undefined;\n        this._rejectEvent = undefined;\n\n        this._resetTimer();\n\n        this._resolveEvent(e);\n      }\n    } else if (e.getType() === \"m.key.verification.cancel\") {\n      const reject = this._reject;\n      this._reject = undefined;\n      reject(new Error(\"Other side cancelled verification\"));\n    } else {\n      const exception = new Error(\"Unexpected message: expecting \" + this._expectedEvent + \" but got \" + e.getType());\n      this._expectedEvent = undefined;\n\n      if (this._rejectEvent) {\n        const reject = this._rejectEvent;\n        this._rejectEvent = undefined;\n        reject(exception);\n      }\n\n      this.cancel(exception);\n    }\n  }\n\n  done() {\n    this._endTimer(); // always kill the activity timer\n\n\n    if (!this._done) {\n      if (this._channel.needsDoneMessage) {\n        // verification in DM requires a done message\n        this._send(\"m.key.verification.done\", {});\n      }\n\n      this._resolve();\n    }\n  }\n\n  cancel(e) {\n    this._endTimer(); // always kill the activity timer\n\n\n    if (!this._done) {\n      this.cancelled = true;\n\n      if (this.userId && this.deviceId) {\n        // send a cancellation to the other user (if it wasn't\n        // cancelled by the other user)\n        if (e === timeoutException) {\n          const timeoutEvent = (0, _Error.newTimeoutError)();\n\n          this._send(timeoutEvent.getType(), timeoutEvent.getContent());\n        } else if (e instanceof _event.MatrixEvent) {\n          const sender = e.getSender();\n\n          if (sender !== this.userId) {\n            const content = e.getContent();\n\n            if (e.getType() === \"m.key.verification.cancel\") {\n              content.code = content.code || \"m.unknown\";\n              content.reason = content.reason || content.body || \"Unknown reason\";\n\n              this._send(\"m.key.verification.cancel\", content);\n            } else {\n              this._send(\"m.key.verification.cancel\", {\n                code: \"m.unknown\",\n                reason: content.body || \"Unknown reason\"\n              });\n            }\n          }\n        } else {\n          this._send(\"m.key.verification.cancel\", {\n            code: \"m.unknown\",\n            reason: e.toString()\n          });\n        }\n      }\n\n      if (this._promise !== null) {\n        // when we cancel without a promise, we end up with a promise\n        // but no reject function. If cancel is called again, we'd error.\n        if (this._reject) this._reject(e);\n      } else {\n        // FIXME: this causes an \"Uncaught promise\" console message\n        // if nothing ends up chaining this promise.\n        this._promise = Promise.reject(e);\n      } // Also emit a 'cancel' event that the app can listen for to detect cancellation\n      // before calling verify()\n\n\n      this.emit('cancel', e);\n    }\n  }\n  /**\n   * Begin the key verification\n   *\n   * @returns {Promise} Promise which resolves when the verification has\n   *     completed.\n   */\n\n\n  verify() {\n    if (this._promise) return this._promise;\n    this._promise = new Promise((resolve, reject) => {\n      this._resolve = (...args) => {\n        this._done = true;\n\n        this._endTimer();\n\n        resolve(...args);\n      };\n\n      this._reject = (...args) => {\n        this._done = true;\n\n        this._endTimer();\n\n        reject(...args);\n      };\n    });\n\n    if (this._doVerification && !this._started) {\n      this._started = true;\n\n      this._resetTimer(); // restart the timeout\n\n\n      Promise.resolve(this._doVerification()).then(this.done.bind(this), this.cancel.bind(this));\n    }\n\n    return this._promise;\n  }\n\n  async _verifyKeys(userId, keys, verifier) {\n    // we try to verify all the keys that we're told about, but we might\n    // not know about all of them, so keep track of the keys that we know\n    // about, and ignore the rest\n    const verifiedDevices = [];\n\n    for (const [keyId, keyInfo] of Object.entries(keys)) {\n      const deviceId = keyId.split(':', 2)[1];\n      const device = await this._baseApis.getStoredDevice(userId, deviceId);\n\n      if (device) {\n        await verifier(keyId, device, keyInfo);\n        verifiedDevices.push(deviceId);\n      } else {\n        const crossSigningInfo = this._baseApis._crypto._deviceList.getStoredCrossSigningForUser(userId);\n\n        if (crossSigningInfo && crossSigningInfo.getId() === deviceId) {\n          await verifier(keyId, _deviceinfo.DeviceInfo.fromStorage({\n            keys: {\n              [keyId]: deviceId\n            }\n          }, deviceId), keyInfo);\n          verifiedDevices.push(deviceId);\n        } else {\n          _logger.logger.warn(`verification: Could not find device ${deviceId} to verify`);\n        }\n      }\n    } // if none of the keys could be verified, then error because the app\n    // should be informed about that\n\n\n    if (!verifiedDevices.length) {\n      throw new Error(\"No devices could be verified\");\n    }\n\n    for (const deviceId of verifiedDevices) {\n      await this._baseApis.setDeviceVerified(userId, deviceId);\n    }\n  }\n\n}\n\nexports.VerificationBase = VerificationBase;","map":{"version":3,"sources":["/home/kimist/Developpement/React/watcha_client/node_modules/matrix-js-sdk/lib/crypto/verification/Base.js"],"names":["Object","defineProperty","exports","value","VerificationBase","_event","require","_events","_logger","_deviceinfo","_Error","timeoutException","Error","EventEmitter","constructor","channel","baseApis","userId","deviceId","startEvent","request","_channel","_baseApis","cancelled","_done","_promise","_transactionTimeoutTimer","_resetTimer","logger","info","clearTimeout","setTimeout","cancel","_endTimer","_send","type","uncompletedContent","send","_waitForEvent","Promise","reject","_expectedEvent","resolve","_resolveEvent","_rejectEvent","handleEvent","e","getType","undefined","_reject","exception","done","needsDoneMessage","_resolve","timeoutEvent","newTimeoutError","getContent","MatrixEvent","sender","getSender","content","code","reason","body","toString","emit","verify","args","_doVerification","_started","then","bind","_verifyKeys","keys","verifier","verifiedDevices","keyId","keyInfo","entries","split","device","getStoredDevice","push","crossSigningInfo","_crypto","_deviceList","getStoredCrossSigningForUser","getId","DeviceInfo","fromStorage","warn","length","setDeviceVerified"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VerificationBase = void 0;\n\nvar _event = require(\"../../models/event\");\n\nvar _events = require(\"events\");\n\nvar _logger = require(\"../../logger\");\n\nvar _deviceinfo = require(\"../deviceinfo\");\n\nvar _Error = require(\"./Error\");\n\n/*\nCopyright 2018 New Vector Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Base class for verification methods.\n * @module crypto/verification/Base\n */\nconst timeoutException = new Error(\"Verification timed out\");\n\nclass VerificationBase extends _events.EventEmitter {\n  /**\n   * Base class for verification methods.\n   *\n   * <p>Once a verifier object is created, the verification can be started by\n   * calling the verify() method, which will return a promise that will\n   * resolve when the verification is completed, or reject if it could not\n   * complete.</p>\n   *\n   * <p>Subclasses must have a NAME class property.</p>\n   *\n   * @class\n   *\n   * @param {module:base-apis~Channel} channel the verification channel to send verification messages over.\n   *\n   * @param {module:base-apis~MatrixBaseApis} baseApis base matrix api interface\n   *\n   * @param {string} userId the user ID that is being verified\n   *\n   * @param {string} deviceId the device ID that is being verified\n   *\n   * @param {object} [startEvent] the m.key.verification.start event that\n   * initiated this verification, if any\n   *\n   * @param {object} [request] the key verification request object related to\n   * this verification, if any\n   */\n  constructor(channel, baseApis, userId, deviceId, startEvent, request) {\n    super();\n    this._channel = channel;\n    this._baseApis = baseApis;\n    this.userId = userId;\n    this.deviceId = deviceId;\n    this.startEvent = startEvent;\n    this.request = request;\n    this.cancelled = false;\n    this._done = false;\n    this._promise = null;\n    this._transactionTimeoutTimer = null; // At this point, the verification request was received so start the timeout timer.\n\n    this._resetTimer();\n  }\n\n  _resetTimer() {\n    _logger.logger.info(\"Refreshing/starting the verification transaction timeout timer\");\n\n    if (this._transactionTimeoutTimer !== null) {\n      clearTimeout(this._transactionTimeoutTimer);\n    }\n\n    this._transactionTimeoutTimer = setTimeout(() => {\n      if (!this._done && !this.cancelled) {\n        _logger.logger.info(\"Triggering verification timeout\");\n\n        this.cancel(timeoutException);\n      }\n    }, 10 * 60 * 1000); // 10 minutes\n  }\n\n  _endTimer() {\n    if (this._transactionTimeoutTimer !== null) {\n      clearTimeout(this._transactionTimeoutTimer);\n      this._transactionTimeoutTimer = null;\n    }\n  }\n\n  _send(type, uncompletedContent) {\n    return this._channel.send(type, uncompletedContent);\n  }\n\n  _waitForEvent(type) {\n    if (this._done) {\n      return Promise.reject(new Error(\"Verification is already done\"));\n    }\n\n    this._expectedEvent = type;\n    return new Promise((resolve, reject) => {\n      this._resolveEvent = resolve;\n      this._rejectEvent = reject;\n    });\n  }\n\n  handleEvent(e) {\n    if (this._done) {\n      return;\n    } else if (e.getType() === this._expectedEvent) {\n      // if we receive an expected m.key.verification.done, then just\n      // ignore it, since we don't need to do anything about it\n      if (this._expectedEvent !== \"m.key.verification.done\") {\n        this._expectedEvent = undefined;\n        this._rejectEvent = undefined;\n\n        this._resetTimer();\n\n        this._resolveEvent(e);\n      }\n    } else if (e.getType() === \"m.key.verification.cancel\") {\n      const reject = this._reject;\n      this._reject = undefined;\n      reject(new Error(\"Other side cancelled verification\"));\n    } else {\n      const exception = new Error(\"Unexpected message: expecting \" + this._expectedEvent + \" but got \" + e.getType());\n      this._expectedEvent = undefined;\n\n      if (this._rejectEvent) {\n        const reject = this._rejectEvent;\n        this._rejectEvent = undefined;\n        reject(exception);\n      }\n\n      this.cancel(exception);\n    }\n  }\n\n  done() {\n    this._endTimer(); // always kill the activity timer\n\n\n    if (!this._done) {\n      if (this._channel.needsDoneMessage) {\n        // verification in DM requires a done message\n        this._send(\"m.key.verification.done\", {});\n      }\n\n      this._resolve();\n    }\n  }\n\n  cancel(e) {\n    this._endTimer(); // always kill the activity timer\n\n\n    if (!this._done) {\n      this.cancelled = true;\n\n      if (this.userId && this.deviceId) {\n        // send a cancellation to the other user (if it wasn't\n        // cancelled by the other user)\n        if (e === timeoutException) {\n          const timeoutEvent = (0, _Error.newTimeoutError)();\n\n          this._send(timeoutEvent.getType(), timeoutEvent.getContent());\n        } else if (e instanceof _event.MatrixEvent) {\n          const sender = e.getSender();\n\n          if (sender !== this.userId) {\n            const content = e.getContent();\n\n            if (e.getType() === \"m.key.verification.cancel\") {\n              content.code = content.code || \"m.unknown\";\n              content.reason = content.reason || content.body || \"Unknown reason\";\n\n              this._send(\"m.key.verification.cancel\", content);\n            } else {\n              this._send(\"m.key.verification.cancel\", {\n                code: \"m.unknown\",\n                reason: content.body || \"Unknown reason\"\n              });\n            }\n          }\n        } else {\n          this._send(\"m.key.verification.cancel\", {\n            code: \"m.unknown\",\n            reason: e.toString()\n          });\n        }\n      }\n\n      if (this._promise !== null) {\n        // when we cancel without a promise, we end up with a promise\n        // but no reject function. If cancel is called again, we'd error.\n        if (this._reject) this._reject(e);\n      } else {\n        // FIXME: this causes an \"Uncaught promise\" console message\n        // if nothing ends up chaining this promise.\n        this._promise = Promise.reject(e);\n      } // Also emit a 'cancel' event that the app can listen for to detect cancellation\n      // before calling verify()\n\n\n      this.emit('cancel', e);\n    }\n  }\n  /**\n   * Begin the key verification\n   *\n   * @returns {Promise} Promise which resolves when the verification has\n   *     completed.\n   */\n\n\n  verify() {\n    if (this._promise) return this._promise;\n    this._promise = new Promise((resolve, reject) => {\n      this._resolve = (...args) => {\n        this._done = true;\n\n        this._endTimer();\n\n        resolve(...args);\n      };\n\n      this._reject = (...args) => {\n        this._done = true;\n\n        this._endTimer();\n\n        reject(...args);\n      };\n    });\n\n    if (this._doVerification && !this._started) {\n      this._started = true;\n\n      this._resetTimer(); // restart the timeout\n\n\n      Promise.resolve(this._doVerification()).then(this.done.bind(this), this.cancel.bind(this));\n    }\n\n    return this._promise;\n  }\n\n  async _verifyKeys(userId, keys, verifier) {\n    // we try to verify all the keys that we're told about, but we might\n    // not know about all of them, so keep track of the keys that we know\n    // about, and ignore the rest\n    const verifiedDevices = [];\n\n    for (const [keyId, keyInfo] of Object.entries(keys)) {\n      const deviceId = keyId.split(':', 2)[1];\n      const device = await this._baseApis.getStoredDevice(userId, deviceId);\n\n      if (device) {\n        await verifier(keyId, device, keyInfo);\n        verifiedDevices.push(deviceId);\n      } else {\n        const crossSigningInfo = this._baseApis._crypto._deviceList.getStoredCrossSigningForUser(userId);\n\n        if (crossSigningInfo && crossSigningInfo.getId() === deviceId) {\n          await verifier(keyId, _deviceinfo.DeviceInfo.fromStorage({\n            keys: {\n              [keyId]: deviceId\n            }\n          }, deviceId), keyInfo);\n          verifiedDevices.push(deviceId);\n        } else {\n          _logger.logger.warn(`verification: Could not find device ${deviceId} to verify`);\n        }\n      }\n    } // if none of the keys could be verified, then error because the app\n    // should be informed about that\n\n\n    if (!verifiedDevices.length) {\n      throw new Error(\"No devices could be verified\");\n    }\n\n    for (const deviceId of verifiedDevices) {\n      await this._baseApis.setDeviceVerified(userId, deviceId);\n    }\n  }\n\n}\n\nexports.VerificationBase = VerificationBase;"]},"metadata":{},"sourceType":"script"}