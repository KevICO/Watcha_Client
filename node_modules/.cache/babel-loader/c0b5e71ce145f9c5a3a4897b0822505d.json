{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isCryptoAvailable = isCryptoAvailable;\nexports.Crypto = Crypto;\nexports.verificationMethods = void 0;\n\nvar _anotherJson = _interopRequireDefault(require(\"another-json\"));\n\nvar _events = require(\"events\");\n\nvar _ReEmitter = require(\"../ReEmitter\");\n\nvar _logger = require(\"../logger\");\n\nvar utils = _interopRequireWildcard(require(\"../utils\"));\n\nvar _OlmDevice = require(\"./OlmDevice\");\n\nvar olmlib = _interopRequireWildcard(require(\"./olmlib\"));\n\nvar _DeviceList = require(\"./DeviceList\");\n\nvar _deviceinfo = require(\"./deviceinfo\");\n\nvar algorithms = _interopRequireWildcard(require(\"./algorithms\"));\n\nvar _CrossSigning = require(\"./CrossSigning\");\n\nvar _SecretStorage = require(\"./SecretStorage\");\n\nvar _OutgoingRoomKeyRequestManager = require(\"./OutgoingRoomKeyRequestManager\");\n\nvar _indexeddbCryptoStore = require(\"./store/indexeddb-crypto-store\");\n\nvar _QRCode = require(\"./verification/QRCode\");\n\nvar _SAS = require(\"./verification/SAS\");\n\nvar _key_passphrase = require(\"./key_passphrase\");\n\nvar _recoverykey = require(\"./recoverykey\");\n\nvar _VerificationRequest = require(\"./verification/request/VerificationRequest\");\n\nvar _InRoomChannel = require(\"./verification/request/InRoomChannel\");\n\nvar _ToDeviceChannel = require(\"./verification/request/ToDeviceChannel\");\n\nvar httpApi = _interopRequireWildcard(require(\"../http-api\"));\n/*\nCopyright 2016 OpenMarket Ltd\nCopyright 2017 Vector Creations Ltd\nCopyright 2018-2019 New Vector Ltd\nCopyright 2019-2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * @module crypto\n */\n\n\nconst DeviceVerification = _deviceinfo.DeviceInfo.DeviceVerification;\nconst defaultVerificationMethods = {\n  [_QRCode.ScanQRCode.NAME]: _QRCode.ScanQRCode,\n  [_QRCode.ShowQRCode.NAME]: _QRCode.ShowQRCode,\n  [_SAS.SAS.NAME]: _SAS.SAS\n};\n/**\n * verification method names\n */\n\nconst verificationMethods = {\n  QR_CODE_SCAN: _QRCode.ScanQRCode.NAME,\n  QR_CODE_SHOW: _QRCode.ShowQRCode.NAME,\n  SAS: _SAS.SAS.NAME\n};\nexports.verificationMethods = verificationMethods;\n\nfunction isCryptoAvailable() {\n  return Boolean(global.Olm);\n}\n\nconst MIN_FORCE_SESSION_INTERVAL_MS = 60 * 60 * 1000;\nconst KEY_BACKUP_KEYS_PER_REQUEST = 200;\n/**\n * Cryptography bits\n *\n * This module is internal to the js-sdk; the public API is via MatrixClient.\n *\n * @constructor\n * @alias module:crypto\n *\n * @internal\n *\n * @param {module:base-apis~MatrixBaseApis} baseApis base matrix api interface\n *\n * @param {module:store/session/webstorage~WebStorageSessionStore} sessionStore\n *    Store to be used for end-to-end crypto session data\n *\n * @param {string} userId The user ID for the local user\n *\n * @param {string} deviceId The identifier for this device.\n *\n * @param {Object} clientStore the MatrixClient data store.\n *\n * @param {module:crypto/store/base~CryptoStore} cryptoStore\n *    storage for the crypto layer.\n *\n * @param {RoomList} roomList An initialised RoomList object\n *\n * @param {Array} verificationMethods Array of verification methods to use.\n *    Each element can either be a string from MatrixClient.verificationMethods\n *    or a class that implements a verification method.\n */\n\nfunction Crypto(baseApis, sessionStore, userId, deviceId, clientStore, cryptoStore, roomList, verificationMethods) {\n  this._onDeviceListUserCrossSigningUpdated = this._onDeviceListUserCrossSigningUpdated.bind(this);\n  this._reEmitter = new _ReEmitter.ReEmitter(this);\n  this._baseApis = baseApis;\n  this._sessionStore = sessionStore;\n  this._userId = userId;\n  this._deviceId = deviceId;\n  this._clientStore = clientStore;\n  this._cryptoStore = cryptoStore;\n  this._roomList = roomList;\n  this._verificationMethods = new Map();\n\n  if (verificationMethods) {\n    for (const method of verificationMethods) {\n      if (typeof method === \"string\") {\n        if (defaultVerificationMethods[method]) {\n          this._verificationMethods.set(method, defaultVerificationMethods[method]);\n        }\n      } else if (method.NAME) {\n        this._verificationMethods.set(method.NAME, method);\n      }\n    }\n  } // track whether this device's megolm keys are being backed up incrementally\n  // to the server or not.\n  // XXX: this should probably have a single source of truth from OlmAccount\n\n\n  this.backupInfo = null; // The info dict from /room_keys/version\n\n  this.backupKey = null; // The encryption key object\n\n  this._checkedForBackup = false; // Have we checked the server for a backup we can use?\n\n  this._sendingBackups = false; // Are we currently sending backups?\n\n  this._olmDevice = new _OlmDevice.OlmDevice(cryptoStore);\n  this._deviceList = new _DeviceList.DeviceList(baseApis, cryptoStore, this._olmDevice); // XXX: This isn't removed at any point, but then none of the event listeners\n  // this class sets seem to be removed at any point... :/\n\n  this._deviceList.on('userCrossSigningUpdated', this._onDeviceListUserCrossSigningUpdated);\n\n  this._reEmitter.reEmit(this._deviceList, [\"crypto.devicesUpdated\"]); // the last time we did a check for the number of one-time-keys on the\n  // server.\n\n\n  this._lastOneTimeKeyCheck = null;\n  this._oneTimeKeyCheckInProgress = false; // EncryptionAlgorithm instance for each room\n\n  this._roomEncryptors = {}; // map from algorithm to DecryptionAlgorithm instance, for each room\n\n  this._roomDecryptors = {};\n  this._supportedAlgorithms = utils.keys(algorithms.DECRYPTION_CLASSES);\n  this._deviceKeys = {};\n  this._globalBlacklistUnverifiedDevices = false;\n  this._globalErrorOnUnknownDevices = true;\n  this._outgoingRoomKeyRequestManager = new _OutgoingRoomKeyRequestManager.OutgoingRoomKeyRequestManager(baseApis, this._deviceId, this._cryptoStore); // list of IncomingRoomKeyRequests/IncomingRoomKeyRequestCancellations\n  // we received in the current sync.\n\n  this._receivedRoomKeyRequests = [];\n  this._receivedRoomKeyRequestCancellations = []; // true if we are currently processing received room key requests\n\n  this._processingRoomKeyRequests = false; // controls whether device tracking is delayed\n  // until calling encryptEvent or trackRoomDevices,\n  // or done immediately upon enabling room encryption.\n\n  this._lazyLoadMembers = false; // in case _lazyLoadMembers is true,\n  // track if an initial tracking of all the room members\n  // has happened for a given room. This is delayed\n  // to avoid loading room members as long as possible.\n\n  this._roomDeviceTrackingState = {}; // The timestamp of the last time we forced establishment\n  // of a new session for each device, in milliseconds.\n  // {\n  //     userId: {\n  //         deviceId: 1234567890000,\n  //     },\n  // }\n\n  this._lastNewSessionForced = {};\n  this._toDeviceVerificationRequests = new Map();\n  this._inRoomVerificationRequests = new Map();\n  const cryptoCallbacks = this._baseApis._cryptoCallbacks || {};\n  this._crossSigningInfo = new _CrossSigning.CrossSigningInfo(userId, cryptoCallbacks);\n  this._secretStorage = new _SecretStorage.SecretStorage(baseApis, cryptoCallbacks, this._crossSigningInfo); // Assuming no app-supplied callback, default to getting from SSSS.\n\n  if (!cryptoCallbacks.getCrossSigningKey && cryptoCallbacks.getSecretStorageKey) {\n    cryptoCallbacks.getCrossSigningKey = async type => {\n      return _CrossSigning.CrossSigningInfo.getFromSecretStorage(type, this._secretStorage);\n    };\n  }\n}\n\nutils.inherits(Crypto, _events.EventEmitter);\n/**\n * Initialise the crypto module so that it is ready for use\n *\n * Returns a promise which resolves once the crypto module is ready for use.\n */\n\nCrypto.prototype.init = async function () {\n  _logger.logger.log(\"Crypto: initialising Olm...\");\n\n  await global.Olm.init();\n\n  _logger.logger.log(\"Crypto: initialising Olm device...\");\n\n  await this._olmDevice.init();\n\n  _logger.logger.log(\"Crypto: loading device list...\");\n\n  await this._deviceList.load(); // build our device keys: these will later be uploaded\n\n  this._deviceKeys[\"ed25519:\" + this._deviceId] = this._olmDevice.deviceEd25519Key;\n  this._deviceKeys[\"curve25519:\" + this._deviceId] = this._olmDevice.deviceCurve25519Key;\n\n  _logger.logger.log(\"Crypto: fetching own devices...\");\n\n  let myDevices = this._deviceList.getRawStoredDevicesForUser(this._userId);\n\n  if (!myDevices) {\n    myDevices = {};\n  }\n\n  if (!myDevices[this._deviceId]) {\n    // add our own deviceinfo to the cryptoStore\n    _logger.logger.log(\"Crypto: adding this device to the store...\");\n\n    const deviceInfo = {\n      keys: this._deviceKeys,\n      algorithms: this._supportedAlgorithms,\n      verified: DeviceVerification.VERIFIED,\n      known: true\n    };\n    myDevices[this._deviceId] = deviceInfo;\n\n    this._deviceList.storeDevicesForUser(this._userId, myDevices);\n\n    this._deviceList.saveIfDirty();\n  }\n\n  await this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], txn => {\n    this._cryptoStore.getCrossSigningKeys(txn, keys => {\n      if (keys) {\n        _logger.logger.log(\"Loaded cross-signing public keys from crypto store\");\n\n        this._crossSigningInfo.setKeys(keys);\n      }\n    });\n  }); // make sure we are keeping track of our own devices\n  // (this is important for key backups & things)\n\n  this._deviceList.startTrackingDeviceList(this._userId);\n\n  _logger.logger.log(\"Crypto: checking for key backup...\");\n\n  this._checkAndStartKeyBackup();\n};\n/**\n * Create a recovery key from a user-supplied passphrase.\n *\n * @param {string} password Passphrase string that can be entered by the user\n *     when restoring the backup as an alternative to entering the recovery key.\n *     Optional.\n * @returns {Promise<Array>} Array with public key metadata, encoded private\n *     recovery key which should be disposed of after displaying to the user,\n *     and raw private key to avoid round tripping if needed.\n */\n\n\nCrypto.prototype.createRecoveryKeyFromPassphrase = async function (password) {\n  const decryption = new global.Olm.PkDecryption();\n\n  try {\n    const keyInfo = {};\n\n    if (password) {\n      const derivation = await (0, _key_passphrase.keyFromPassphrase)(password);\n      keyInfo.passphrase = {\n        algorithm: \"m.pbkdf2\",\n        iterations: derivation.iterations,\n        salt: derivation.salt\n      };\n      keyInfo.pubkey = decryption.init_with_private_key(derivation.key);\n    } else {\n      keyInfo.pubkey = decryption.generate_key();\n    }\n\n    const privateKey = decryption.get_private_key();\n    const encodedPrivateKey = (0, _recoverykey.encodeRecoveryKey)(privateKey);\n    return [keyInfo, encodedPrivateKey, privateKey];\n  } finally {\n    if (decryption) decryption.free();\n  }\n};\n/**\n * Bootstrap Secure Secret Storage if needed by creating a default key and\n * signing it with the cross-signing master key. If everything is already set\n * up, then no changes are made, so this is safe to run to ensure secret storage\n * is ready for use.\n *\n * @param {function} [opts.authUploadDeviceSigningKeys] Optional. Function\n * called to await an interactive auth flow when uploading device signing keys.\n * Args:\n *     {function} A function that makes the request requiring auth. Receives the\n *     auth data as an object.\n * @param {function} [opts.createSecretStorageKey] Optional. Function\n * called to await a secret storage key creation flow.\n * @param {object} [opts.keyBackupInfo] The current key backup object. If passed,\n * the passphrase and recovery key from this backup will be used.\n * Returns:\n *     {Promise} A promise which resolves to key creation data for\n *     SecretStorage#addKey: an object with `passphrase` and/or `pubkey` fields.\n */\n\n\nCrypto.prototype.bootstrapSecretStorage = async function ({\n  authUploadDeviceSigningKeys,\n  createSecretStorageKey = async () => {},\n  keyBackupInfo\n} = {}) {\n  _logger.logger.log(\"Bootstrapping Secure Secret Storage\"); // Create cross-signing keys if they don't exist, as we want to sign the SSSS default\n  // key with the cross-signing master key. The cross-signing master key is also used\n  // to verify the signature on the SSSS default key when adding secrets, so we\n  // effectively need it for both reading and writing secrets.\n\n\n  let crossSigningPrivateKeys = {}; // If we happen to reset cross-signing keys here, then we want access to the\n  // cross-signing private keys, but only for the scope of this method, so we\n  // use temporary callbacks to weave them through the various APIs.\n\n  const appCallbacks = Object.assign({}, this._baseApis._cryptoCallbacks);\n\n  try {\n    const inStorage = await this._crossSigningInfo.isStoredInSecretStorage(this._secretStorage);\n\n    if (!this._crossSigningInfo.getId() || !inStorage) {\n      _logger.logger.log(\"Cross-signing public and/or private keys not found, \" + \"checking secret storage for private keys\");\n\n      if (inStorage) {\n        _logger.logger.log(\"Cross-signing private keys found in secret storage\");\n\n        await this.checkOwnCrossSigningTrust();\n      } else {\n        _logger.logger.log(\"Cross-signing private keys not found in secret storage, \" + \"creating new keys\");\n\n        this._baseApis._cryptoCallbacks.saveCrossSigningKeys = keys => crossSigningPrivateKeys = keys;\n\n        this._baseApis._cryptoCallbacks.getCrossSigningKey = name => crossSigningPrivateKeys[name];\n\n        await this.resetCrossSigningKeys(_CrossSigning.CrossSigningLevel.MASTER, {\n          authUploadDeviceSigningKeys\n        });\n      }\n    } else {\n      _logger.logger.log(\"Cross signing keys are present in secret storage\");\n    } // Check if Secure Secret Storage has a default key. If we don't have one, create\n    // the default key (which will also be signed by the cross-signing master key).\n\n\n    if (!(await this.hasSecretStorageKey())) {\n      let newKeyId;\n\n      if (keyBackupInfo) {\n        _logger.logger.log(\"Secret storage default key not found, using key backup key\");\n\n        const opts = {\n          pubkey: keyBackupInfo.auth_data.public_key\n        };\n\n        if (keyBackupInfo.auth_data.private_key_salt && keyBackupInfo.auth_data.private_key_iterations) {\n          opts.passphrase = {\n            algorithm: \"m.pbkdf2\",\n            iterations: keyBackupInfo.auth_data.private_key_iterations,\n            salt: keyBackupInfo.auth_data.private_key_salt\n          };\n        }\n\n        newKeyId = await this.addSecretStorageKey(_SecretStorage.SECRET_STORAGE_ALGORITHM_V1, opts); // Add an entry for the backup key in SSSS as a 'passthrough' key\n        // (ie. the secret is the key itself).\n\n        this._secretStorage.storePassthrough('m.megolm_backup.v1', newKeyId); // if this key backup is trusted, sign it with the cross signing key\n        // so the key backup can be trusted via cross-signing.\n\n\n        const backupSigStatus = await this.checkKeyBackup(keyBackupInfo);\n\n        if (backupSigStatus.trustInfo.usable) {\n          console.log(\"Adding cross signing signature to key backup\");\n          await this._crossSigningInfo.signObject(keyBackupInfo.auth_data, \"master\");\n          await this._baseApis._http.authedRequest(undefined, \"PUT\", \"/room_keys/version/\" + keyBackupInfo.version, undefined, keyBackupInfo, {\n            prefix: httpApi.PREFIX_UNSTABLE\n          });\n        } else {\n          console.log(\"Key backup is NOT TRUSTED: NOT adding cross signing signature\");\n        }\n      } else {\n        _logger.logger.log(\"Secret storage default key not found, creating new key\");\n\n        const keyOptions = await createSecretStorageKey();\n        newKeyId = await this.addSecretStorageKey(_SecretStorage.SECRET_STORAGE_ALGORITHM_V1, keyOptions);\n      }\n\n      await this.setDefaultSecretStorageKeyId(newKeyId);\n    } else {\n      _logger.logger.log(\"Have secret storage key\");\n    } // If cross-signing keys were reset, store them in Secure Secret Storage.\n    // This is done in a separate step so we can ensure secret storage has its\n    // own key first.\n    // XXX: We need to think about how to re-do these steps if they fail.\n    // See also https://github.com/vector-im/riot-web/issues/11635\n\n\n    if (Object.keys(crossSigningPrivateKeys).length) {\n      _logger.logger.log(\"Storing cross-signing private keys in secret storage\"); // SSSS expects its keys to be signed by cross-signing master key.\n      // Since we have just reset cross-signing keys, we need to re-sign the\n      // SSSS default key with the new cross-signing master key so that the\n      // following storage step can proceed.\n\n\n      await this._secretStorage.signKey(); // Assuming no app-supplied callback, default to storing in SSSS.\n\n      if (!appCallbacks.saveCrossSigningKeys) {\n        await _CrossSigning.CrossSigningInfo.storeInSecretStorage(crossSigningPrivateKeys, this._secretStorage);\n      }\n    }\n  } finally {\n    this._baseApis._cryptoCallbacks = appCallbacks;\n  }\n\n  _logger.logger.log(\"Secure Secret Storage ready\");\n};\n\nCrypto.prototype.addSecretStorageKey = function (algorithm, opts, keyID) {\n  return this._secretStorage.addKey(algorithm, opts, keyID);\n};\n\nCrypto.prototype.hasSecretStorageKey = function (keyID) {\n  return this._secretStorage.hasKey(keyID);\n};\n\nCrypto.prototype.storeSecret = function (name, secret, keys) {\n  return this._secretStorage.store(name, secret, keys);\n};\n\nCrypto.prototype.getSecret = function (name) {\n  return this._secretStorage.get(name);\n};\n\nCrypto.prototype.isSecretStored = function (name, checkKey) {\n  return this._secretStorage.isStored(name, checkKey);\n};\n\nCrypto.prototype.requestSecret = function (name, devices) {\n  if (!devices) {\n    devices = Object.keys(this._deviceList.getRawStoredDevicesForUser(this._userId));\n  }\n\n  return this._secretStorage.request(name, devices);\n};\n\nCrypto.prototype.getDefaultSecretStorageKeyId = function () {\n  return this._secretStorage.getDefaultKeyId();\n};\n\nCrypto.prototype.setDefaultSecretStorageKeyId = function (k) {\n  return this._secretStorage.setDefaultKeyId(k);\n};\n/**\n * Checks that a given secret storage private key matches a given public key.\n * This can be used by the getSecretStorageKey callback to verify that the\n * private key it is about to supply is the one that was requested.\n *\n * @param {Uint8Array} privateKey The private key\n * @param {string} expectedPublicKey The public key\n * @returns {boolean} true if the key matches, otherwise false\n */\n\n\nCrypto.prototype.checkSecretStoragePrivateKey = function (privateKey, expectedPublicKey) {\n  let decryption = null;\n\n  try {\n    decryption = new global.Olm.PkDecryption();\n    const gotPubkey = decryption.init_with_private_key(privateKey); // make sure it agrees with the given pubkey\n\n    return gotPubkey === expectedPublicKey;\n  } finally {\n    if (decryption) decryption.free();\n  }\n};\n/**\n * Checks that a given cross-signing private key matches a given public key.\n * This can be used by the getCrossSigningKey callback to verify that the\n * private key it is about to supply is the one that was requested.\n *\n * @param {Uint8Array} privateKey The private key\n * @param {string} expectedPublicKey The public key\n * @returns {boolean} true if the key matches, otherwise false\n */\n\n\nCrypto.prototype.checkCrossSigningPrivateKey = function (privateKey, expectedPublicKey) {\n  let signing = null;\n\n  try {\n    signing = new global.Olm.PkSigning();\n    const gotPubkey = signing.init_with_seed(privateKey); // make sure it agrees with the given pubkey\n\n    return gotPubkey === expectedPublicKey;\n  } finally {\n    if (signing) signing.free();\n  }\n};\n/**\n * Generate new cross-signing keys.\n *\n * @param {CrossSigningLevel} [level] the level of cross-signing to reset.  New\n * keys will be created for the given level and below.  Defaults to\n * regenerating all keys.\n * @param {function} [opts.authUploadDeviceSigningKeys] Optional. Function\n * called to await an interactive auth flow when uploading device signing keys.\n * Args:\n *     {function} A function that makes the request requiring auth. Receives the\n *     auth data as an object.\n */\n\n\nCrypto.prototype.resetCrossSigningKeys = async function (level, {\n  authUploadDeviceSigningKeys = async func => await func()\n} = {}) {\n  _logger.logger.info(`Resetting cross-signing keys at level ${level}`); // Copy old keys (usually empty) in case we need to revert\n\n\n  const oldKeys = Object.assign({}, this._crossSigningInfo.keys);\n\n  try {\n    await this._crossSigningInfo.resetKeys(level);\n    await this._signObject(this._crossSigningInfo.keys.master); // send keys to server first before storing as trusted locally\n    // to ensure upload succeeds\n\n    const keys = {};\n\n    for (const [name, key] of Object.entries(this._crossSigningInfo.keys)) {\n      keys[name + \"_key\"] = key;\n    }\n\n    await authUploadDeviceSigningKeys(async authDict => {\n      await this._baseApis.uploadDeviceSigningKeys(authDict, keys);\n    }); // write a copy locally so we know these are trusted keys\n\n    await this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], txn => {\n      this._cryptoStore.storeCrossSigningKeys(txn, this._crossSigningInfo.keys);\n    });\n  } catch (e) {\n    // If anything failed here, revert the keys so we know to try again from the start\n    // next time.\n    _logger.logger.error(\"Resetting cross-signing keys failed, revert to previous keys\", e);\n\n    this._crossSigningInfo.keys = oldKeys;\n    throw e;\n  }\n\n  this._baseApis.emit(\"crossSigning.keysChanged\", {});\n\n  await this._afterCrossSigningLocalKeyChange();\n\n  _logger.logger.info(\"Cross-signing key reset complete\");\n};\n/**\n * Run various follow-up actions after cross-signing keys have changed locally\n * (either by resetting the keys for the account or by getting them from secret\n * storage), such as signing the current device, upgrading device\n * verifications, etc.\n */\n\n\nCrypto.prototype._afterCrossSigningLocalKeyChange = async function () {\n  // sign the current device with the new key, and upload to the server\n  const device = this._deviceList.getStoredDevice(this._userId, this._deviceId);\n\n  const signedDevice = await this._crossSigningInfo.signDevice(this._userId, device);\n  await this._baseApis.uploadKeySignatures({\n    [this._userId]: {\n      [this._deviceId]: signedDevice\n    }\n  }); // check all users for signatures\n  // FIXME: do this in batches\n\n  const users = {};\n\n  for (const [userId, crossSigningInfo] of Object.entries(this._deviceList._crossSigningInfo)) {\n    const upgradeInfo = await this._checkForDeviceVerificationUpgrade(userId, _CrossSigning.CrossSigningInfo.fromStorage(crossSigningInfo, userId));\n\n    if (upgradeInfo) {\n      users[userId] = upgradeInfo;\n    }\n  }\n\n  const shouldUpgradeCb = this._baseApis._cryptoCallbacks.shouldUpgradeDeviceVerifications;\n\n  if (Object.keys(users).length > 0 && shouldUpgradeCb) {\n    try {\n      const usersToUpgrade = await shouldUpgradeCb({\n        users: users\n      });\n\n      if (usersToUpgrade) {\n        for (const userId of usersToUpgrade) {\n          if (userId in users) {\n            await this._baseApis.setDeviceVerified(userId, users[userId].crossSigningInfo.getId());\n          }\n        }\n      }\n    } catch (e) {\n      _logger.logger.log(\"shouldUpgradeDeviceVerifications threw an error: not upgrading\", e);\n    }\n  }\n};\n/**\n * Check if a user's cross-signing key is a candidate for upgrading from device\n * verification.\n *\n * @param {string} userId the user whose cross-signing information is to be checked\n * @param {object} crossSigningInfo the cross-signing information to check\n */\n\n\nCrypto.prototype._checkForDeviceVerificationUpgrade = async function (userId, crossSigningInfo) {\n  // only upgrade if this is the first cross-signing key that we've seen for\n  // them, and if their cross-signing key isn't already verified\n  const trustLevel = this._crossSigningInfo.checkUserTrust(crossSigningInfo);\n\n  if (crossSigningInfo.firstUse && !trustLevel.verified) {\n    const devices = this._deviceList.getRawStoredDevicesForUser(userId);\n\n    const deviceIds = await this._checkForValidDeviceSignature(userId, crossSigningInfo.keys.master, devices);\n\n    if (deviceIds.length) {\n      return {\n        devices: deviceIds.map(deviceId => _deviceinfo.DeviceInfo.fromStorage(devices[deviceId], deviceId)),\n        crossSigningInfo\n      };\n    }\n  }\n};\n/**\n * Check if the cross-signing key is signed by a verified device.\n *\n * @param {string} userId the user ID whose key is being checked\n * @param {object} key the key that is being checked\n * @param {object} devices the user's devices.  Should be a map from device ID\n *     to device info\n */\n\n\nCrypto.prototype._checkForValidDeviceSignature = async function (userId, key, devices) {\n  const deviceIds = [];\n\n  if (devices && key.signatures && key.signatures[userId]) {\n    for (const signame of Object.keys(key.signatures[userId])) {\n      const [, deviceId] = signame.split(':', 2);\n\n      if (deviceId in devices && devices[deviceId].verified === DeviceVerification.VERIFIED) {\n        try {\n          await olmlib.verifySignature(this._olmDevice, key, userId, deviceId, devices[deviceId].keys[signame]);\n          deviceIds.push(deviceId);\n        } catch (e) {}\n      }\n    }\n  }\n\n  return deviceIds;\n};\n/**\n * Get the user's cross-signing key ID.\n *\n * @param {string} [type=master] The type of key to get the ID of.  One of\n *     \"master\", \"self_signing\", or \"user_signing\".  Defaults to \"master\".\n *\n * @returns {string} the key ID\n */\n\n\nCrypto.prototype.getCrossSigningId = function (type) {\n  return this._crossSigningInfo.getId(type);\n};\n/**\n * Get the cross signing information for a given user.\n *\n * @param {string} userId the user ID to get the cross-signing info for.\n *\n * @returns {CrossSigningInfo} the cross signing informmation for the user.\n */\n\n\nCrypto.prototype.getStoredCrossSigningForUser = function (userId) {\n  return this._deviceList.getStoredCrossSigningForUser(userId);\n};\n/**\n * Check whether a given user is trusted.\n *\n * @param {string} userId The ID of the user to check.\n *\n * @returns {UserTrustLevel}\n */\n\n\nCrypto.prototype.checkUserTrust = function (userId) {\n  const userCrossSigning = this._deviceList.getStoredCrossSigningForUser(userId);\n\n  if (!userCrossSigning) {\n    return new _CrossSigning.UserTrustLevel(false, false);\n  }\n\n  return this._crossSigningInfo.checkUserTrust(userCrossSigning);\n};\n/**\n * Check whether a given device is trusted.\n *\n * @param {string} userId The ID of the user whose devices is to be checked.\n * @param {string} deviceId The ID of the device to check\n *\n * @returns {DeviceTrustLevel}\n */\n\n\nCrypto.prototype.checkDeviceTrust = function (userId, deviceId) {\n  const device = this._deviceList.getStoredDevice(userId, deviceId);\n\n  const trustedLocally = device && device.isVerified();\n\n  const userCrossSigning = this._deviceList.getStoredCrossSigningForUser(userId);\n\n  if (device && userCrossSigning) {\n    return this._crossSigningInfo.checkDeviceTrust(userCrossSigning, device, trustedLocally);\n  } else {\n    return new _CrossSigning.DeviceTrustLevel(false, false, trustedLocally);\n  }\n};\n/*\n * Event handler for DeviceList's userNewDevices event\n */\n\n\nCrypto.prototype._onDeviceListUserCrossSigningUpdated = async function (userId) {\n  if (userId === this._userId) {\n    // An update to our own cross-signing key.\n    // Get the new key first:\n    const newCrossSigning = this._deviceList.getStoredCrossSigningForUser(userId);\n\n    const seenPubkey = newCrossSigning ? newCrossSigning.getId() : null;\n\n    const currentPubkey = this._crossSigningInfo.getId();\n\n    const changed = currentPubkey !== seenPubkey;\n\n    if (currentPubkey && seenPubkey && !changed) {\n      // If it's not changed, just make sure everything is up to date\n      await this.checkOwnCrossSigningTrust();\n    } else {\n      this.emit(\"crossSigning.keysChanged\", {}); // We'll now be in a state where cross-signing on the account is not trusted\n      // because our locally stored cross-signing keys will not match the ones\n      // on the server for our account. The app must call checkOwnCrossSigningTrust()\n      // to fix this.\n      // XXX: Do we need to do something to emit events saying every device has become\n      // untrusted?\n    }\n  } else {\n    await this._checkDeviceVerifications(userId);\n    this.emit(\"userTrustStatusChanged\", userId, this.checkUserTrust(userId));\n  }\n};\n/**\n * Check the copy of our cross-signing key that we have in the device list and\n * see if we can get the private key. If so, mark it as trusted.\n */\n\n\nCrypto.prototype.checkOwnCrossSigningTrust = async function () {\n  const userId = this._userId; // If we see an update to our own master key, check it against the master\n  // key we have and, if it matches, mark it as verified\n  // First, get the new cross-signing info\n\n  const newCrossSigning = this._deviceList.getStoredCrossSigningForUser(userId);\n\n  if (!newCrossSigning) {\n    _logger.logger.error(\"Got cross-signing update event for user \" + userId + \" but no new cross-signing information found!\");\n\n    return;\n  }\n\n  const seenPubkey = newCrossSigning.getId();\n  const masterChanged = this._crossSigningInfo.getId() !== seenPubkey;\n\n  if (masterChanged) {\n    // try to get the private key if the master key changed\n    _logger.logger.info(\"Got new master public key\", seenPubkey);\n\n    let signing = null;\n\n    try {\n      const ret = await this._crossSigningInfo.getCrossSigningKey('master', seenPubkey);\n      signing = ret[1];\n\n      if (!signing) {\n        throw new Error(\"Cross-signing master private key not available\");\n      }\n    } finally {\n      if (signing) signing.free();\n    }\n\n    _logger.logger.info(\"Got matching private key from callback for new public master key\");\n  }\n\n  const oldSelfSigningId = this._crossSigningInfo.getId(\"self_signing\");\n\n  const oldUserSigningId = this._crossSigningInfo.getId(\"user_signing\"); // Update the version of our keys in our cross-signing object and the local store\n\n\n  this._crossSigningInfo.setKeys(newCrossSigning.keys);\n\n  await this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], txn => {\n    this._cryptoStore.storeCrossSigningKeys(txn, this._crossSigningInfo.keys);\n  });\n  const keySignatures = {};\n\n  if (oldSelfSigningId !== newCrossSigning.getId(\"self_signing\")) {\n    _logger.logger.info(\"Got new self-signing key\", newCrossSigning.getId(\"self_signing\"));\n\n    const device = this._deviceList.getStoredDevice(this._userId, this._deviceId);\n\n    const signedDevice = await this._crossSigningInfo.signDevice(this._userId, device);\n    keySignatures[this._deviceId] = signedDevice;\n  }\n\n  if (oldUserSigningId !== newCrossSigning.getId(\"user_signing\")) {\n    _logger.logger.info(\"Got new user-signing key\", newCrossSigning.getId(\"user_signing\"));\n  }\n\n  if (masterChanged) {\n    await this._signObject(this._crossSigningInfo.keys.master);\n    keySignatures[this._crossSigningInfo.getId()] = this._crossSigningInfo.keys.master;\n  }\n\n  if (Object.keys(keySignatures).length) {\n    await this._baseApis.uploadKeySignatures({\n      [this._userId]: keySignatures\n    });\n  }\n\n  this.emit(\"userTrustStatusChanged\", userId, this.checkUserTrust(userId));\n\n  if (masterChanged) {\n    this._baseApis.emit(\"crossSigning.keysChanged\", {});\n\n    await this._afterCrossSigningLocalKeyChange();\n  } // Now we may be able to trust our key backup\n\n\n  await this.checkKeyBackup(); // FIXME: if we previously trusted the backup, should we automatically sign\n  // the backup with the new key (if not already signed)?\n};\n/**\n * Check if the master key is signed by a verified device, and if so, prompt\n * the application to mark it as verified.\n *\n * @param {string} userId the user ID whose key should be checked\n */\n\n\nCrypto.prototype._checkDeviceVerifications = async function (userId) {\n  if (this._crossSigningInfo.keys.user_signing) {\n    const crossSigningInfo = this._deviceList.getStoredCrossSigningForUser(userId);\n\n    if (crossSigningInfo) {\n      const upgradeInfo = await this._checkForDeviceVerificationUpgrade(userId, crossSigningInfo);\n      const shouldUpgradeCb = this._baseApis._cryptoCallbacks.shouldUpgradeDeviceVerifications;\n\n      if (upgradeInfo && shouldUpgradeCb) {\n        const usersToUpgrade = await shouldUpgradeCb({\n          users: {\n            [userId]: upgradeInfo\n          }\n        });\n\n        if (usersToUpgrade.includes(userId)) {\n          await this._baseApis.setDeviceVerified(userId, crossSigningInfo.getId());\n        }\n      }\n    }\n  }\n};\n/**\n * Check the server for an active key backup and\n * if one is present and has a valid signature from\n * one of the user's verified devices, start backing up\n * to it.\n */\n\n\nCrypto.prototype._checkAndStartKeyBackup = async function () {\n  _logger.logger.log(\"Checking key backup status...\");\n\n  if (this._baseApis.isGuest()) {\n    _logger.logger.log(\"Skipping key backup check since user is guest\");\n\n    this._checkedForBackup = true;\n    return null;\n  }\n\n  let backupInfo;\n\n  try {\n    backupInfo = await this._baseApis.getKeyBackupVersion();\n  } catch (e) {\n    _logger.logger.log(\"Error checking for active key backup\", e);\n\n    if (e.httpStatus / 100 === 4) {\n      // well that's told us. we won't try again.\n      this._checkedForBackup = true;\n    }\n\n    return null;\n  }\n\n  this._checkedForBackup = true;\n  const trustInfo = await this.isKeyBackupTrusted(backupInfo);\n\n  if (trustInfo.usable && !this.backupInfo) {\n    _logger.logger.log(\"Found usable key backup v\" + backupInfo.version + \": enabling key backups\");\n\n    this._baseApis.enableKeyBackup(backupInfo);\n  } else if (!trustInfo.usable && this.backupInfo) {\n    _logger.logger.log(\"No usable key backup: disabling key backup\");\n\n    this._baseApis.disableKeyBackup();\n  } else if (!trustInfo.usable && !this.backupInfo) {\n    _logger.logger.log(\"No usable key backup: not enabling key backup\");\n  } else if (trustInfo.usable && this.backupInfo) {\n    // may not be the same version: if not, we should switch\n    if (backupInfo.version !== this.backupInfo.version) {\n      _logger.logger.log(\"On backup version \" + this.backupInfo.version + \" but found \" + \"version \" + backupInfo.version + \": switching.\");\n\n      this._baseApis.disableKeyBackup();\n\n      this._baseApis.enableKeyBackup(backupInfo);\n    } else {\n      _logger.logger.log(\"Backup version \" + backupInfo.version + \" still current\");\n    }\n  }\n\n  return {\n    backupInfo,\n    trustInfo\n  };\n};\n\nCrypto.prototype.setTrustedBackupPubKey = async function (trustedPubKey) {\n  // This should be redundant post cross-signing is a thing, so just\n  // plonk it in localStorage for now.\n  this._sessionStore.setLocalTrustedBackupPubKey(trustedPubKey);\n\n  await this.checkKeyBackup();\n};\n/**\n * Forces a re-check of the key backup and enables/disables it\n * as appropriate.\n *\n * @return {Object} Object with backup info (as returned by\n *     getKeyBackupVersion) in backupInfo and\n *     trust information (as returned by isKeyBackupTrusted)\n *     in trustInfo.\n */\n\n\nCrypto.prototype.checkKeyBackup = async function () {\n  this._checkedForBackup = false;\n  return this._checkAndStartKeyBackup();\n};\n/**\n * @param {object} backupInfo key backup info dict from /room_keys/version\n * @return {object} {\n *     usable: [bool], // is the backup trusted, true iff there is a sig that is valid & from a trusted device\n *     sigs: [\n *         valid: [bool || null], // true: valid, false: invalid, null: cannot attempt validation\n *         deviceId: [string],\n *         device: [DeviceInfo || null],\n *     ]\n * }\n */\n\n\nCrypto.prototype.isKeyBackupTrusted = async function (backupInfo) {\n  const ret = {\n    usable: false,\n    trusted_locally: false,\n    sigs: []\n  };\n\n  if (!backupInfo || !backupInfo.algorithm || !backupInfo.auth_data || !backupInfo.auth_data.public_key || !backupInfo.auth_data.signatures) {\n    _logger.logger.info(\"Key backup is absent or missing required data\");\n\n    return ret;\n  }\n\n  const trustedPubkey = this._sessionStore.getLocalTrustedBackupPubKey();\n\n  if (backupInfo.auth_data.public_key === trustedPubkey) {\n    _logger.logger.info(\"Backup public key \" + trustedPubkey + \" is trusted locally\");\n\n    ret.trusted_locally = true;\n  }\n\n  const mySigs = backupInfo.auth_data.signatures[this._userId] || [];\n\n  for (const keyId of Object.keys(mySigs)) {\n    const keyIdParts = keyId.split(':');\n\n    if (keyIdParts[0] !== 'ed25519') {\n      _logger.logger.log(\"Ignoring unknown signature type: \" + keyIdParts[0]);\n\n      continue;\n    } // Could be a cross-signing master key, but just say this is the device\n    // ID for backwards compat\n\n\n    const sigInfo = {\n      deviceId: keyIdParts[1]\n    }; // first check to see if it's from our cross-signing key\n\n    const crossSigningId = this._crossSigningInfo.getId();\n\n    if (crossSigningId === sigInfo.deviceId) {\n      sigInfo.crossSigningId = true;\n\n      try {\n        await olmlib.verifySignature(this._olmDevice, backupInfo.auth_data, this._userId, sigInfo.deviceId, crossSigningId);\n        sigInfo.valid = true;\n      } catch (e) {\n        _logger.logger.warning(\"Bad signature from cross signing key \" + crossSigningId, e);\n\n        sigInfo.valid = false;\n      }\n\n      ret.sigs.push(sigInfo);\n      continue;\n    } // Now look for a sig from a device\n    // At some point this can probably go away and we'll just support\n    // it being signed by the cross-signing master key\n\n\n    const device = this._deviceList.getStoredDevice(this._userId, sigInfo.deviceId);\n\n    if (device) {\n      sigInfo.device = device;\n      sigInfo.deviceTrust = await this.checkDeviceTrust(this._userId, sigInfo.deviceId);\n\n      try {\n        await olmlib.verifySignature(this._olmDevice, backupInfo.auth_data, this._userId, device.deviceId, device.getFingerprint());\n        sigInfo.valid = true;\n      } catch (e) {\n        _logger.logger.info(\"Bad signature from key ID \" + keyId + \" userID \" + this._userId + \" device ID \" + device.deviceId + \" fingerprint: \" + device.getFingerprint(), backupInfo.auth_data, e);\n\n        sigInfo.valid = false;\n      }\n    } else {\n      sigInfo.valid = null; // Can't determine validity because we don't have the signing device\n\n      _logger.logger.info(\"Ignoring signature from unknown key \" + keyId);\n    }\n\n    ret.sigs.push(sigInfo);\n  }\n\n  ret.usable = ret.sigs.some(s => {\n    return s.valid && (s.device && s.deviceTrust.isVerified() || s.crossSigningId);\n  });\n  ret.usable |= ret.trusted_locally;\n  return ret;\n};\n/**\n */\n\n\nCrypto.prototype.enableLazyLoading = function () {\n  this._lazyLoadMembers = true;\n};\n/**\n * Tell the crypto module to register for MatrixClient events which it needs to\n * listen for\n *\n * @param {external:EventEmitter} eventEmitter event source where we can register\n *    for event notifications\n */\n\n\nCrypto.prototype.registerEventHandlers = function (eventEmitter) {\n  const crypto = this;\n  eventEmitter.on(\"RoomMember.membership\", function (event, member, oldMembership) {\n    try {\n      crypto._onRoomMembership(event, member, oldMembership);\n    } catch (e) {\n      _logger.logger.error(\"Error handling membership change:\", e);\n    }\n  });\n  eventEmitter.on(\"toDeviceEvent\", function (event) {\n    crypto._onToDeviceEvent(event);\n  });\n  eventEmitter.on(\"Room.timeline\", function (event) {\n    crypto._onTimelineEvent(event);\n  });\n  eventEmitter.on(\"Event.decrypted\", function (event) {\n    crypto._onTimelineEvent(event);\n  });\n};\n/** Start background processes related to crypto */\n\n\nCrypto.prototype.start = function () {\n  this._outgoingRoomKeyRequestManager.start();\n};\n/** Stop background processes related to crypto */\n\n\nCrypto.prototype.stop = function () {\n  this._outgoingRoomKeyRequestManager.stop();\n\n  this._deviceList.stop();\n};\n/**\n * @return {string} The version of Olm.\n */\n\n\nCrypto.getOlmVersion = function () {\n  return _OlmDevice.OlmDevice.getOlmVersion();\n};\n/**\n * Get the Ed25519 key for this device\n *\n * @return {string} base64-encoded ed25519 key.\n */\n\n\nCrypto.prototype.getDeviceEd25519Key = function () {\n  return this._olmDevice.deviceEd25519Key;\n};\n/**\n * Set the global override for whether the client should ever send encrypted\n * messages to unverified devices.  This provides the default for rooms which\n * do not specify a value.\n *\n * @param {boolean} value whether to blacklist all unverified devices by default\n */\n\n\nCrypto.prototype.setGlobalBlacklistUnverifiedDevices = function (value) {\n  this._globalBlacklistUnverifiedDevices = value;\n};\n/**\n * @return {boolean} whether to blacklist all unverified devices by default\n */\n\n\nCrypto.prototype.getGlobalBlacklistUnverifiedDevices = function () {\n  return this._globalBlacklistUnverifiedDevices;\n};\n/**\n * Set whether sendMessage in a room with unknown and unverified devices\n * should throw an error and not send them message. This has 'Global' for\n * symmertry with setGlobalBlacklistUnverifiedDevices but there is currently\n * no room-level equivalent for this setting.\n *\n * This API is currently UNSTABLE and may change or be removed without notice.\n *\n * @param {boolean} value whether error on unknown devices\n */\n\n\nCrypto.prototype.setGlobalErrorOnUnknownDevices = function (value) {\n  this._globalErrorOnUnknownDevices = value;\n};\n/**\n * @return {boolean} whether to error on unknown devices\n *\n * This API is currently UNSTABLE and may change or be removed without notice.\n */\n\n\nCrypto.prototype.getGlobalErrorOnUnknownDevices = function () {\n  return this._globalErrorOnUnknownDevices;\n};\n/**\n * Upload the device keys to the homeserver.\n * @return {object} A promise that will resolve when the keys are uploaded.\n */\n\n\nCrypto.prototype.uploadDeviceKeys = function () {\n  const crypto = this;\n  const userId = crypto._userId;\n  const deviceId = crypto._deviceId;\n  const deviceKeys = {\n    algorithms: crypto._supportedAlgorithms,\n    device_id: deviceId,\n    keys: crypto._deviceKeys,\n    user_id: userId\n  };\n  return crypto._signObject(deviceKeys).then(() => {\n    return crypto._baseApis.uploadKeysRequest({\n      device_keys: deviceKeys\n    }, {\n      // for now, we set the device id explicitly, as we may not be using the\n      // same one as used in login.\n      device_id: deviceId\n    });\n  });\n};\n/**\n * Stores the current one_time_key count which will be handled later (in a call of\n * onSyncCompleted). The count is e.g. coming from a /sync response.\n *\n * @param {Number} currentCount The current count of one_time_keys to be stored\n */\n\n\nCrypto.prototype.updateOneTimeKeyCount = function (currentCount) {\n  if (isFinite(currentCount)) {\n    this._oneTimeKeyCount = currentCount;\n  } else {\n    throw new TypeError(\"Parameter for updateOneTimeKeyCount has to be a number\");\n  }\n}; // check if it's time to upload one-time keys, and do so if so.\n\n\nfunction _maybeUploadOneTimeKeys(crypto) {\n  // frequency with which to check & upload one-time keys\n  const uploadPeriod = 1000 * 60; // one minute\n  // max number of keys to upload at once\n  // Creating keys can be an expensive operation so we limit the\n  // number we generate in one go to avoid blocking the application\n  // for too long.\n\n  const maxKeysPerCycle = 5;\n\n  if (crypto._oneTimeKeyCheckInProgress) {\n    return;\n  }\n\n  const now = Date.now();\n\n  if (crypto._lastOneTimeKeyCheck !== null && now - crypto._lastOneTimeKeyCheck < uploadPeriod) {\n    // we've done a key upload recently.\n    return;\n  }\n\n  crypto._lastOneTimeKeyCheck = now; // We need to keep a pool of one time public keys on the server so that\n  // other devices can start conversations with us. But we can only store\n  // a finite number of private keys in the olm Account object.\n  // To complicate things further then can be a delay between a device\n  // claiming a public one time key from the server and it sending us a\n  // message. We need to keep the corresponding private key locally until\n  // we receive the message.\n  // But that message might never arrive leaving us stuck with duff\n  // private keys clogging up our local storage.\n  // So we need some kind of enginering compromise to balance all of\n  // these factors.\n  // Check how many keys we can store in the Account object.\n\n  const maxOneTimeKeys = crypto._olmDevice.maxNumberOfOneTimeKeys(); // Try to keep at most half that number on the server. This leaves the\n  // rest of the slots free to hold keys that have been claimed from the\n  // server but we haven't recevied a message for.\n  // If we run out of slots when generating new keys then olm will\n  // discard the oldest private keys first. This will eventually clean\n  // out stale private keys that won't receive a message.\n\n\n  const keyLimit = Math.floor(maxOneTimeKeys / 2);\n\n  function uploadLoop(keyCount) {\n    if (keyLimit <= keyCount) {\n      // If we don't need to generate any more keys then we are done.\n      return Promise.resolve();\n    }\n\n    const keysThisLoop = Math.min(keyLimit - keyCount, maxKeysPerCycle); // Ask olm to generate new one time keys, then upload them to synapse.\n\n    return crypto._olmDevice.generateOneTimeKeys(keysThisLoop).then(() => {\n      return _uploadOneTimeKeys(crypto);\n    }).then(res => {\n      if (res.one_time_key_counts && res.one_time_key_counts.signed_curve25519) {\n        // if the response contains a more up to date value use this\n        // for the next loop\n        return uploadLoop(res.one_time_key_counts.signed_curve25519);\n      } else {\n        throw new Error(\"response for uploading keys does not contain \" + \"one_time_key_counts.signed_curve25519\");\n      }\n    });\n  }\n\n  crypto._oneTimeKeyCheckInProgress = true;\n  Promise.resolve().then(() => {\n    if (crypto._oneTimeKeyCount !== undefined) {\n      // We already have the current one_time_key count from a /sync response.\n      // Use this value instead of asking the server for the current key count.\n      return Promise.resolve(crypto._oneTimeKeyCount);\n    } // ask the server how many keys we have\n\n\n    return crypto._baseApis.uploadKeysRequest({}, {\n      device_id: crypto._deviceId\n    }).then(res => {\n      return res.one_time_key_counts.signed_curve25519 || 0;\n    });\n  }).then(keyCount => {\n    // Start the uploadLoop with the current keyCount. The function checks if\n    // we need to upload new keys or not.\n    // If there are too many keys on the server then we don't need to\n    // create any more keys.\n    return uploadLoop(keyCount);\n  }).catch(e => {\n    _logger.logger.error(\"Error uploading one-time keys\", e.stack || e);\n  }).finally(() => {\n    // reset _oneTimeKeyCount to prevent start uploading based on old data.\n    // it will be set again on the next /sync-response\n    crypto._oneTimeKeyCount = undefined;\n    crypto._oneTimeKeyCheckInProgress = false;\n  });\n} // returns a promise which resolves to the response\n\n\nasync function _uploadOneTimeKeys(crypto) {\n  const oneTimeKeys = await crypto._olmDevice.getOneTimeKeys();\n  const oneTimeJson = {};\n  const promises = [];\n\n  for (const keyId in oneTimeKeys.curve25519) {\n    if (oneTimeKeys.curve25519.hasOwnProperty(keyId)) {\n      const k = {\n        key: oneTimeKeys.curve25519[keyId]\n      };\n      oneTimeJson[\"signed_curve25519:\" + keyId] = k;\n      promises.push(crypto._signObject(k));\n    }\n  }\n\n  await Promise.all(promises);\n  const res = await crypto._baseApis.uploadKeysRequest({\n    one_time_keys: oneTimeJson\n  }, {\n    // for now, we set the device id explicitly, as we may not be using the\n    // same one as used in login.\n    device_id: crypto._deviceId\n  });\n  await crypto._olmDevice.markKeysAsPublished();\n  return res;\n}\n/**\n * Download the keys for a list of users and stores the keys in the session\n * store.\n * @param {Array} userIds The users to fetch.\n * @param {bool} forceDownload Always download the keys even if cached.\n *\n * @return {Promise} A promise which resolves to a map userId->deviceId->{@link\n * module:crypto/deviceinfo|DeviceInfo}.\n */\n\n\nCrypto.prototype.downloadKeys = function (userIds, forceDownload) {\n  return this._deviceList.downloadKeys(userIds, forceDownload);\n};\n/**\n * Get the stored device keys for a user id\n *\n * @param {string} userId the user to list keys for.\n *\n * @return {module:crypto/deviceinfo[]|null} list of devices, or null if we haven't\n * managed to get a list of devices for this user yet.\n */\n\n\nCrypto.prototype.getStoredDevicesForUser = function (userId) {\n  return this._deviceList.getStoredDevicesForUser(userId);\n};\n/**\n * Get the stored keys for a single device\n *\n * @param {string} userId\n * @param {string} deviceId\n *\n * @return {module:crypto/deviceinfo?} device, or undefined\n * if we don't know about this device\n */\n\n\nCrypto.prototype.getStoredDevice = function (userId, deviceId) {\n  return this._deviceList.getStoredDevice(userId, deviceId);\n};\n/**\n * Save the device list, if necessary\n *\n * @param {integer} delay Time in ms before which the save actually happens.\n *     By default, the save is delayed for a short period in order to batch\n *     multiple writes, but this behaviour can be disabled by passing 0.\n *\n * @return {Promise<bool>} true if the data was saved, false if\n *     it was not (eg. because no changes were pending). The promise\n *     will only resolve once the data is saved, so may take some time\n *     to resolve.\n */\n\n\nCrypto.prototype.saveDeviceList = function (delay) {\n  return this._deviceList.saveIfDirty(delay);\n};\n/**\n * Update the blocked/verified state of the given device\n *\n * @param {string} userId owner of the device\n * @param {string} deviceId unique identifier for the device or user's\n * cross-signing public key ID.\n *\n * @param {?boolean} verified whether to mark the device as verified. Null to\n *     leave unchanged.\n *\n * @param {?boolean} blocked whether to mark the device as blocked. Null to\n *      leave unchanged.\n *\n * @param {?boolean} known whether to mark that the user has been made aware of\n *      the existence of this device. Null to leave unchanged\n *\n * @return {Promise<module:crypto/deviceinfo>} updated DeviceInfo\n */\n\n\nCrypto.prototype.setDeviceVerification = async function (userId, deviceId, verified, blocked, known) {\n  // get rid of any `undefined`s here so we can just check\n  // for null rather than null or undefined\n  if (verified === undefined) verified = null;\n  if (blocked === undefined) blocked = null;\n  if (known === undefined) known = null; // Check if the 'device' is actually a cross signing key\n  // The js-sdk's verification treats cross-signing keys as devices\n  // and so uses this method to mark them verified.\n\n  const xsk = this._deviceList.getStoredCrossSigningForUser(userId);\n\n  if (xsk && xsk.getId() === deviceId) {\n    if (blocked !== null || known !== null) {\n      throw new Error(\"Cannot set blocked or known for a cross-signing key\");\n    }\n\n    if (!verified) {\n      throw new Error(\"Cannot set a cross-signing key as unverified\");\n    }\n\n    const device = await this._crossSigningInfo.signUser(xsk);\n\n    if (device) {\n      await this._baseApis.uploadKeySignatures({\n        [userId]: {\n          [deviceId]: device\n        }\n      }); // This will emit events when it comes back down the sync\n      // (we could do local echo to speed things up)\n    }\n\n    return device;\n  }\n\n  const devices = this._deviceList.getRawStoredDevicesForUser(userId);\n\n  if (!devices || !devices[deviceId]) {\n    throw new Error(\"Unknown device \" + userId + \":\" + deviceId);\n  }\n\n  const dev = devices[deviceId];\n  let verificationStatus = dev.verified;\n\n  if (verified) {\n    verificationStatus = DeviceVerification.VERIFIED;\n  } else if (verified !== null && verificationStatus == DeviceVerification.VERIFIED) {\n    verificationStatus = DeviceVerification.UNVERIFIED;\n  }\n\n  if (blocked) {\n    verificationStatus = DeviceVerification.BLOCKED;\n  } else if (blocked !== null && verificationStatus == DeviceVerification.BLOCKED) {\n    verificationStatus = DeviceVerification.UNVERIFIED;\n  }\n\n  let knownStatus = dev.known;\n\n  if (known !== null) {\n    knownStatus = known;\n  }\n\n  if (dev.verified !== verificationStatus || dev.known !== knownStatus) {\n    dev.verified = verificationStatus;\n    dev.known = knownStatus;\n\n    this._deviceList.storeDevicesForUser(userId, devices);\n\n    this._deviceList.saveIfDirty();\n  } // do cross-signing\n\n\n  if (verified && userId === this._userId) {\n    const device = await this._crossSigningInfo.signDevice(userId, _deviceinfo.DeviceInfo.fromStorage(dev, deviceId));\n\n    if (device) {\n      await this._baseApis.uploadKeySignatures({\n        [userId]: {\n          [deviceId]: device\n        }\n      }); // XXX: we'll need to wait for the device list to be updated\n    }\n  }\n\n  const deviceObj = _deviceinfo.DeviceInfo.fromStorage(dev, deviceId);\n\n  this.emit(\"deviceVerificationChanged\", userId, deviceId, deviceObj);\n  return deviceObj;\n};\n\nCrypto.prototype.requestVerificationDM = async function (userId, roomId, methods) {\n  const channel = new _InRoomChannel.InRoomChannel(this._baseApis, roomId, userId);\n  const request = await this._requestVerificationWithChannel(userId, methods, channel, this._inRoomVerificationRequests);\n  return await request.waitForVerifier();\n};\n\nCrypto.prototype.acceptVerificationDM = function (event, method) {\n  if (!_InRoomChannel.InRoomChannel.validateEvent(event, this._baseApis)) {\n    return;\n  }\n\n  const sender = event.getSender();\n\n  const requestsByTxnId = this._inRoomVerificationRequests.get(sender);\n\n  if (!requestsByTxnId) {\n    return;\n  }\n\n  const transactionId = _InRoomChannel.InRoomChannel.getTransactionId(event);\n\n  const request = requestsByTxnId.get(transactionId);\n\n  if (!request) {\n    return;\n  }\n\n  return request.beginKeyVerification(method);\n};\n\nCrypto.prototype.requestVerification = async function (userId, methods, devices) {\n  if (!devices) {\n    devices = Object.keys(this._deviceList.getRawStoredDevicesForUser(userId));\n  }\n\n  const channel = new _ToDeviceChannel.ToDeviceChannel(this._baseApis, userId, devices);\n  const request = await this._requestVerificationWithChannel(userId, methods, channel, this._toDeviceVerificationRequests);\n  return await request.waitForVerifier();\n};\n\nCrypto.prototype._requestVerificationWithChannel = async function (userId, methods, channel, requestsMap) {\n  if (!methods) {\n    // .keys() returns an iterator, so we need to explicitly turn it into an array\n    methods = [...this._verificationMethods.keys()];\n  } // TODO: filter by given methods\n\n\n  const request = new _VerificationRequest.VerificationRequest(channel, this._verificationMethods, userId, this._baseApis);\n  await request.sendRequest();\n  let requestsByTxnId = requestsMap.get(userId);\n\n  if (!requestsByTxnId) {\n    requestsByTxnId = new Map();\n    requestsMap.set(userId, requestsByTxnId);\n  } // TODO: we're only adding the request to the map once it has been sent\n  // but if the other party is really fast they could potentially respond to the\n  // request before the server tells us the event got sent, and we would probably\n  // create a new request object\n\n\n  requestsByTxnId.set(channel.transactionId, request);\n  return request;\n};\n\nCrypto.prototype.beginKeyVerification = function (method, userId, deviceId, transactionId = null) {\n  let requestsByTxnId = this._toDeviceVerificationRequests.get(userId);\n\n  if (!requestsByTxnId) {\n    requestsByTxnId = new Map();\n\n    this._toDeviceVerificationRequests.set(userId, requestsByTxnId);\n  }\n\n  let request;\n\n  if (transactionId) {\n    request = requestsByTxnId.get(transactionId);\n  } else {\n    transactionId = _ToDeviceChannel.ToDeviceChannel.makeTransactionId();\n    const channel = new _ToDeviceChannel.ToDeviceChannel(this._baseApis, userId, [deviceId], transactionId, deviceId);\n    request = new _VerificationRequest.VerificationRequest(channel, this._verificationMethods, userId, this._baseApis);\n    requestsByTxnId.set(transactionId, request);\n  }\n\n  if (!request) {\n    throw new Error(`No request found for user ${userId} with transactionId ${transactionId}`);\n  }\n\n  return request.beginKeyVerification(method, {\n    userId,\n    deviceId\n  });\n};\n/**\n * Get information on the active olm sessions with a user\n * <p>\n * Returns a map from device id to an object with keys 'deviceIdKey' (the\n * device's curve25519 identity key) and 'sessions' (an array of objects in the\n * same format as that returned by\n * {@link module:crypto/OlmDevice#getSessionInfoForDevice}).\n * <p>\n * This method is provided for debugging purposes.\n *\n * @param {string} userId id of user to inspect\n *\n * @return {Promise<Object.<string, {deviceIdKey: string, sessions: object[]}>>}\n */\n\n\nCrypto.prototype.getOlmSessionsForUser = async function (userId) {\n  const devices = this.getStoredDevicesForUser(userId) || [];\n  const result = {};\n\n  for (let j = 0; j < devices.length; ++j) {\n    const device = devices[j];\n    const deviceKey = device.getIdentityKey();\n    const sessions = await this._olmDevice.getSessionInfoForDevice(deviceKey);\n    result[device.deviceId] = {\n      deviceIdKey: deviceKey,\n      sessions: sessions\n    };\n  }\n\n  return result;\n};\n/**\n * Get the device which sent an event\n *\n * @param {module:models/event.MatrixEvent} event event to be checked\n *\n * @return {module:crypto/deviceinfo?}\n */\n\n\nCrypto.prototype.getEventSenderDeviceInfo = function (event) {\n  const senderKey = event.getSenderKey();\n  const algorithm = event.getWireContent().algorithm;\n\n  if (!senderKey || !algorithm) {\n    return null;\n  }\n\n  const forwardingChain = event.getForwardingCurve25519KeyChain();\n\n  if (forwardingChain.length > 0) {\n    // we got this event from somewhere else\n    // TODO: check if we can trust the forwarders.\n    return null;\n  } // senderKey is the Curve25519 identity key of the device which the event\n  // was sent from. In the case of Megolm, it's actually the Curve25519\n  // identity key of the device which set up the Megolm session.\n\n\n  const device = this._deviceList.getDeviceByIdentityKey(algorithm, senderKey);\n\n  if (device === null) {\n    // we haven't downloaded the details of this device yet.\n    return null;\n  } // so far so good, but now we need to check that the sender of this event\n  // hadn't advertised someone else's Curve25519 key as their own. We do that\n  // by checking the Ed25519 claimed by the event (or, in the case of megolm,\n  // the event which set up the megolm session), to check that it matches the\n  // fingerprint of the purported sending device.\n  //\n  // (see https://github.com/vector-im/vector-web/issues/2215)\n\n\n  const claimedKey = event.getClaimedEd25519Key();\n\n  if (!claimedKey) {\n    _logger.logger.warn(\"Event \" + event.getId() + \" claims no ed25519 key: \" + \"cannot verify sending device\");\n\n    return null;\n  }\n\n  if (claimedKey !== device.getFingerprint()) {\n    _logger.logger.warn(\"Event \" + event.getId() + \" claims ed25519 key \" + claimedKey + \"but sender device has key \" + device.getFingerprint());\n\n    return null;\n  }\n\n  return device;\n};\n/**\n * Forces the current outbound group session to be discarded such\n * that another one will be created next time an event is sent.\n *\n * @param {string} roomId The ID of the room to discard the session for\n *\n * This should not normally be necessary.\n */\n\n\nCrypto.prototype.forceDiscardSession = function (roomId) {\n  const alg = this._roomEncryptors[roomId];\n  if (alg === undefined) throw new Error(\"Room not encrypted\");\n\n  if (alg.forceDiscardSession === undefined) {\n    throw new Error(\"Room encryption algorithm doesn't support session discarding\");\n  }\n\n  alg.forceDiscardSession();\n};\n/**\n * Configure a room to use encryption (ie, save a flag in the cryptoStore).\n *\n * @param {string} roomId The room ID to enable encryption in.\n *\n * @param {object} config The encryption config for the room.\n *\n * @param {boolean=} inhibitDeviceQuery true to suppress device list query for\n *   users in the room (for now). In case lazy loading is enabled,\n *   the device query is always inhibited as the members are not tracked.\n */\n\n\nCrypto.prototype.setRoomEncryption = async function (roomId, config, inhibitDeviceQuery) {\n  // ignore crypto events with no algorithm defined\n  // This will happen if a crypto event is redacted before we fetch the room state\n  // It would otherwise just throw later as an unknown algorithm would, but we may\n  // as well catch this here\n  if (!config.algorithm) {\n    _logger.logger.log(\"Ignoring setRoomEncryption with no algorithm\");\n\n    return;\n  } // if state is being replayed from storage, we might already have a configuration\n  // for this room as they are persisted as well.\n  // We just need to make sure the algorithm is initialized in this case.\n  // However, if the new config is different,\n  // we should bail out as room encryption can't be changed once set.\n\n\n  const existingConfig = this._roomList.getRoomEncryption(roomId);\n\n  if (existingConfig) {\n    if (JSON.stringify(existingConfig) != JSON.stringify(config)) {\n      _logger.logger.error(\"Ignoring m.room.encryption event which requests \" + \"a change of config in \" + roomId);\n\n      return;\n    }\n  } // if we already have encryption in this room, we should ignore this event,\n  // as it would reset the encryption algorithm.\n  // This is at least expected to be called twice, as sync calls onCryptoEvent\n  // for both the timeline and state sections in the /sync response,\n  // the encryption event would appear in both.\n  // If it's called more than twice though,\n  // it signals a bug on client or server.\n\n\n  const existingAlg = this._roomEncryptors[roomId];\n\n  if (existingAlg) {\n    return;\n  } // _roomList.getRoomEncryption will not race with _roomList.setRoomEncryption\n  // because it first stores in memory. We should await the promise only\n  // after all the in-memory state (_roomEncryptors and _roomList) has been updated\n  // to avoid races when calling this method multiple times. Hence keep a hold of the promise.\n\n\n  let storeConfigPromise = null;\n\n  if (!existingConfig) {\n    storeConfigPromise = this._roomList.setRoomEncryption(roomId, config);\n  }\n\n  const AlgClass = algorithms.ENCRYPTION_CLASSES[config.algorithm];\n\n  if (!AlgClass) {\n    throw new Error(\"Unable to encrypt with \" + config.algorithm);\n  }\n\n  const alg = new AlgClass({\n    userId: this._userId,\n    deviceId: this._deviceId,\n    crypto: this,\n    olmDevice: this._olmDevice,\n    baseApis: this._baseApis,\n    roomId: roomId,\n    config: config\n  });\n  this._roomEncryptors[roomId] = alg;\n\n  if (storeConfigPromise) {\n    await storeConfigPromise;\n  }\n\n  if (!this._lazyLoadMembers) {\n    _logger.logger.log(\"Enabling encryption in \" + roomId + \"; \" + \"starting to track device lists for all users therein\");\n\n    await this.trackRoomDevices(roomId); // TODO: this flag is only not used from MatrixClient::setRoomEncryption\n    // which is never used (inside riot at least)\n    // but didn't want to remove it as it technically would\n    // be a breaking change.\n\n    if (!this.inhibitDeviceQuery) {\n      this._deviceList.refreshOutdatedDeviceLists();\n    }\n  } else {\n    _logger.logger.log(\"Enabling encryption in \" + roomId);\n  }\n};\n/**\n * Make sure we are tracking the device lists for all users in this room.\n *\n * @param {string} roomId The room ID to start tracking devices in.\n * @returns {Promise} when all devices for the room have been fetched and marked to track\n */\n\n\nCrypto.prototype.trackRoomDevices = function (roomId) {\n  const trackMembers = async () => {\n    // not an encrypted room\n    if (!this._roomEncryptors[roomId]) {\n      return;\n    }\n\n    const room = this._clientStore.getRoom(roomId);\n\n    if (!room) {\n      throw new Error(`Unable to start tracking devices in unknown room ${roomId}`);\n    }\n\n    _logger.logger.log(`Starting to track devices for room ${roomId} ...`);\n\n    const members = await room.getEncryptionTargetMembers();\n    members.forEach(m => {\n      this._deviceList.startTrackingDeviceList(m.userId);\n    });\n  };\n\n  let promise = this._roomDeviceTrackingState[roomId];\n\n  if (!promise) {\n    promise = trackMembers();\n    this._roomDeviceTrackingState[roomId] = promise;\n  }\n\n  return promise;\n};\n/**\n * @typedef {Object} module:crypto~OlmSessionResult\n * @property {module:crypto/deviceinfo} device  device info\n * @property {string?} sessionId base64 olm session id; null if no session\n *    could be established\n */\n\n/**\n * Try to make sure we have established olm sessions for all known devices for\n * the given users.\n *\n * @param {string[]} users list of user ids\n *\n * @return {module:client.Promise} resolves once the sessions are complete, to\n *    an Object mapping from userId to deviceId to\n *    {@link module:crypto~OlmSessionResult}\n */\n\n\nCrypto.prototype.ensureOlmSessionsForUsers = function (users) {\n  const devicesByUser = {};\n\n  for (let i = 0; i < users.length; ++i) {\n    const userId = users[i];\n    devicesByUser[userId] = [];\n    const devices = this.getStoredDevicesForUser(userId) || [];\n\n    for (let j = 0; j < devices.length; ++j) {\n      const deviceInfo = devices[j];\n      const key = deviceInfo.getIdentityKey();\n\n      if (key == this._olmDevice.deviceCurve25519Key) {\n        // don't bother setting up session to ourself\n        continue;\n      }\n\n      if (deviceInfo.verified == DeviceVerification.BLOCKED) {\n        // don't bother setting up sessions with blocked users\n        continue;\n      }\n\n      devicesByUser[userId].push(deviceInfo);\n    }\n  }\n\n  return olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, devicesByUser);\n};\n/**\n * Get a list containing all of the room keys\n *\n * @return {module:crypto/OlmDevice.MegolmSessionData[]} a list of session export objects\n */\n\n\nCrypto.prototype.exportRoomKeys = async function () {\n  const exportedSessions = [];\n  await this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS], txn => {\n    this._cryptoStore.getAllEndToEndInboundGroupSessions(txn, s => {\n      if (s === null) return;\n\n      const sess = this._olmDevice.exportInboundGroupSession(s.senderKey, s.sessionId, s.sessionData);\n\n      delete sess.first_known_index;\n      sess.algorithm = olmlib.MEGOLM_ALGORITHM;\n      exportedSessions.push(sess);\n    });\n  });\n  return exportedSessions;\n};\n/**\n * Import a list of room keys previously exported by exportRoomKeys\n *\n * @param {Object[]} keys a list of session export objects\n * @return {module:client.Promise} a promise which resolves once the keys have been imported\n */\n\n\nCrypto.prototype.importRoomKeys = function (keys) {\n  return Promise.all(keys.map(key => {\n    if (!key.room_id || !key.algorithm) {\n      _logger.logger.warn(\"ignoring room key entry with missing fields\", key);\n\n      return null;\n    }\n\n    const alg = this._getRoomDecryptor(key.room_id, key.algorithm);\n\n    return alg.importRoomKey(key);\n  }));\n};\n/**\n * Schedules sending all keys waiting to be sent to the backup, if not already\n * scheduled. Retries if necessary.\n *\n * @param {number} maxDelay Maximum delay to wait in ms. 0 means no delay.\n */\n\n\nCrypto.prototype.scheduleKeyBackupSend = async function (maxDelay = 10000) {\n  if (this._sendingBackups) return;\n  this._sendingBackups = true;\n\n  try {\n    // wait between 0 and `maxDelay` seconds, to avoid backup\n    // requests from different clients hitting the server all at\n    // the same time when a new key is sent\n    const delay = Math.random() * maxDelay;\n    await (0, utils.sleep)(delay);\n    let numFailures = 0; // number of consecutive failures\n\n    while (1) {\n      if (!this.backupKey) {\n        return;\n      }\n\n      try {\n        const numBackedUp = await this._backupPendingKeys(KEY_BACKUP_KEYS_PER_REQUEST);\n\n        if (numBackedUp === 0) {\n          // no sessions left needing backup: we're done\n          return;\n        }\n\n        numFailures = 0;\n      } catch (err) {\n        numFailures++;\n\n        _logger.logger.log(\"Key backup request failed\", err);\n\n        if (err.data) {\n          if (err.data.errcode == 'M_NOT_FOUND' || err.data.errcode == 'M_WRONG_ROOM_KEYS_VERSION') {\n            // Re-check key backup status on error, so we can be\n            // sure to present the current situation when asked.\n            await this.checkKeyBackup(); // Backup version has changed or this backup version\n            // has been deleted\n\n            this.emit(\"crypto.keyBackupFailed\", err.data.errcode);\n            throw err;\n          }\n        }\n      }\n\n      if (numFailures) {\n        // exponential backoff if we have failures\n        await (0, utils.sleep)(1000 * Math.pow(2, Math.min(numFailures - 1, 4)));\n      }\n    }\n  } finally {\n    this._sendingBackups = false;\n  }\n};\n/**\n * Take some e2e keys waiting to be backed up and send them\n * to the backup.\n *\n * @param {integer} limit Maximum number of keys to back up\n * @returns {integer} Number of sessions backed up\n */\n\n\nCrypto.prototype._backupPendingKeys = async function (limit) {\n  const sessions = await this._cryptoStore.getSessionsNeedingBackup(limit);\n\n  if (!sessions.length) {\n    return 0;\n  }\n\n  let remaining = await this._cryptoStore.countSessionsNeedingBackup();\n  this.emit(\"crypto.keyBackupSessionsRemaining\", remaining);\n  const data = {};\n\n  for (const session of sessions) {\n    const roomId = session.sessionData.room_id;\n\n    if (data[roomId] === undefined) {\n      data[roomId] = {\n        sessions: {}\n      };\n    }\n\n    const sessionData = await this._olmDevice.exportInboundGroupSession(session.senderKey, session.sessionId, session.sessionData);\n    sessionData.algorithm = olmlib.MEGOLM_ALGORITHM;\n    delete sessionData.session_id;\n    delete sessionData.room_id;\n    const firstKnownIndex = sessionData.first_known_index;\n    delete sessionData.first_known_index;\n    const encrypted = this.backupKey.encrypt(JSON.stringify(sessionData));\n    const forwardedCount = (sessionData.forwarding_curve25519_key_chain || []).length;\n\n    const device = this._deviceList.getDeviceByIdentityKey(olmlib.MEGOLM_ALGORITHM, session.senderKey);\n\n    data[roomId]['sessions'][session.sessionId] = {\n      first_message_index: firstKnownIndex,\n      forwarded_count: forwardedCount,\n      is_verified: !!(device && device.isVerified()),\n      session_data: encrypted\n    };\n  }\n\n  await this._baseApis.sendKeyBackup(undefined, undefined, this.backupInfo.version, {\n    rooms: data\n  });\n  await this._cryptoStore.unmarkSessionsNeedingBackup(sessions);\n  remaining = await this._cryptoStore.countSessionsNeedingBackup();\n  this.emit(\"crypto.keyBackupSessionsRemaining\", remaining);\n  return sessions.length;\n};\n\nCrypto.prototype.backupGroupSession = async function (roomId, senderKey, forwardingCurve25519KeyChain, sessionId, sessionKey, keysClaimed, exportFormat) {\n  if (!this.backupInfo) {\n    throw new Error(\"Key backups are not enabled\");\n  }\n\n  await this._cryptoStore.markSessionsNeedingBackup([{\n    senderKey: senderKey,\n    sessionId: sessionId\n  }]); // don't wait for this to complete: it will delay so\n  // happens in the background\n\n  this.scheduleKeyBackupSend();\n};\n/**\n * Marks all group sessions as needing to be backed up and schedules them to\n * upload in the background as soon as possible.\n */\n\n\nCrypto.prototype.scheduleAllGroupSessionsForBackup = async function () {\n  await this.flagAllGroupSessionsForBackup(); // Schedule keys to upload in the background as soon as possible.\n\n  this.scheduleKeyBackupSend(0\n  /* maxDelay */\n  );\n};\n/**\n * Marks all group sessions as needing to be backed up without scheduling\n * them to upload in the background.\n * @returns {Promise<int>} Resolves to the number of sessions requiring a backup.\n */\n\n\nCrypto.prototype.flagAllGroupSessionsForBackup = async function () {\n  await this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, _indexeddbCryptoStore.IndexedDBCryptoStore.STORE_BACKUP], txn => {\n    this._cryptoStore.getAllEndToEndInboundGroupSessions(txn, session => {\n      if (session !== null) {\n        this._cryptoStore.markSessionsNeedingBackup([session], txn);\n      }\n    });\n  });\n  const remaining = await this._cryptoStore.countSessionsNeedingBackup();\n  this.emit(\"crypto.keyBackupSessionsRemaining\", remaining);\n  return remaining;\n};\n/* eslint-disable valid-jsdoc */\n//https://github.com/eslint/eslint/issues/7307\n\n/**\n * Encrypt an event according to the configuration of the room.\n *\n * @param {module:models/event.MatrixEvent} event  event to be sent\n *\n * @param {module:models/room} room destination room.\n *\n * @return {module:client.Promise?} Promise which resolves when the event has been\n *     encrypted, or null if nothing was needed\n */\n\n/* eslint-enable valid-jsdoc */\n\n\nCrypto.prototype.encryptEvent = async function (event, room) {\n  if (!room) {\n    throw new Error(\"Cannot send encrypted messages in unknown rooms\");\n  }\n\n  const roomId = event.getRoomId();\n  const alg = this._roomEncryptors[roomId];\n\n  if (!alg) {\n    // MatrixClient has already checked that this room should be encrypted,\n    // so this is an unexpected situation.\n    throw new Error(\"Room was previously configured to use encryption, but is \" + \"no longer. Perhaps the homeserver is hiding the \" + \"configuration event.\");\n  }\n\n  if (!this._roomDeviceTrackingState[roomId]) {\n    this.trackRoomDevices(roomId);\n  } // wait for all the room devices to be loaded\n\n\n  await this._roomDeviceTrackingState[roomId];\n  let content = event.getContent(); // If event has an m.relates_to then we need\n  // to put this on the wrapping event instead\n\n  const mRelatesTo = content['m.relates_to'];\n\n  if (mRelatesTo) {\n    // Clone content here so we don't remove `m.relates_to` from the local-echo\n    content = Object.assign({}, content);\n    delete content['m.relates_to'];\n  }\n\n  const encryptedContent = await alg.encryptMessage(room, event.getType(), content);\n\n  if (mRelatesTo) {\n    encryptedContent['m.relates_to'] = mRelatesTo;\n  }\n\n  event.makeEncrypted(\"m.room.encrypted\", encryptedContent, this._olmDevice.deviceCurve25519Key, this._olmDevice.deviceEd25519Key);\n};\n/**\n * Decrypt a received event\n *\n * @param {MatrixEvent} event\n *\n * @return {Promise<module:crypto~EventDecryptionResult>} resolves once we have\n *  finished decrypting. Rejects with an `algorithms.DecryptionError` if there\n *  is a problem decrypting the event.\n */\n\n\nCrypto.prototype.decryptEvent = function (event) {\n  if (event.isRedacted()) {\n    return Promise.resolve({\n      clearEvent: {\n        room_id: event.getRoomId(),\n        type: \"m.room.message\",\n        content: {}\n      }\n    });\n  }\n\n  const content = event.getWireContent();\n\n  const alg = this._getRoomDecryptor(event.getRoomId(), content.algorithm);\n\n  return alg.decryptEvent(event);\n};\n/**\n * Handle the notification from /sync or /keys/changes that device lists have\n * been changed.\n *\n * @param {Object} syncData Object containing sync tokens associated with this sync\n * @param {Object} syncDeviceLists device_lists field from /sync, or response from\n * /keys/changes\n */\n\n\nCrypto.prototype.handleDeviceListChanges = async function (syncData, syncDeviceLists) {\n  // Initial syncs don't have device change lists. We'll either get the complete list\n  // of changes for the interval or will have invalidated everything in willProcessSync\n  if (!syncData.oldSyncToken) return; // Here, we're relying on the fact that we only ever save the sync data after\n  // sucessfully saving the device list data, so we're guaranteed that the device\n  // list store is at least as fresh as the sync token from the sync store, ie.\n  // any device changes received in sync tokens prior to the 'next' token here\n  // have been processed and are reflected in the current device list.\n  // If we didn't make this assumption, we'd have to use the /keys/changes API\n  // to get key changes between the sync token in the device list and the 'old'\n  // sync token used here to make sure we didn't miss any.\n\n  await this._evalDeviceListChanges(syncDeviceLists);\n};\n/**\n * Send a request for some room keys, if we have not already done so\n *\n * @param {module:crypto~RoomKeyRequestBody} requestBody\n * @param {Array<{userId: string, deviceId: string}>} recipients\n * @param {boolean} resend whether to resend the key request if there is\n *    already one\n *\n * @return {Promise} a promise that resolves when the key request is queued\n */\n\n\nCrypto.prototype.requestRoomKey = function (requestBody, recipients, resend = false) {\n  return this._outgoingRoomKeyRequestManager.sendRoomKeyRequest(requestBody, recipients, resend).catch(e => {\n    // this normally means we couldn't talk to the store\n    _logger.logger.error('Error requesting key for event', e);\n  });\n};\n/**\n * Cancel any earlier room key request\n *\n * @param {module:crypto~RoomKeyRequestBody} requestBody\n *    parameters to match for cancellation\n */\n\n\nCrypto.prototype.cancelRoomKeyRequest = function (requestBody) {\n  this._outgoingRoomKeyRequestManager.cancelRoomKeyRequest(requestBody).catch(e => {\n    _logger.logger.warn(\"Error clearing pending room key requests\", e);\n  });\n};\n/**\n * handle an m.room.encryption event\n *\n * @param {module:models/event.MatrixEvent} event encryption event\n */\n\n\nCrypto.prototype.onCryptoEvent = async function (event) {\n  const roomId = event.getRoomId();\n  const content = event.getContent();\n\n  try {\n    // inhibit the device list refresh for now - it will happen once we've\n    // finished processing the sync, in onSyncCompleted.\n    await this.setRoomEncryption(roomId, content, true);\n  } catch (e) {\n    _logger.logger.error(\"Error configuring encryption in room \" + roomId + \":\", e);\n  }\n};\n/**\n * Called before the result of a sync is procesed\n *\n * @param {Object} syncData  the data from the 'MatrixClient.sync' event\n */\n\n\nCrypto.prototype.onSyncWillProcess = async function (syncData) {\n  if (!syncData.oldSyncToken) {\n    // If there is no old sync token, we start all our tracking from\n    // scratch, so mark everything as untracked. onCryptoEvent will\n    // be called for all e2e rooms during the processing of the sync,\n    // at which point we'll start tracking all the users of that room.\n    _logger.logger.log(\"Initial sync performed - resetting device tracking state\");\n\n    this._deviceList.stopTrackingAllDeviceLists(); // we always track our own device list (for key backups etc)\n\n\n    this._deviceList.startTrackingDeviceList(this._userId);\n\n    this._roomDeviceTrackingState = {};\n  }\n};\n/**\n * handle the completion of a /sync\n *\n * This is called after the processing of each successful /sync response.\n * It is an opportunity to do a batch process on the information received.\n *\n * @param {Object} syncData  the data from the 'MatrixClient.sync' event\n */\n\n\nCrypto.prototype.onSyncCompleted = async function (syncData) {\n  const nextSyncToken = syncData.nextSyncToken;\n\n  this._deviceList.setSyncToken(syncData.nextSyncToken);\n\n  this._deviceList.saveIfDirty(); // catch up on any new devices we got told about during the sync.\n\n\n  this._deviceList.lastKnownSyncToken = nextSyncToken; // we always track our own device list (for key backups etc)\n\n  this._deviceList.startTrackingDeviceList(this._userId);\n\n  this._deviceList.refreshOutdatedDeviceLists(); // we don't start uploading one-time keys until we've caught up with\n  // to-device messages, to help us avoid throwing away one-time-keys that we\n  // are about to receive messages for\n  // (https://github.com/vector-im/riot-web/issues/2782).\n\n\n  if (!syncData.catchingUp) {\n    _maybeUploadOneTimeKeys(this);\n\n    this._processReceivedRoomKeyRequests();\n  }\n};\n/**\n * Trigger the appropriate invalidations and removes for a given\n * device list\n *\n * @param {Object} deviceLists device_lists field from /sync, or response from\n * /keys/changes\n */\n\n\nCrypto.prototype._evalDeviceListChanges = async function (deviceLists) {\n  if (deviceLists.changed && Array.isArray(deviceLists.changed)) {\n    deviceLists.changed.forEach(u => {\n      this._deviceList.invalidateUserDeviceList(u);\n    });\n  }\n\n  if (deviceLists.left && Array.isArray(deviceLists.left) && deviceLists.left.length) {\n    // Check we really don't share any rooms with these users\n    // any more: the server isn't required to give us the\n    // exact correct set.\n    const e2eUserIds = new Set((await this._getTrackedE2eUsers()));\n    deviceLists.left.forEach(u => {\n      if (!e2eUserIds.has(u)) {\n        this._deviceList.stopTrackingDeviceList(u);\n      }\n    });\n  }\n};\n/**\n * Get a list of all the IDs of users we share an e2e room with\n * for which we are tracking devices already\n *\n * @returns {string[]} List of user IDs\n */\n\n\nCrypto.prototype._getTrackedE2eUsers = async function () {\n  const e2eUserIds = [];\n\n  for (const room of this._getTrackedE2eRooms()) {\n    const members = await room.getEncryptionTargetMembers();\n\n    for (const member of members) {\n      e2eUserIds.push(member.userId);\n    }\n  }\n\n  return e2eUserIds;\n};\n/**\n * Get a list of the e2e-enabled rooms we are members of,\n * and for which we are already tracking the devices\n *\n * @returns {module:models.Room[]}\n */\n\n\nCrypto.prototype._getTrackedE2eRooms = function () {\n  return this._clientStore.getRooms().filter(room => {\n    // check for rooms with encryption enabled\n    const alg = this._roomEncryptors[room.roomId];\n\n    if (!alg) {\n      return false;\n    }\n\n    if (!this._roomDeviceTrackingState[room.roomId]) {\n      return false;\n    } // ignore any rooms which we have left\n\n\n    const myMembership = room.getMyMembership();\n    return myMembership === \"join\" || myMembership === \"invite\";\n  });\n};\n\nCrypto.prototype._onToDeviceEvent = function (event) {\n  try {\n    _logger.logger.log(`received to_device ${event.getType()} from: ` + `${event.getSender()} id: ${event.getId()}`);\n\n    if (event.getType() == \"m.room_key\" || event.getType() == \"m.forwarded_room_key\") {\n      this._onRoomKeyEvent(event);\n    } else if (event.getType() == \"m.room_key_request\") {\n      this._onRoomKeyRequestEvent(event);\n    } else if (event.getType() === \"m.secret.request\") {\n      this._secretStorage._onRequestReceived(event);\n    } else if (event.getType() === \"m.secret.send\") {\n      this._secretStorage._onSecretReceived(event);\n    } else if (event.getType() === \"org.matrix.room_key.withheld\") {\n      this._onRoomKeyWithheldEvent(event);\n    } else if (event.getContent().transaction_id) {\n      this._onKeyVerificationMessage(event);\n    } else if (event.getContent().msgtype === \"m.bad.encrypted\") {\n      this._onToDeviceBadEncrypted(event);\n    } else if (event.isBeingDecrypted()) {\n      // once the event has been decrypted, try again\n      event.once('Event.decrypted', ev => {\n        this._onToDeviceEvent(ev);\n      });\n    }\n  } catch (e) {\n    _logger.logger.error(\"Error handling toDeviceEvent:\", e);\n  }\n};\n/**\n * Handle a key event\n *\n * @private\n * @param {module:models/event.MatrixEvent} event key event\n */\n\n\nCrypto.prototype._onRoomKeyEvent = function (event) {\n  const content = event.getContent();\n\n  if (!content.room_id || !content.algorithm) {\n    _logger.logger.error(\"key event is missing fields\");\n\n    return;\n  }\n\n  if (!this._checkedForBackup) {\n    // don't bother awaiting on this - the important thing is that we retry if we\n    // haven't managed to check before\n    this._checkAndStartKeyBackup();\n  }\n\n  const alg = this._getRoomDecryptor(content.room_id, content.algorithm);\n\n  alg.onRoomKeyEvent(event);\n};\n/**\n * Handle a key withheld event\n *\n * @private\n * @param {module:models/event.MatrixEvent} event key withheld event\n */\n\n\nCrypto.prototype._onRoomKeyWithheldEvent = function (event) {\n  const content = event.getContent();\n\n  if (content.code !== \"m.no_olm\" && (!content.room_id || !content.session_id) || !content.algorithm || !content.sender_key) {\n    _logger.logger.error(\"key withheld event is missing fields\");\n\n    return;\n  }\n\n  _logger.logger.info(`Got room key withheld event from ${event.getSender()} (${content.sender_key}) ` + `for ${content.algorithm}/${content.room_id}/${content.session_id} ` + `with reason ${content.code} (${content.reason})`);\n\n  const alg = this._getRoomDecryptor(content.room_id, content.algorithm);\n\n  if (alg.onRoomKeyWithheldEvent) {\n    alg.onRoomKeyWithheldEvent(event);\n  }\n\n  if (!content.room_id) {\n    // retry decryption for all events sent by the sender_key.  This will\n    // update the events to show a message indicating that the olm session was\n    // wedged.\n    const roomDecryptors = this._getRoomDecryptors(content.algorithm);\n\n    for (const decryptor of roomDecryptors) {\n      decryptor.retryDecryptionFromSender(content.sender_key);\n    }\n  }\n};\n/**\n * Handle a general key verification event.\n *\n * @private\n * @param {module:models/event.MatrixEvent} event verification start event\n */\n\n\nCrypto.prototype._onKeyVerificationMessage = function (event) {\n  if (!_ToDeviceChannel.ToDeviceChannel.validateEvent(event, this._baseApis)) {\n    return;\n  }\n\n  const transactionId = _ToDeviceChannel.ToDeviceChannel.getTransactionId(event);\n\n  const createRequest = event => {\n    if (!_ToDeviceChannel.ToDeviceChannel.canCreateRequest(_ToDeviceChannel.ToDeviceChannel.getEventType(event))) {\n      return;\n    }\n\n    const content = event.getContent();\n    const deviceId = content && content.from_device;\n\n    if (!deviceId) {\n      return;\n    }\n\n    const userId = event.getSender();\n    const channel = new _ToDeviceChannel.ToDeviceChannel(this._baseApis, userId, [deviceId]);\n    return new _VerificationRequest.VerificationRequest(channel, this._verificationMethods, userId, this._baseApis);\n  };\n\n  this._handleVerificationEvent(event, transactionId, this._toDeviceVerificationRequests, createRequest);\n};\n/**\n * Handle key verification requests sent as timeline events\n *\n * @private\n * @param {module:models/event.MatrixEvent} event the timeline event\n */\n\n\nCrypto.prototype._onTimelineEvent = function (event) {\n  if (!_InRoomChannel.InRoomChannel.validateEvent(event, this._baseApis)) {\n    return;\n  }\n\n  const transactionId = _InRoomChannel.InRoomChannel.getTransactionId(event);\n\n  const createRequest = event => {\n    if (!_InRoomChannel.InRoomChannel.canCreateRequest(_InRoomChannel.InRoomChannel.getEventType(event))) {\n      return;\n    }\n\n    const userId = event.getSender();\n    const channel = new _InRoomChannel.InRoomChannel(this._baseApis, event.getRoomId(), userId);\n    return new _VerificationRequest.VerificationRequest(channel, this._verificationMethods, userId, this._baseApis);\n  };\n\n  this._handleVerificationEvent(event, transactionId, this._inRoomVerificationRequests, createRequest);\n};\n\nCrypto.prototype._handleVerificationEvent = async function (event, transactionId, requestsMap, createRequest) {\n  const sender = event.getSender();\n  let requestsByTxnId = requestsMap.get(sender);\n  let isNewRequest = false;\n  let request = requestsByTxnId && requestsByTxnId.get(transactionId);\n\n  if (!request) {\n    request = createRequest(event); // a request could not be made from this event, so ignore event\n\n    if (!request) {\n      return;\n    }\n\n    isNewRequest = true;\n\n    if (!requestsByTxnId) {\n      requestsByTxnId = new Map();\n      requestsMap.set(sender, requestsByTxnId);\n    }\n\n    requestsByTxnId.set(transactionId, request);\n  }\n\n  try {\n    const hadVerifier = !!request.verifier;\n    await request.channel.handleEvent(event, request); // emit start event when verifier got set\n\n    if (!hadVerifier && request.verifier) {\n      this._baseApis.emit(\"crypto.verification.start\", request.verifier);\n    }\n  } catch (err) {\n    console.error(\"error while handling verification event\", event, err);\n  }\n\n  if (!request.pending) {\n    requestsByTxnId.delete(transactionId);\n\n    if (requestsByTxnId.size === 0) {\n      requestsMap.delete(sender);\n    }\n  } else if (isNewRequest && !request.initiatedByMe) {\n    this._baseApis.emit(\"crypto.verification.request\", request);\n  }\n};\n/**\n * Handle a toDevice event that couldn't be decrypted\n *\n * @private\n * @param {module:models/event.MatrixEvent} event undecryptable event\n */\n\n\nCrypto.prototype._onToDeviceBadEncrypted = async function (event) {\n  const content = event.getWireContent();\n  const sender = event.getSender();\n  const algorithm = content.algorithm;\n  const deviceKey = content.sender_key; // retry decryption for all events sent by the sender_key.  This will\n  // update the events to show a message indicating that the olm session was\n  // wedged.\n\n  const retryDecryption = () => {\n    const roomDecryptors = this._getRoomDecryptors(olmlib.MEGOLM_ALGORITHM);\n\n    for (const decryptor of roomDecryptors) {\n      decryptor.retryDecryptionFromSender(deviceKey);\n    }\n  };\n\n  if (sender === undefined || deviceKey === undefined || deviceKey === undefined) {\n    return;\n  } // check when we last forced a new session with this device: if we've already done so\n  // recently, don't do it again.\n\n\n  this._lastNewSessionForced[sender] = this._lastNewSessionForced[sender] || {};\n  const lastNewSessionForced = this._lastNewSessionForced[sender][deviceKey] || 0;\n\n  if (lastNewSessionForced + MIN_FORCE_SESSION_INTERVAL_MS > Date.now()) {\n    _logger.logger.debug(\"New session already forced with device \" + sender + \":\" + deviceKey + \" at \" + lastNewSessionForced + \": not forcing another\");\n\n    await this._olmDevice.recordSessionProblem(deviceKey, \"wedged\", true);\n    retryDecryption();\n    return;\n  } // establish a new olm session with this device since we're failing to decrypt messages\n  // on a current session.\n  // Note that an undecryptable message from another device could easily be spoofed -\n  // is there anything we can do to mitigate this?\n\n\n  const device = this._deviceList.getDeviceByIdentityKey(algorithm, deviceKey);\n\n  if (!device) {\n    _logger.logger.info(\"Couldn't find device for identity key \" + deviceKey + \": not re-establishing session\");\n\n    await this._olmDevice.recordSessionProblem(deviceKey, \"wedged\", false);\n    retryDecryption();\n    return;\n  }\n\n  const devicesByUser = {};\n  devicesByUser[sender] = [device];\n  await olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, devicesByUser, true);\n  this._lastNewSessionForced[sender][deviceKey] = Date.now(); // Now send a blank message on that session so the other side knows about it.\n  // (The keyshare request is sent in the clear so that won't do)\n  // We send this first such that, as long as the toDevice messages arrive in the\n  // same order we sent them, the other end will get this first, set up the new session,\n  // then get the keyshare request and send the key over this new session (because it\n  // is the session it has most recently received a message on).\n\n  const encryptedContent = {\n    algorithm: olmlib.OLM_ALGORITHM,\n    sender_key: this._olmDevice.deviceCurve25519Key,\n    ciphertext: {}\n  };\n  await olmlib.encryptMessageForDevice(encryptedContent.ciphertext, this._userId, this._deviceId, this._olmDevice, sender, device, {\n    type: \"m.dummy\"\n  });\n  await this._olmDevice.recordSessionProblem(deviceKey, \"wedged\", true);\n  retryDecryption();\n  await this._baseApis.sendToDevice(\"m.room.encrypted\", {\n    [sender]: {\n      [device.deviceId]: encryptedContent\n    }\n  }); // Most of the time this probably won't be necessary since we'll have queued up a key request when\n  // we failed to decrypt the message and will be waiting a bit for the key to arrive before sending\n  // it. This won't always be the case though so we need to re-send any that have already been sent\n  // to avoid races.\n\n  const requestsToResend = await this._outgoingRoomKeyRequestManager.getOutgoingSentRoomKeyRequest(sender, device.deviceId);\n\n  for (const keyReq of requestsToResend) {\n    this.requestRoomKey(keyReq.requestBody, keyReq.recipients, true);\n  }\n};\n/**\n * Handle a change in the membership state of a member of a room\n *\n * @private\n * @param {module:models/event.MatrixEvent} event  event causing the change\n * @param {module:models/room-member} member  user whose membership changed\n * @param {string=} oldMembership  previous membership\n */\n\n\nCrypto.prototype._onRoomMembership = function (event, member, oldMembership) {\n  // this event handler is registered on the *client* (as opposed to the room\n  // member itself), which means it is only called on changes to the *live*\n  // membership state (ie, it is not called when we back-paginate, nor when\n  // we load the state in the initialsync).\n  //\n  // Further, it is automatically registered and called when new members\n  // arrive in the room.\n  const roomId = member.roomId;\n  const alg = this._roomEncryptors[roomId];\n\n  if (!alg) {\n    // not encrypting in this room\n    return;\n  } // only mark users in this room as tracked if we already started tracking in this room\n  // this way we don't start device queries after sync on behalf of this room which we won't use\n  // the result of anyway, as we'll need to do a query again once all the members are fetched\n  // by calling _trackRoomDevices\n\n\n  if (this._roomDeviceTrackingState[roomId]) {\n    if (member.membership == 'join') {\n      _logger.logger.log('Join event for ' + member.userId + ' in ' + roomId); // make sure we are tracking the deviceList for this user\n\n\n      this._deviceList.startTrackingDeviceList(member.userId);\n    } else if (member.membership == 'invite' && this._clientStore.getRoom(roomId).shouldEncryptForInvitedMembers()) {\n      _logger.logger.log('Invite event for ' + member.userId + ' in ' + roomId);\n\n      this._deviceList.startTrackingDeviceList(member.userId);\n    }\n  }\n\n  alg.onRoomMembership(event, member, oldMembership);\n};\n/**\n * Called when we get an m.room_key_request event.\n *\n * @private\n * @param {module:models/event.MatrixEvent} event key request event\n */\n\n\nCrypto.prototype._onRoomKeyRequestEvent = function (event) {\n  const content = event.getContent();\n\n  if (content.action === \"request\") {\n    // Queue it up for now, because they tend to arrive before the room state\n    // events at initial sync, and we want to see if we know anything about the\n    // room before passing them on to the app.\n    const req = new IncomingRoomKeyRequest(event);\n\n    this._receivedRoomKeyRequests.push(req);\n  } else if (content.action === \"request_cancellation\") {\n    const req = new IncomingRoomKeyRequestCancellation(event);\n\n    this._receivedRoomKeyRequestCancellations.push(req);\n  }\n};\n/**\n * Process any m.room_key_request events which were queued up during the\n * current sync.\n *\n * @private\n */\n\n\nCrypto.prototype._processReceivedRoomKeyRequests = async function () {\n  if (this._processingRoomKeyRequests) {\n    // we're still processing last time's requests; keep queuing new ones\n    // up for now.\n    return;\n  }\n\n  this._processingRoomKeyRequests = true;\n\n  try {\n    // we need to grab and clear the queues in the synchronous bit of this method,\n    // so that we don't end up racing with the next /sync.\n    const requests = this._receivedRoomKeyRequests;\n    this._receivedRoomKeyRequests = [];\n    const cancellations = this._receivedRoomKeyRequestCancellations;\n    this._receivedRoomKeyRequestCancellations = []; // Process all of the requests, *then* all of the cancellations.\n    //\n    // This makes sure that if we get a request and its cancellation in the\n    // same /sync result, then we process the request before the\n    // cancellation (and end up with a cancelled request), rather than the\n    // cancellation before the request (and end up with an outstanding\n    // request which should have been cancelled.)\n\n    await Promise.all(requests.map(req => this._processReceivedRoomKeyRequest(req)));\n    await Promise.all(cancellations.map(cancellation => this._processReceivedRoomKeyRequestCancellation(cancellation)));\n  } catch (e) {\n    _logger.logger.error(`Error processing room key requsts: ${e}`);\n  } finally {\n    this._processingRoomKeyRequests = false;\n  }\n};\n/**\n * Helper for processReceivedRoomKeyRequests\n *\n * @param {IncomingRoomKeyRequest} req\n */\n\n\nCrypto.prototype._processReceivedRoomKeyRequest = async function (req) {\n  const userId = req.userId;\n  const deviceId = req.deviceId;\n  const body = req.requestBody;\n  const roomId = body.room_id;\n  const alg = body.algorithm;\n\n  _logger.logger.log(`m.room_key_request from ${userId}:${deviceId}` + ` for ${roomId} / ${body.session_id} (id ${req.requestId})`);\n\n  if (userId !== this._userId) {\n    if (!this._roomEncryptors[roomId]) {\n      _logger.logger.debug(`room key request for unencrypted room ${roomId}`);\n\n      return;\n    }\n\n    const encryptor = this._roomEncryptors[roomId];\n\n    const device = this._deviceList.getStoredDevice(userId, deviceId);\n\n    if (!device) {\n      _logger.logger.debug(`Ignoring keyshare for unknown device ${userId}:${deviceId}`);\n\n      return;\n    }\n\n    try {\n      await encryptor.reshareKeyWithDevice(body.sender_key, body.session_id, userId, device);\n    } catch (e) {\n      _logger.logger.warn(\"Failed to re-share keys for session \" + body.session_id + \" with device \" + userId + \":\" + device.deviceId, e);\n    }\n\n    return;\n  } // todo: should we queue up requests we don't yet have keys for,\n  // in case they turn up later?\n  // if we don't have a decryptor for this room/alg, we don't have\n  // the keys for the requested events, and can drop the requests.\n\n\n  if (!this._roomDecryptors[roomId]) {\n    _logger.logger.log(`room key request for unencrypted room ${roomId}`);\n\n    return;\n  }\n\n  const decryptor = this._roomDecryptors[roomId][alg];\n\n  if (!decryptor) {\n    _logger.logger.log(`room key request for unknown alg ${alg} in room ${roomId}`);\n\n    return;\n  }\n\n  if (!(await decryptor.hasKeysForKeyRequest(req))) {\n    _logger.logger.log(`room key request for unknown session ${roomId} / ` + body.session_id);\n\n    return;\n  }\n\n  req.share = () => {\n    decryptor.shareKeysWithDevice(req);\n  }; // if the device is is verified already, share the keys\n\n\n  const device = this._deviceList.getStoredDevice(userId, deviceId);\n\n  if (device && device.isVerified()) {\n    _logger.logger.log('device is already verified: sharing keys');\n\n    req.share();\n    return;\n  }\n\n  this.emit(\"crypto.roomKeyRequest\", req);\n};\n/**\n * Helper for processReceivedRoomKeyRequests\n *\n * @param {IncomingRoomKeyRequestCancellation} cancellation\n */\n\n\nCrypto.prototype._processReceivedRoomKeyRequestCancellation = async function (cancellation) {\n  _logger.logger.log(`m.room_key_request cancellation for ${cancellation.userId}:` + `${cancellation.deviceId} (id ${cancellation.requestId})`); // we should probably only notify the app of cancellations we told it\n  // about, but we don't currently have a record of that, so we just pass\n  // everything through.\n\n\n  this.emit(\"crypto.roomKeyRequestCancellation\", cancellation);\n};\n/**\n * Get a decryptor for a given room and algorithm.\n *\n * If we already have a decryptor for the given room and algorithm, return\n * it. Otherwise try to instantiate it.\n *\n * @private\n *\n * @param {string?} roomId   room id for decryptor. If undefined, a temporary\n * decryptor is instantiated.\n *\n * @param {string} algorithm  crypto algorithm\n *\n * @return {module:crypto.algorithms.base.DecryptionAlgorithm}\n *\n * @raises {module:crypto.algorithms.DecryptionError} if the algorithm is\n * unknown\n */\n\n\nCrypto.prototype._getRoomDecryptor = function (roomId, algorithm) {\n  let decryptors;\n  let alg;\n  roomId = roomId || null;\n\n  if (roomId) {\n    decryptors = this._roomDecryptors[roomId];\n\n    if (!decryptors) {\n      this._roomDecryptors[roomId] = decryptors = {};\n    }\n\n    alg = decryptors[algorithm];\n\n    if (alg) {\n      return alg;\n    }\n  }\n\n  const AlgClass = algorithms.DECRYPTION_CLASSES[algorithm];\n\n  if (!AlgClass) {\n    throw new algorithms.DecryptionError('UNKNOWN_ENCRYPTION_ALGORITHM', 'Unknown encryption algorithm \"' + algorithm + '\".');\n  }\n\n  alg = new AlgClass({\n    userId: this._userId,\n    crypto: this,\n    olmDevice: this._olmDevice,\n    baseApis: this._baseApis,\n    roomId: roomId\n  });\n\n  if (decryptors) {\n    decryptors[algorithm] = alg;\n  }\n\n  return alg;\n};\n/**\n * Get all the room decryptors for a given encryption algorithm.\n *\n * @param {string} algorithm The encryption algorithm\n *\n * @return {array} An array of room decryptors\n */\n\n\nCrypto.prototype._getRoomDecryptors = function (algorithm) {\n  const decryptors = [];\n\n  for (const d of Object.values(this._roomDecryptors)) {\n    if (algorithm in d) {\n      decryptors.push(d[algorithm]);\n    }\n  }\n\n  return decryptors;\n};\n/**\n * sign the given object with our ed25519 key\n *\n * @param {Object} obj  Object to which we will add a 'signatures' property\n */\n\n\nCrypto.prototype._signObject = async function (obj) {\n  const sigs = obj.signatures || {};\n  const unsigned = obj.unsigned;\n  delete obj.signatures;\n  delete obj.unsigned;\n  sigs[this._userId] = sigs[this._userId] || {};\n  sigs[this._userId][\"ed25519:\" + this._deviceId] = await this._olmDevice.sign(_anotherJson.default.stringify(obj));\n  obj.signatures = sigs;\n  if (unsigned !== undefined) obj.unsigned = unsigned;\n};\n/**\n * The parameters of a room key request. The details of the request may\n * vary with the crypto algorithm, but the management and storage layers for\n * outgoing requests expect it to have 'room_id' and 'session_id' properties.\n *\n * @typedef {Object} RoomKeyRequestBody\n */\n\n/**\n * Represents a received m.room_key_request event\n *\n * @property {string} userId    user requesting the key\n * @property {string} deviceId  device requesting the key\n * @property {string} requestId unique id for the request\n * @property {module:crypto~RoomKeyRequestBody} requestBody\n * @property {function()} share  callback which, when called, will ask\n *    the relevant crypto algorithm implementation to share the keys for\n *    this request.\n */\n\n\nclass IncomingRoomKeyRequest {\n  constructor(event) {\n    const content = event.getContent();\n    this.userId = event.getSender();\n    this.deviceId = content.requesting_device_id;\n    this.requestId = content.request_id;\n    this.requestBody = content.body || {};\n\n    this.share = () => {\n      throw new Error(\"don't know how to share keys for this request yet\");\n    };\n  }\n\n}\n/**\n * Represents a received m.room_key_request cancellation\n *\n * @property {string} userId    user requesting the cancellation\n * @property {string} deviceId  device requesting the cancellation\n * @property {string} requestId unique id for the request to be cancelled\n */\n\n\nclass IncomingRoomKeyRequestCancellation {\n  constructor(event) {\n    const content = event.getContent();\n    this.userId = event.getSender();\n    this.deviceId = content.requesting_device_id;\n    this.requestId = content.request_id;\n  }\n\n}\n/**\n * The result of a (successful) call to decryptEvent.\n *\n * @typedef {Object} EventDecryptionResult\n *\n * @property {Object} clearEvent The plaintext payload for the event\n *     (typically containing <tt>type</tt> and <tt>content</tt> fields).\n *\n * @property {?string} senderCurve25519Key Key owned by the sender of this\n *    event.  See {@link module:models/event.MatrixEvent#getSenderKey}.\n *\n * @property {?string} claimedEd25519Key ed25519 key claimed by the sender of\n *    this event. See\n *    {@link module:models/event.MatrixEvent#getClaimedEd25519Key}.\n *\n * @property {?Array<string>} forwardingCurve25519KeyChain list of curve25519\n *     keys involved in telling us about the senderCurve25519Key and\n *     claimedEd25519Key. See\n *     {@link module:models/event.MatrixEvent#getForwardingCurve25519KeyChain}.\n */\n\n/**\n * Fires when we receive a room key request\n *\n * @event module:client~MatrixClient#\"crypto.roomKeyRequest\"\n * @param {module:crypto~IncomingRoomKeyRequest} req  request details\n */\n\n/**\n * Fires when we receive a room key request cancellation\n *\n * @event module:client~MatrixClient#\"crypto.roomKeyRequestCancellation\"\n * @param {module:crypto~IncomingRoomKeyRequestCancellation} req\n */\n\n/**\n * Fires when the app may wish to warn the user about something related\n * the end-to-end crypto.\n *\n * @event module:client~MatrixClient#\"crypto.warning\"\n * @param {string} type One of the strings listed above\n */","map":{"version":3,"sources":["/home/kimist/Developpement/React/watcha_client/node_modules/matrix-js-sdk/lib/crypto/index.js"],"names":["_interopRequireWildcard","require","_interopRequireDefault","Object","defineProperty","exports","value","isCryptoAvailable","Crypto","verificationMethods","_anotherJson","_events","_ReEmitter","_logger","utils","_OlmDevice","olmlib","_DeviceList","_deviceinfo","algorithms","_CrossSigning","_SecretStorage","_OutgoingRoomKeyRequestManager","_indexeddbCryptoStore","_QRCode","_SAS","_key_passphrase","_recoverykey","_VerificationRequest","_InRoomChannel","_ToDeviceChannel","httpApi","DeviceVerification","DeviceInfo","defaultVerificationMethods","ScanQRCode","NAME","ShowQRCode","SAS","QR_CODE_SCAN","QR_CODE_SHOW","Boolean","global","Olm","MIN_FORCE_SESSION_INTERVAL_MS","KEY_BACKUP_KEYS_PER_REQUEST","baseApis","sessionStore","userId","deviceId","clientStore","cryptoStore","roomList","_onDeviceListUserCrossSigningUpdated","bind","_reEmitter","ReEmitter","_baseApis","_sessionStore","_userId","_deviceId","_clientStore","_cryptoStore","_roomList","_verificationMethods","Map","method","set","backupInfo","backupKey","_checkedForBackup","_sendingBackups","_olmDevice","OlmDevice","_deviceList","DeviceList","on","reEmit","_lastOneTimeKeyCheck","_oneTimeKeyCheckInProgress","_roomEncryptors","_roomDecryptors","_supportedAlgorithms","keys","DECRYPTION_CLASSES","_deviceKeys","_globalBlacklistUnverifiedDevices","_globalErrorOnUnknownDevices","_outgoingRoomKeyRequestManager","OutgoingRoomKeyRequestManager","_receivedRoomKeyRequests","_receivedRoomKeyRequestCancellations","_processingRoomKeyRequests","_lazyLoadMembers","_roomDeviceTrackingState","_lastNewSessionForced","_toDeviceVerificationRequests","_inRoomVerificationRequests","cryptoCallbacks","_cryptoCallbacks","_crossSigningInfo","CrossSigningInfo","_secretStorage","SecretStorage","getCrossSigningKey","getSecretStorageKey","type","getFromSecretStorage","inherits","EventEmitter","prototype","init","logger","log","load","deviceEd25519Key","deviceCurve25519Key","myDevices","getRawStoredDevicesForUser","deviceInfo","verified","VERIFIED","known","storeDevicesForUser","saveIfDirty","doTxn","IndexedDBCryptoStore","STORE_ACCOUNT","txn","getCrossSigningKeys","setKeys","startTrackingDeviceList","_checkAndStartKeyBackup","createRecoveryKeyFromPassphrase","password","decryption","PkDecryption","keyInfo","derivation","keyFromPassphrase","passphrase","algorithm","iterations","salt","pubkey","init_with_private_key","key","generate_key","privateKey","get_private_key","encodedPrivateKey","encodeRecoveryKey","free","bootstrapSecretStorage","authUploadDeviceSigningKeys","createSecretStorageKey","keyBackupInfo","crossSigningPrivateKeys","appCallbacks","assign","inStorage","isStoredInSecretStorage","getId","checkOwnCrossSigningTrust","saveCrossSigningKeys","name","resetCrossSigningKeys","CrossSigningLevel","MASTER","hasSecretStorageKey","newKeyId","opts","auth_data","public_key","private_key_salt","private_key_iterations","addSecretStorageKey","SECRET_STORAGE_ALGORITHM_V1","storePassthrough","backupSigStatus","checkKeyBackup","trustInfo","usable","console","signObject","_http","authedRequest","undefined","version","prefix","PREFIX_UNSTABLE","keyOptions","setDefaultSecretStorageKeyId","length","signKey","storeInSecretStorage","keyID","addKey","hasKey","storeSecret","secret","store","getSecret","get","isSecretStored","checkKey","isStored","requestSecret","devices","request","getDefaultSecretStorageKeyId","getDefaultKeyId","k","setDefaultKeyId","checkSecretStoragePrivateKey","expectedPublicKey","gotPubkey","checkCrossSigningPrivateKey","signing","PkSigning","init_with_seed","level","func","info","oldKeys","resetKeys","_signObject","master","entries","authDict","uploadDeviceSigningKeys","storeCrossSigningKeys","e","error","emit","_afterCrossSigningLocalKeyChange","device","getStoredDevice","signedDevice","signDevice","uploadKeySignatures","users","crossSigningInfo","upgradeInfo","_checkForDeviceVerificationUpgrade","fromStorage","shouldUpgradeCb","shouldUpgradeDeviceVerifications","usersToUpgrade","setDeviceVerified","trustLevel","checkUserTrust","firstUse","deviceIds","_checkForValidDeviceSignature","map","signatures","signame","split","verifySignature","push","getCrossSigningId","getStoredCrossSigningForUser","userCrossSigning","UserTrustLevel","checkDeviceTrust","trustedLocally","isVerified","DeviceTrustLevel","newCrossSigning","seenPubkey","currentPubkey","changed","_checkDeviceVerifications","masterChanged","ret","Error","oldSelfSigningId","oldUserSigningId","keySignatures","user_signing","includes","isGuest","getKeyBackupVersion","httpStatus","isKeyBackupTrusted","enableKeyBackup","disableKeyBackup","setTrustedBackupPubKey","trustedPubKey","setLocalTrustedBackupPubKey","trusted_locally","sigs","trustedPubkey","getLocalTrustedBackupPubKey","mySigs","keyId","keyIdParts","sigInfo","crossSigningId","valid","warning","deviceTrust","getFingerprint","some","s","enableLazyLoading","registerEventHandlers","eventEmitter","crypto","event","member","oldMembership","_onRoomMembership","_onToDeviceEvent","_onTimelineEvent","start","stop","getOlmVersion","getDeviceEd25519Key","setGlobalBlacklistUnverifiedDevices","getGlobalBlacklistUnverifiedDevices","setGlobalErrorOnUnknownDevices","getGlobalErrorOnUnknownDevices","uploadDeviceKeys","deviceKeys","device_id","user_id","then","uploadKeysRequest","device_keys","updateOneTimeKeyCount","currentCount","isFinite","_oneTimeKeyCount","TypeError","_maybeUploadOneTimeKeys","uploadPeriod","maxKeysPerCycle","now","Date","maxOneTimeKeys","maxNumberOfOneTimeKeys","keyLimit","Math","floor","uploadLoop","keyCount","Promise","resolve","keysThisLoop","min","generateOneTimeKeys","_uploadOneTimeKeys","res","one_time_key_counts","signed_curve25519","catch","stack","finally","oneTimeKeys","getOneTimeKeys","oneTimeJson","promises","curve25519","hasOwnProperty","all","one_time_keys","markKeysAsPublished","downloadKeys","userIds","forceDownload","getStoredDevicesForUser","saveDeviceList","delay","setDeviceVerification","blocked","xsk","signUser","dev","verificationStatus","UNVERIFIED","BLOCKED","knownStatus","deviceObj","requestVerificationDM","roomId","methods","channel","InRoomChannel","_requestVerificationWithChannel","waitForVerifier","acceptVerificationDM","validateEvent","sender","getSender","requestsByTxnId","transactionId","getTransactionId","beginKeyVerification","requestVerification","ToDeviceChannel","requestsMap","VerificationRequest","sendRequest","makeTransactionId","getOlmSessionsForUser","result","j","deviceKey","getIdentityKey","sessions","getSessionInfoForDevice","deviceIdKey","getEventSenderDeviceInfo","senderKey","getSenderKey","getWireContent","forwardingChain","getForwardingCurve25519KeyChain","getDeviceByIdentityKey","claimedKey","getClaimedEd25519Key","warn","forceDiscardSession","alg","setRoomEncryption","config","inhibitDeviceQuery","existingConfig","getRoomEncryption","JSON","stringify","existingAlg","storeConfigPromise","AlgClass","ENCRYPTION_CLASSES","olmDevice","trackRoomDevices","refreshOutdatedDeviceLists","trackMembers","room","getRoom","members","getEncryptionTargetMembers","forEach","m","promise","ensureOlmSessionsForUsers","devicesByUser","i","ensureOlmSessionsForDevices","exportRoomKeys","exportedSessions","STORE_INBOUND_GROUP_SESSIONS","getAllEndToEndInboundGroupSessions","sess","exportInboundGroupSession","sessionId","sessionData","first_known_index","MEGOLM_ALGORITHM","importRoomKeys","room_id","_getRoomDecryptor","importRoomKey","scheduleKeyBackupSend","maxDelay","random","sleep","numFailures","numBackedUp","_backupPendingKeys","err","data","errcode","pow","limit","getSessionsNeedingBackup","remaining","countSessionsNeedingBackup","session","session_id","firstKnownIndex","encrypted","encrypt","forwardedCount","forwarding_curve25519_key_chain","first_message_index","forwarded_count","is_verified","session_data","sendKeyBackup","rooms","unmarkSessionsNeedingBackup","backupGroupSession","forwardingCurve25519KeyChain","sessionKey","keysClaimed","exportFormat","markSessionsNeedingBackup","scheduleAllGroupSessionsForBackup","flagAllGroupSessionsForBackup","STORE_BACKUP","encryptEvent","getRoomId","content","getContent","mRelatesTo","encryptedContent","encryptMessage","getType","makeEncrypted","decryptEvent","isRedacted","clearEvent","handleDeviceListChanges","syncData","syncDeviceLists","oldSyncToken","_evalDeviceListChanges","requestRoomKey","requestBody","recipients","resend","sendRoomKeyRequest","cancelRoomKeyRequest","onCryptoEvent","onSyncWillProcess","stopTrackingAllDeviceLists","onSyncCompleted","nextSyncToken","setSyncToken","lastKnownSyncToken","catchingUp","_processReceivedRoomKeyRequests","deviceLists","Array","isArray","u","invalidateUserDeviceList","left","e2eUserIds","Set","_getTrackedE2eUsers","has","stopTrackingDeviceList","_getTrackedE2eRooms","getRooms","filter","myMembership","getMyMembership","_onRoomKeyEvent","_onRoomKeyRequestEvent","_onRequestReceived","_onSecretReceived","_onRoomKeyWithheldEvent","transaction_id","_onKeyVerificationMessage","msgtype","_onToDeviceBadEncrypted","isBeingDecrypted","once","ev","onRoomKeyEvent","code","sender_key","reason","onRoomKeyWithheldEvent","roomDecryptors","_getRoomDecryptors","decryptor","retryDecryptionFromSender","createRequest","canCreateRequest","getEventType","from_device","_handleVerificationEvent","isNewRequest","hadVerifier","verifier","handleEvent","pending","delete","size","initiatedByMe","retryDecryption","lastNewSessionForced","debug","recordSessionProblem","OLM_ALGORITHM","ciphertext","encryptMessageForDevice","sendToDevice","requestsToResend","getOutgoingSentRoomKeyRequest","keyReq","membership","shouldEncryptForInvitedMembers","onRoomMembership","action","req","IncomingRoomKeyRequest","IncomingRoomKeyRequestCancellation","requests","cancellations","_processReceivedRoomKeyRequest","cancellation","_processReceivedRoomKeyRequestCancellation","body","requestId","encryptor","reshareKeyWithDevice","hasKeysForKeyRequest","share","shareKeysWithDevice","decryptors","DecryptionError","d","values","obj","unsigned","sign","default","constructor","requesting_device_id","request_id"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isCryptoAvailable = isCryptoAvailable;\nexports.Crypto = Crypto;\nexports.verificationMethods = void 0;\n\nvar _anotherJson = _interopRequireDefault(require(\"another-json\"));\n\nvar _events = require(\"events\");\n\nvar _ReEmitter = require(\"../ReEmitter\");\n\nvar _logger = require(\"../logger\");\n\nvar utils = _interopRequireWildcard(require(\"../utils\"));\n\nvar _OlmDevice = require(\"./OlmDevice\");\n\nvar olmlib = _interopRequireWildcard(require(\"./olmlib\"));\n\nvar _DeviceList = require(\"./DeviceList\");\n\nvar _deviceinfo = require(\"./deviceinfo\");\n\nvar algorithms = _interopRequireWildcard(require(\"./algorithms\"));\n\nvar _CrossSigning = require(\"./CrossSigning\");\n\nvar _SecretStorage = require(\"./SecretStorage\");\n\nvar _OutgoingRoomKeyRequestManager = require(\"./OutgoingRoomKeyRequestManager\");\n\nvar _indexeddbCryptoStore = require(\"./store/indexeddb-crypto-store\");\n\nvar _QRCode = require(\"./verification/QRCode\");\n\nvar _SAS = require(\"./verification/SAS\");\n\nvar _key_passphrase = require(\"./key_passphrase\");\n\nvar _recoverykey = require(\"./recoverykey\");\n\nvar _VerificationRequest = require(\"./verification/request/VerificationRequest\");\n\nvar _InRoomChannel = require(\"./verification/request/InRoomChannel\");\n\nvar _ToDeviceChannel = require(\"./verification/request/ToDeviceChannel\");\n\nvar httpApi = _interopRequireWildcard(require(\"../http-api\"));\n\n/*\nCopyright 2016 OpenMarket Ltd\nCopyright 2017 Vector Creations Ltd\nCopyright 2018-2019 New Vector Ltd\nCopyright 2019-2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * @module crypto\n */\nconst DeviceVerification = _deviceinfo.DeviceInfo.DeviceVerification;\nconst defaultVerificationMethods = {\n  [_QRCode.ScanQRCode.NAME]: _QRCode.ScanQRCode,\n  [_QRCode.ShowQRCode.NAME]: _QRCode.ShowQRCode,\n  [_SAS.SAS.NAME]: _SAS.SAS\n};\n/**\n * verification method names\n */\n\nconst verificationMethods = {\n  QR_CODE_SCAN: _QRCode.ScanQRCode.NAME,\n  QR_CODE_SHOW: _QRCode.ShowQRCode.NAME,\n  SAS: _SAS.SAS.NAME\n};\nexports.verificationMethods = verificationMethods;\n\nfunction isCryptoAvailable() {\n  return Boolean(global.Olm);\n}\n\nconst MIN_FORCE_SESSION_INTERVAL_MS = 60 * 60 * 1000;\nconst KEY_BACKUP_KEYS_PER_REQUEST = 200;\n/**\n * Cryptography bits\n *\n * This module is internal to the js-sdk; the public API is via MatrixClient.\n *\n * @constructor\n * @alias module:crypto\n *\n * @internal\n *\n * @param {module:base-apis~MatrixBaseApis} baseApis base matrix api interface\n *\n * @param {module:store/session/webstorage~WebStorageSessionStore} sessionStore\n *    Store to be used for end-to-end crypto session data\n *\n * @param {string} userId The user ID for the local user\n *\n * @param {string} deviceId The identifier for this device.\n *\n * @param {Object} clientStore the MatrixClient data store.\n *\n * @param {module:crypto/store/base~CryptoStore} cryptoStore\n *    storage for the crypto layer.\n *\n * @param {RoomList} roomList An initialised RoomList object\n *\n * @param {Array} verificationMethods Array of verification methods to use.\n *    Each element can either be a string from MatrixClient.verificationMethods\n *    or a class that implements a verification method.\n */\n\nfunction Crypto(baseApis, sessionStore, userId, deviceId, clientStore, cryptoStore, roomList, verificationMethods) {\n  this._onDeviceListUserCrossSigningUpdated = this._onDeviceListUserCrossSigningUpdated.bind(this);\n  this._reEmitter = new _ReEmitter.ReEmitter(this);\n  this._baseApis = baseApis;\n  this._sessionStore = sessionStore;\n  this._userId = userId;\n  this._deviceId = deviceId;\n  this._clientStore = clientStore;\n  this._cryptoStore = cryptoStore;\n  this._roomList = roomList;\n  this._verificationMethods = new Map();\n\n  if (verificationMethods) {\n    for (const method of verificationMethods) {\n      if (typeof method === \"string\") {\n        if (defaultVerificationMethods[method]) {\n          this._verificationMethods.set(method, defaultVerificationMethods[method]);\n        }\n      } else if (method.NAME) {\n        this._verificationMethods.set(method.NAME, method);\n      }\n    }\n  } // track whether this device's megolm keys are being backed up incrementally\n  // to the server or not.\n  // XXX: this should probably have a single source of truth from OlmAccount\n\n\n  this.backupInfo = null; // The info dict from /room_keys/version\n\n  this.backupKey = null; // The encryption key object\n\n  this._checkedForBackup = false; // Have we checked the server for a backup we can use?\n\n  this._sendingBackups = false; // Are we currently sending backups?\n\n  this._olmDevice = new _OlmDevice.OlmDevice(cryptoStore);\n  this._deviceList = new _DeviceList.DeviceList(baseApis, cryptoStore, this._olmDevice); // XXX: This isn't removed at any point, but then none of the event listeners\n  // this class sets seem to be removed at any point... :/\n\n  this._deviceList.on('userCrossSigningUpdated', this._onDeviceListUserCrossSigningUpdated);\n\n  this._reEmitter.reEmit(this._deviceList, [\"crypto.devicesUpdated\"]); // the last time we did a check for the number of one-time-keys on the\n  // server.\n\n\n  this._lastOneTimeKeyCheck = null;\n  this._oneTimeKeyCheckInProgress = false; // EncryptionAlgorithm instance for each room\n\n  this._roomEncryptors = {}; // map from algorithm to DecryptionAlgorithm instance, for each room\n\n  this._roomDecryptors = {};\n  this._supportedAlgorithms = utils.keys(algorithms.DECRYPTION_CLASSES);\n  this._deviceKeys = {};\n  this._globalBlacklistUnverifiedDevices = false;\n  this._globalErrorOnUnknownDevices = true;\n  this._outgoingRoomKeyRequestManager = new _OutgoingRoomKeyRequestManager.OutgoingRoomKeyRequestManager(baseApis, this._deviceId, this._cryptoStore); // list of IncomingRoomKeyRequests/IncomingRoomKeyRequestCancellations\n  // we received in the current sync.\n\n  this._receivedRoomKeyRequests = [];\n  this._receivedRoomKeyRequestCancellations = []; // true if we are currently processing received room key requests\n\n  this._processingRoomKeyRequests = false; // controls whether device tracking is delayed\n  // until calling encryptEvent or trackRoomDevices,\n  // or done immediately upon enabling room encryption.\n\n  this._lazyLoadMembers = false; // in case _lazyLoadMembers is true,\n  // track if an initial tracking of all the room members\n  // has happened for a given room. This is delayed\n  // to avoid loading room members as long as possible.\n\n  this._roomDeviceTrackingState = {}; // The timestamp of the last time we forced establishment\n  // of a new session for each device, in milliseconds.\n  // {\n  //     userId: {\n  //         deviceId: 1234567890000,\n  //     },\n  // }\n\n  this._lastNewSessionForced = {};\n  this._toDeviceVerificationRequests = new Map();\n  this._inRoomVerificationRequests = new Map();\n  const cryptoCallbacks = this._baseApis._cryptoCallbacks || {};\n  this._crossSigningInfo = new _CrossSigning.CrossSigningInfo(userId, cryptoCallbacks);\n  this._secretStorage = new _SecretStorage.SecretStorage(baseApis, cryptoCallbacks, this._crossSigningInfo); // Assuming no app-supplied callback, default to getting from SSSS.\n\n  if (!cryptoCallbacks.getCrossSigningKey && cryptoCallbacks.getSecretStorageKey) {\n    cryptoCallbacks.getCrossSigningKey = async type => {\n      return _CrossSigning.CrossSigningInfo.getFromSecretStorage(type, this._secretStorage);\n    };\n  }\n}\n\nutils.inherits(Crypto, _events.EventEmitter);\n/**\n * Initialise the crypto module so that it is ready for use\n *\n * Returns a promise which resolves once the crypto module is ready for use.\n */\n\nCrypto.prototype.init = async function () {\n  _logger.logger.log(\"Crypto: initialising Olm...\");\n\n  await global.Olm.init();\n\n  _logger.logger.log(\"Crypto: initialising Olm device...\");\n\n  await this._olmDevice.init();\n\n  _logger.logger.log(\"Crypto: loading device list...\");\n\n  await this._deviceList.load(); // build our device keys: these will later be uploaded\n\n  this._deviceKeys[\"ed25519:\" + this._deviceId] = this._olmDevice.deviceEd25519Key;\n  this._deviceKeys[\"curve25519:\" + this._deviceId] = this._olmDevice.deviceCurve25519Key;\n\n  _logger.logger.log(\"Crypto: fetching own devices...\");\n\n  let myDevices = this._deviceList.getRawStoredDevicesForUser(this._userId);\n\n  if (!myDevices) {\n    myDevices = {};\n  }\n\n  if (!myDevices[this._deviceId]) {\n    // add our own deviceinfo to the cryptoStore\n    _logger.logger.log(\"Crypto: adding this device to the store...\");\n\n    const deviceInfo = {\n      keys: this._deviceKeys,\n      algorithms: this._supportedAlgorithms,\n      verified: DeviceVerification.VERIFIED,\n      known: true\n    };\n    myDevices[this._deviceId] = deviceInfo;\n\n    this._deviceList.storeDevicesForUser(this._userId, myDevices);\n\n    this._deviceList.saveIfDirty();\n  }\n\n  await this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], txn => {\n    this._cryptoStore.getCrossSigningKeys(txn, keys => {\n      if (keys) {\n        _logger.logger.log(\"Loaded cross-signing public keys from crypto store\");\n\n        this._crossSigningInfo.setKeys(keys);\n      }\n    });\n  }); // make sure we are keeping track of our own devices\n  // (this is important for key backups & things)\n\n  this._deviceList.startTrackingDeviceList(this._userId);\n\n  _logger.logger.log(\"Crypto: checking for key backup...\");\n\n  this._checkAndStartKeyBackup();\n};\n/**\n * Create a recovery key from a user-supplied passphrase.\n *\n * @param {string} password Passphrase string that can be entered by the user\n *     when restoring the backup as an alternative to entering the recovery key.\n *     Optional.\n * @returns {Promise<Array>} Array with public key metadata, encoded private\n *     recovery key which should be disposed of after displaying to the user,\n *     and raw private key to avoid round tripping if needed.\n */\n\n\nCrypto.prototype.createRecoveryKeyFromPassphrase = async function (password) {\n  const decryption = new global.Olm.PkDecryption();\n\n  try {\n    const keyInfo = {};\n\n    if (password) {\n      const derivation = await (0, _key_passphrase.keyFromPassphrase)(password);\n      keyInfo.passphrase = {\n        algorithm: \"m.pbkdf2\",\n        iterations: derivation.iterations,\n        salt: derivation.salt\n      };\n      keyInfo.pubkey = decryption.init_with_private_key(derivation.key);\n    } else {\n      keyInfo.pubkey = decryption.generate_key();\n    }\n\n    const privateKey = decryption.get_private_key();\n    const encodedPrivateKey = (0, _recoverykey.encodeRecoveryKey)(privateKey);\n    return [keyInfo, encodedPrivateKey, privateKey];\n  } finally {\n    if (decryption) decryption.free();\n  }\n};\n/**\n * Bootstrap Secure Secret Storage if needed by creating a default key and\n * signing it with the cross-signing master key. If everything is already set\n * up, then no changes are made, so this is safe to run to ensure secret storage\n * is ready for use.\n *\n * @param {function} [opts.authUploadDeviceSigningKeys] Optional. Function\n * called to await an interactive auth flow when uploading device signing keys.\n * Args:\n *     {function} A function that makes the request requiring auth. Receives the\n *     auth data as an object.\n * @param {function} [opts.createSecretStorageKey] Optional. Function\n * called to await a secret storage key creation flow.\n * @param {object} [opts.keyBackupInfo] The current key backup object. If passed,\n * the passphrase and recovery key from this backup will be used.\n * Returns:\n *     {Promise} A promise which resolves to key creation data for\n *     SecretStorage#addKey: an object with `passphrase` and/or `pubkey` fields.\n */\n\n\nCrypto.prototype.bootstrapSecretStorage = async function ({\n  authUploadDeviceSigningKeys,\n  createSecretStorageKey = async () => {},\n  keyBackupInfo\n} = {}) {\n  _logger.logger.log(\"Bootstrapping Secure Secret Storage\"); // Create cross-signing keys if they don't exist, as we want to sign the SSSS default\n  // key with the cross-signing master key. The cross-signing master key is also used\n  // to verify the signature on the SSSS default key when adding secrets, so we\n  // effectively need it for both reading and writing secrets.\n\n\n  let crossSigningPrivateKeys = {}; // If we happen to reset cross-signing keys here, then we want access to the\n  // cross-signing private keys, but only for the scope of this method, so we\n  // use temporary callbacks to weave them through the various APIs.\n\n  const appCallbacks = Object.assign({}, this._baseApis._cryptoCallbacks);\n\n  try {\n    const inStorage = await this._crossSigningInfo.isStoredInSecretStorage(this._secretStorage);\n\n    if (!this._crossSigningInfo.getId() || !inStorage) {\n      _logger.logger.log(\"Cross-signing public and/or private keys not found, \" + \"checking secret storage for private keys\");\n\n      if (inStorage) {\n        _logger.logger.log(\"Cross-signing private keys found in secret storage\");\n\n        await this.checkOwnCrossSigningTrust();\n      } else {\n        _logger.logger.log(\"Cross-signing private keys not found in secret storage, \" + \"creating new keys\");\n\n        this._baseApis._cryptoCallbacks.saveCrossSigningKeys = keys => crossSigningPrivateKeys = keys;\n\n        this._baseApis._cryptoCallbacks.getCrossSigningKey = name => crossSigningPrivateKeys[name];\n\n        await this.resetCrossSigningKeys(_CrossSigning.CrossSigningLevel.MASTER, {\n          authUploadDeviceSigningKeys\n        });\n      }\n    } else {\n      _logger.logger.log(\"Cross signing keys are present in secret storage\");\n    } // Check if Secure Secret Storage has a default key. If we don't have one, create\n    // the default key (which will also be signed by the cross-signing master key).\n\n\n    if (!(await this.hasSecretStorageKey())) {\n      let newKeyId;\n\n      if (keyBackupInfo) {\n        _logger.logger.log(\"Secret storage default key not found, using key backup key\");\n\n        const opts = {\n          pubkey: keyBackupInfo.auth_data.public_key\n        };\n\n        if (keyBackupInfo.auth_data.private_key_salt && keyBackupInfo.auth_data.private_key_iterations) {\n          opts.passphrase = {\n            algorithm: \"m.pbkdf2\",\n            iterations: keyBackupInfo.auth_data.private_key_iterations,\n            salt: keyBackupInfo.auth_data.private_key_salt\n          };\n        }\n\n        newKeyId = await this.addSecretStorageKey(_SecretStorage.SECRET_STORAGE_ALGORITHM_V1, opts); // Add an entry for the backup key in SSSS as a 'passthrough' key\n        // (ie. the secret is the key itself).\n\n        this._secretStorage.storePassthrough('m.megolm_backup.v1', newKeyId); // if this key backup is trusted, sign it with the cross signing key\n        // so the key backup can be trusted via cross-signing.\n\n\n        const backupSigStatus = await this.checkKeyBackup(keyBackupInfo);\n\n        if (backupSigStatus.trustInfo.usable) {\n          console.log(\"Adding cross signing signature to key backup\");\n          await this._crossSigningInfo.signObject(keyBackupInfo.auth_data, \"master\");\n          await this._baseApis._http.authedRequest(undefined, \"PUT\", \"/room_keys/version/\" + keyBackupInfo.version, undefined, keyBackupInfo, {\n            prefix: httpApi.PREFIX_UNSTABLE\n          });\n        } else {\n          console.log(\"Key backup is NOT TRUSTED: NOT adding cross signing signature\");\n        }\n      } else {\n        _logger.logger.log(\"Secret storage default key not found, creating new key\");\n\n        const keyOptions = await createSecretStorageKey();\n        newKeyId = await this.addSecretStorageKey(_SecretStorage.SECRET_STORAGE_ALGORITHM_V1, keyOptions);\n      }\n\n      await this.setDefaultSecretStorageKeyId(newKeyId);\n    } else {\n      _logger.logger.log(\"Have secret storage key\");\n    } // If cross-signing keys were reset, store them in Secure Secret Storage.\n    // This is done in a separate step so we can ensure secret storage has its\n    // own key first.\n    // XXX: We need to think about how to re-do these steps if they fail.\n    // See also https://github.com/vector-im/riot-web/issues/11635\n\n\n    if (Object.keys(crossSigningPrivateKeys).length) {\n      _logger.logger.log(\"Storing cross-signing private keys in secret storage\"); // SSSS expects its keys to be signed by cross-signing master key.\n      // Since we have just reset cross-signing keys, we need to re-sign the\n      // SSSS default key with the new cross-signing master key so that the\n      // following storage step can proceed.\n\n\n      await this._secretStorage.signKey(); // Assuming no app-supplied callback, default to storing in SSSS.\n\n      if (!appCallbacks.saveCrossSigningKeys) {\n        await _CrossSigning.CrossSigningInfo.storeInSecretStorage(crossSigningPrivateKeys, this._secretStorage);\n      }\n    }\n  } finally {\n    this._baseApis._cryptoCallbacks = appCallbacks;\n  }\n\n  _logger.logger.log(\"Secure Secret Storage ready\");\n};\n\nCrypto.prototype.addSecretStorageKey = function (algorithm, opts, keyID) {\n  return this._secretStorage.addKey(algorithm, opts, keyID);\n};\n\nCrypto.prototype.hasSecretStorageKey = function (keyID) {\n  return this._secretStorage.hasKey(keyID);\n};\n\nCrypto.prototype.storeSecret = function (name, secret, keys) {\n  return this._secretStorage.store(name, secret, keys);\n};\n\nCrypto.prototype.getSecret = function (name) {\n  return this._secretStorage.get(name);\n};\n\nCrypto.prototype.isSecretStored = function (name, checkKey) {\n  return this._secretStorage.isStored(name, checkKey);\n};\n\nCrypto.prototype.requestSecret = function (name, devices) {\n  if (!devices) {\n    devices = Object.keys(this._deviceList.getRawStoredDevicesForUser(this._userId));\n  }\n\n  return this._secretStorage.request(name, devices);\n};\n\nCrypto.prototype.getDefaultSecretStorageKeyId = function () {\n  return this._secretStorage.getDefaultKeyId();\n};\n\nCrypto.prototype.setDefaultSecretStorageKeyId = function (k) {\n  return this._secretStorage.setDefaultKeyId(k);\n};\n/**\n * Checks that a given secret storage private key matches a given public key.\n * This can be used by the getSecretStorageKey callback to verify that the\n * private key it is about to supply is the one that was requested.\n *\n * @param {Uint8Array} privateKey The private key\n * @param {string} expectedPublicKey The public key\n * @returns {boolean} true if the key matches, otherwise false\n */\n\n\nCrypto.prototype.checkSecretStoragePrivateKey = function (privateKey, expectedPublicKey) {\n  let decryption = null;\n\n  try {\n    decryption = new global.Olm.PkDecryption();\n    const gotPubkey = decryption.init_with_private_key(privateKey); // make sure it agrees with the given pubkey\n\n    return gotPubkey === expectedPublicKey;\n  } finally {\n    if (decryption) decryption.free();\n  }\n};\n/**\n * Checks that a given cross-signing private key matches a given public key.\n * This can be used by the getCrossSigningKey callback to verify that the\n * private key it is about to supply is the one that was requested.\n *\n * @param {Uint8Array} privateKey The private key\n * @param {string} expectedPublicKey The public key\n * @returns {boolean} true if the key matches, otherwise false\n */\n\n\nCrypto.prototype.checkCrossSigningPrivateKey = function (privateKey, expectedPublicKey) {\n  let signing = null;\n\n  try {\n    signing = new global.Olm.PkSigning();\n    const gotPubkey = signing.init_with_seed(privateKey); // make sure it agrees with the given pubkey\n\n    return gotPubkey === expectedPublicKey;\n  } finally {\n    if (signing) signing.free();\n  }\n};\n/**\n * Generate new cross-signing keys.\n *\n * @param {CrossSigningLevel} [level] the level of cross-signing to reset.  New\n * keys will be created for the given level and below.  Defaults to\n * regenerating all keys.\n * @param {function} [opts.authUploadDeviceSigningKeys] Optional. Function\n * called to await an interactive auth flow when uploading device signing keys.\n * Args:\n *     {function} A function that makes the request requiring auth. Receives the\n *     auth data as an object.\n */\n\n\nCrypto.prototype.resetCrossSigningKeys = async function (level, {\n  authUploadDeviceSigningKeys = async func => await func()\n} = {}) {\n  _logger.logger.info(`Resetting cross-signing keys at level ${level}`); // Copy old keys (usually empty) in case we need to revert\n\n\n  const oldKeys = Object.assign({}, this._crossSigningInfo.keys);\n\n  try {\n    await this._crossSigningInfo.resetKeys(level);\n    await this._signObject(this._crossSigningInfo.keys.master); // send keys to server first before storing as trusted locally\n    // to ensure upload succeeds\n\n    const keys = {};\n\n    for (const [name, key] of Object.entries(this._crossSigningInfo.keys)) {\n      keys[name + \"_key\"] = key;\n    }\n\n    await authUploadDeviceSigningKeys(async authDict => {\n      await this._baseApis.uploadDeviceSigningKeys(authDict, keys);\n    }); // write a copy locally so we know these are trusted keys\n\n    await this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], txn => {\n      this._cryptoStore.storeCrossSigningKeys(txn, this._crossSigningInfo.keys);\n    });\n  } catch (e) {\n    // If anything failed here, revert the keys so we know to try again from the start\n    // next time.\n    _logger.logger.error(\"Resetting cross-signing keys failed, revert to previous keys\", e);\n\n    this._crossSigningInfo.keys = oldKeys;\n    throw e;\n  }\n\n  this._baseApis.emit(\"crossSigning.keysChanged\", {});\n\n  await this._afterCrossSigningLocalKeyChange();\n\n  _logger.logger.info(\"Cross-signing key reset complete\");\n};\n/**\n * Run various follow-up actions after cross-signing keys have changed locally\n * (either by resetting the keys for the account or by getting them from secret\n * storage), such as signing the current device, upgrading device\n * verifications, etc.\n */\n\n\nCrypto.prototype._afterCrossSigningLocalKeyChange = async function () {\n  // sign the current device with the new key, and upload to the server\n  const device = this._deviceList.getStoredDevice(this._userId, this._deviceId);\n\n  const signedDevice = await this._crossSigningInfo.signDevice(this._userId, device);\n  await this._baseApis.uploadKeySignatures({\n    [this._userId]: {\n      [this._deviceId]: signedDevice\n    }\n  }); // check all users for signatures\n  // FIXME: do this in batches\n\n  const users = {};\n\n  for (const [userId, crossSigningInfo] of Object.entries(this._deviceList._crossSigningInfo)) {\n    const upgradeInfo = await this._checkForDeviceVerificationUpgrade(userId, _CrossSigning.CrossSigningInfo.fromStorage(crossSigningInfo, userId));\n\n    if (upgradeInfo) {\n      users[userId] = upgradeInfo;\n    }\n  }\n\n  const shouldUpgradeCb = this._baseApis._cryptoCallbacks.shouldUpgradeDeviceVerifications;\n\n  if (Object.keys(users).length > 0 && shouldUpgradeCb) {\n    try {\n      const usersToUpgrade = await shouldUpgradeCb({\n        users: users\n      });\n\n      if (usersToUpgrade) {\n        for (const userId of usersToUpgrade) {\n          if (userId in users) {\n            await this._baseApis.setDeviceVerified(userId, users[userId].crossSigningInfo.getId());\n          }\n        }\n      }\n    } catch (e) {\n      _logger.logger.log(\"shouldUpgradeDeviceVerifications threw an error: not upgrading\", e);\n    }\n  }\n};\n/**\n * Check if a user's cross-signing key is a candidate for upgrading from device\n * verification.\n *\n * @param {string} userId the user whose cross-signing information is to be checked\n * @param {object} crossSigningInfo the cross-signing information to check\n */\n\n\nCrypto.prototype._checkForDeviceVerificationUpgrade = async function (userId, crossSigningInfo) {\n  // only upgrade if this is the first cross-signing key that we've seen for\n  // them, and if their cross-signing key isn't already verified\n  const trustLevel = this._crossSigningInfo.checkUserTrust(crossSigningInfo);\n\n  if (crossSigningInfo.firstUse && !trustLevel.verified) {\n    const devices = this._deviceList.getRawStoredDevicesForUser(userId);\n\n    const deviceIds = await this._checkForValidDeviceSignature(userId, crossSigningInfo.keys.master, devices);\n\n    if (deviceIds.length) {\n      return {\n        devices: deviceIds.map(deviceId => _deviceinfo.DeviceInfo.fromStorage(devices[deviceId], deviceId)),\n        crossSigningInfo\n      };\n    }\n  }\n};\n/**\n * Check if the cross-signing key is signed by a verified device.\n *\n * @param {string} userId the user ID whose key is being checked\n * @param {object} key the key that is being checked\n * @param {object} devices the user's devices.  Should be a map from device ID\n *     to device info\n */\n\n\nCrypto.prototype._checkForValidDeviceSignature = async function (userId, key, devices) {\n  const deviceIds = [];\n\n  if (devices && key.signatures && key.signatures[userId]) {\n    for (const signame of Object.keys(key.signatures[userId])) {\n      const [, deviceId] = signame.split(':', 2);\n\n      if (deviceId in devices && devices[deviceId].verified === DeviceVerification.VERIFIED) {\n        try {\n          await olmlib.verifySignature(this._olmDevice, key, userId, deviceId, devices[deviceId].keys[signame]);\n          deviceIds.push(deviceId);\n        } catch (e) {}\n      }\n    }\n  }\n\n  return deviceIds;\n};\n/**\n * Get the user's cross-signing key ID.\n *\n * @param {string} [type=master] The type of key to get the ID of.  One of\n *     \"master\", \"self_signing\", or \"user_signing\".  Defaults to \"master\".\n *\n * @returns {string} the key ID\n */\n\n\nCrypto.prototype.getCrossSigningId = function (type) {\n  return this._crossSigningInfo.getId(type);\n};\n/**\n * Get the cross signing information for a given user.\n *\n * @param {string} userId the user ID to get the cross-signing info for.\n *\n * @returns {CrossSigningInfo} the cross signing informmation for the user.\n */\n\n\nCrypto.prototype.getStoredCrossSigningForUser = function (userId) {\n  return this._deviceList.getStoredCrossSigningForUser(userId);\n};\n/**\n * Check whether a given user is trusted.\n *\n * @param {string} userId The ID of the user to check.\n *\n * @returns {UserTrustLevel}\n */\n\n\nCrypto.prototype.checkUserTrust = function (userId) {\n  const userCrossSigning = this._deviceList.getStoredCrossSigningForUser(userId);\n\n  if (!userCrossSigning) {\n    return new _CrossSigning.UserTrustLevel(false, false);\n  }\n\n  return this._crossSigningInfo.checkUserTrust(userCrossSigning);\n};\n/**\n * Check whether a given device is trusted.\n *\n * @param {string} userId The ID of the user whose devices is to be checked.\n * @param {string} deviceId The ID of the device to check\n *\n * @returns {DeviceTrustLevel}\n */\n\n\nCrypto.prototype.checkDeviceTrust = function (userId, deviceId) {\n  const device = this._deviceList.getStoredDevice(userId, deviceId);\n\n  const trustedLocally = device && device.isVerified();\n\n  const userCrossSigning = this._deviceList.getStoredCrossSigningForUser(userId);\n\n  if (device && userCrossSigning) {\n    return this._crossSigningInfo.checkDeviceTrust(userCrossSigning, device, trustedLocally);\n  } else {\n    return new _CrossSigning.DeviceTrustLevel(false, false, trustedLocally);\n  }\n};\n/*\n * Event handler for DeviceList's userNewDevices event\n */\n\n\nCrypto.prototype._onDeviceListUserCrossSigningUpdated = async function (userId) {\n  if (userId === this._userId) {\n    // An update to our own cross-signing key.\n    // Get the new key first:\n    const newCrossSigning = this._deviceList.getStoredCrossSigningForUser(userId);\n\n    const seenPubkey = newCrossSigning ? newCrossSigning.getId() : null;\n\n    const currentPubkey = this._crossSigningInfo.getId();\n\n    const changed = currentPubkey !== seenPubkey;\n\n    if (currentPubkey && seenPubkey && !changed) {\n      // If it's not changed, just make sure everything is up to date\n      await this.checkOwnCrossSigningTrust();\n    } else {\n      this.emit(\"crossSigning.keysChanged\", {}); // We'll now be in a state where cross-signing on the account is not trusted\n      // because our locally stored cross-signing keys will not match the ones\n      // on the server for our account. The app must call checkOwnCrossSigningTrust()\n      // to fix this.\n      // XXX: Do we need to do something to emit events saying every device has become\n      // untrusted?\n    }\n  } else {\n    await this._checkDeviceVerifications(userId);\n    this.emit(\"userTrustStatusChanged\", userId, this.checkUserTrust(userId));\n  }\n};\n/**\n * Check the copy of our cross-signing key that we have in the device list and\n * see if we can get the private key. If so, mark it as trusted.\n */\n\n\nCrypto.prototype.checkOwnCrossSigningTrust = async function () {\n  const userId = this._userId; // If we see an update to our own master key, check it against the master\n  // key we have and, if it matches, mark it as verified\n  // First, get the new cross-signing info\n\n  const newCrossSigning = this._deviceList.getStoredCrossSigningForUser(userId);\n\n  if (!newCrossSigning) {\n    _logger.logger.error(\"Got cross-signing update event for user \" + userId + \" but no new cross-signing information found!\");\n\n    return;\n  }\n\n  const seenPubkey = newCrossSigning.getId();\n  const masterChanged = this._crossSigningInfo.getId() !== seenPubkey;\n\n  if (masterChanged) {\n    // try to get the private key if the master key changed\n    _logger.logger.info(\"Got new master public key\", seenPubkey);\n\n    let signing = null;\n\n    try {\n      const ret = await this._crossSigningInfo.getCrossSigningKey('master', seenPubkey);\n      signing = ret[1];\n\n      if (!signing) {\n        throw new Error(\"Cross-signing master private key not available\");\n      }\n    } finally {\n      if (signing) signing.free();\n    }\n\n    _logger.logger.info(\"Got matching private key from callback for new public master key\");\n  }\n\n  const oldSelfSigningId = this._crossSigningInfo.getId(\"self_signing\");\n\n  const oldUserSigningId = this._crossSigningInfo.getId(\"user_signing\"); // Update the version of our keys in our cross-signing object and the local store\n\n\n  this._crossSigningInfo.setKeys(newCrossSigning.keys);\n\n  await this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], txn => {\n    this._cryptoStore.storeCrossSigningKeys(txn, this._crossSigningInfo.keys);\n  });\n  const keySignatures = {};\n\n  if (oldSelfSigningId !== newCrossSigning.getId(\"self_signing\")) {\n    _logger.logger.info(\"Got new self-signing key\", newCrossSigning.getId(\"self_signing\"));\n\n    const device = this._deviceList.getStoredDevice(this._userId, this._deviceId);\n\n    const signedDevice = await this._crossSigningInfo.signDevice(this._userId, device);\n    keySignatures[this._deviceId] = signedDevice;\n  }\n\n  if (oldUserSigningId !== newCrossSigning.getId(\"user_signing\")) {\n    _logger.logger.info(\"Got new user-signing key\", newCrossSigning.getId(\"user_signing\"));\n  }\n\n  if (masterChanged) {\n    await this._signObject(this._crossSigningInfo.keys.master);\n    keySignatures[this._crossSigningInfo.getId()] = this._crossSigningInfo.keys.master;\n  }\n\n  if (Object.keys(keySignatures).length) {\n    await this._baseApis.uploadKeySignatures({\n      [this._userId]: keySignatures\n    });\n  }\n\n  this.emit(\"userTrustStatusChanged\", userId, this.checkUserTrust(userId));\n\n  if (masterChanged) {\n    this._baseApis.emit(\"crossSigning.keysChanged\", {});\n\n    await this._afterCrossSigningLocalKeyChange();\n  } // Now we may be able to trust our key backup\n\n\n  await this.checkKeyBackup(); // FIXME: if we previously trusted the backup, should we automatically sign\n  // the backup with the new key (if not already signed)?\n};\n/**\n * Check if the master key is signed by a verified device, and if so, prompt\n * the application to mark it as verified.\n *\n * @param {string} userId the user ID whose key should be checked\n */\n\n\nCrypto.prototype._checkDeviceVerifications = async function (userId) {\n  if (this._crossSigningInfo.keys.user_signing) {\n    const crossSigningInfo = this._deviceList.getStoredCrossSigningForUser(userId);\n\n    if (crossSigningInfo) {\n      const upgradeInfo = await this._checkForDeviceVerificationUpgrade(userId, crossSigningInfo);\n      const shouldUpgradeCb = this._baseApis._cryptoCallbacks.shouldUpgradeDeviceVerifications;\n\n      if (upgradeInfo && shouldUpgradeCb) {\n        const usersToUpgrade = await shouldUpgradeCb({\n          users: {\n            [userId]: upgradeInfo\n          }\n        });\n\n        if (usersToUpgrade.includes(userId)) {\n          await this._baseApis.setDeviceVerified(userId, crossSigningInfo.getId());\n        }\n      }\n    }\n  }\n};\n/**\n * Check the server for an active key backup and\n * if one is present and has a valid signature from\n * one of the user's verified devices, start backing up\n * to it.\n */\n\n\nCrypto.prototype._checkAndStartKeyBackup = async function () {\n  _logger.logger.log(\"Checking key backup status...\");\n\n  if (this._baseApis.isGuest()) {\n    _logger.logger.log(\"Skipping key backup check since user is guest\");\n\n    this._checkedForBackup = true;\n    return null;\n  }\n\n  let backupInfo;\n\n  try {\n    backupInfo = await this._baseApis.getKeyBackupVersion();\n  } catch (e) {\n    _logger.logger.log(\"Error checking for active key backup\", e);\n\n    if (e.httpStatus / 100 === 4) {\n      // well that's told us. we won't try again.\n      this._checkedForBackup = true;\n    }\n\n    return null;\n  }\n\n  this._checkedForBackup = true;\n  const trustInfo = await this.isKeyBackupTrusted(backupInfo);\n\n  if (trustInfo.usable && !this.backupInfo) {\n    _logger.logger.log(\"Found usable key backup v\" + backupInfo.version + \": enabling key backups\");\n\n    this._baseApis.enableKeyBackup(backupInfo);\n  } else if (!trustInfo.usable && this.backupInfo) {\n    _logger.logger.log(\"No usable key backup: disabling key backup\");\n\n    this._baseApis.disableKeyBackup();\n  } else if (!trustInfo.usable && !this.backupInfo) {\n    _logger.logger.log(\"No usable key backup: not enabling key backup\");\n  } else if (trustInfo.usable && this.backupInfo) {\n    // may not be the same version: if not, we should switch\n    if (backupInfo.version !== this.backupInfo.version) {\n      _logger.logger.log(\"On backup version \" + this.backupInfo.version + \" but found \" + \"version \" + backupInfo.version + \": switching.\");\n\n      this._baseApis.disableKeyBackup();\n\n      this._baseApis.enableKeyBackup(backupInfo);\n    } else {\n      _logger.logger.log(\"Backup version \" + backupInfo.version + \" still current\");\n    }\n  }\n\n  return {\n    backupInfo,\n    trustInfo\n  };\n};\n\nCrypto.prototype.setTrustedBackupPubKey = async function (trustedPubKey) {\n  // This should be redundant post cross-signing is a thing, so just\n  // plonk it in localStorage for now.\n  this._sessionStore.setLocalTrustedBackupPubKey(trustedPubKey);\n\n  await this.checkKeyBackup();\n};\n/**\n * Forces a re-check of the key backup and enables/disables it\n * as appropriate.\n *\n * @return {Object} Object with backup info (as returned by\n *     getKeyBackupVersion) in backupInfo and\n *     trust information (as returned by isKeyBackupTrusted)\n *     in trustInfo.\n */\n\n\nCrypto.prototype.checkKeyBackup = async function () {\n  this._checkedForBackup = false;\n  return this._checkAndStartKeyBackup();\n};\n/**\n * @param {object} backupInfo key backup info dict from /room_keys/version\n * @return {object} {\n *     usable: [bool], // is the backup trusted, true iff there is a sig that is valid & from a trusted device\n *     sigs: [\n *         valid: [bool || null], // true: valid, false: invalid, null: cannot attempt validation\n *         deviceId: [string],\n *         device: [DeviceInfo || null],\n *     ]\n * }\n */\n\n\nCrypto.prototype.isKeyBackupTrusted = async function (backupInfo) {\n  const ret = {\n    usable: false,\n    trusted_locally: false,\n    sigs: []\n  };\n\n  if (!backupInfo || !backupInfo.algorithm || !backupInfo.auth_data || !backupInfo.auth_data.public_key || !backupInfo.auth_data.signatures) {\n    _logger.logger.info(\"Key backup is absent or missing required data\");\n\n    return ret;\n  }\n\n  const trustedPubkey = this._sessionStore.getLocalTrustedBackupPubKey();\n\n  if (backupInfo.auth_data.public_key === trustedPubkey) {\n    _logger.logger.info(\"Backup public key \" + trustedPubkey + \" is trusted locally\");\n\n    ret.trusted_locally = true;\n  }\n\n  const mySigs = backupInfo.auth_data.signatures[this._userId] || [];\n\n  for (const keyId of Object.keys(mySigs)) {\n    const keyIdParts = keyId.split(':');\n\n    if (keyIdParts[0] !== 'ed25519') {\n      _logger.logger.log(\"Ignoring unknown signature type: \" + keyIdParts[0]);\n\n      continue;\n    } // Could be a cross-signing master key, but just say this is the device\n    // ID for backwards compat\n\n\n    const sigInfo = {\n      deviceId: keyIdParts[1]\n    }; // first check to see if it's from our cross-signing key\n\n    const crossSigningId = this._crossSigningInfo.getId();\n\n    if (crossSigningId === sigInfo.deviceId) {\n      sigInfo.crossSigningId = true;\n\n      try {\n        await olmlib.verifySignature(this._olmDevice, backupInfo.auth_data, this._userId, sigInfo.deviceId, crossSigningId);\n        sigInfo.valid = true;\n      } catch (e) {\n        _logger.logger.warning(\"Bad signature from cross signing key \" + crossSigningId, e);\n\n        sigInfo.valid = false;\n      }\n\n      ret.sigs.push(sigInfo);\n      continue;\n    } // Now look for a sig from a device\n    // At some point this can probably go away and we'll just support\n    // it being signed by the cross-signing master key\n\n\n    const device = this._deviceList.getStoredDevice(this._userId, sigInfo.deviceId);\n\n    if (device) {\n      sigInfo.device = device;\n      sigInfo.deviceTrust = await this.checkDeviceTrust(this._userId, sigInfo.deviceId);\n\n      try {\n        await olmlib.verifySignature(this._olmDevice, backupInfo.auth_data, this._userId, device.deviceId, device.getFingerprint());\n        sigInfo.valid = true;\n      } catch (e) {\n        _logger.logger.info(\"Bad signature from key ID \" + keyId + \" userID \" + this._userId + \" device ID \" + device.deviceId + \" fingerprint: \" + device.getFingerprint(), backupInfo.auth_data, e);\n\n        sigInfo.valid = false;\n      }\n    } else {\n      sigInfo.valid = null; // Can't determine validity because we don't have the signing device\n\n      _logger.logger.info(\"Ignoring signature from unknown key \" + keyId);\n    }\n\n    ret.sigs.push(sigInfo);\n  }\n\n  ret.usable = ret.sigs.some(s => {\n    return s.valid && (s.device && s.deviceTrust.isVerified() || s.crossSigningId);\n  });\n  ret.usable |= ret.trusted_locally;\n  return ret;\n};\n/**\n */\n\n\nCrypto.prototype.enableLazyLoading = function () {\n  this._lazyLoadMembers = true;\n};\n/**\n * Tell the crypto module to register for MatrixClient events which it needs to\n * listen for\n *\n * @param {external:EventEmitter} eventEmitter event source where we can register\n *    for event notifications\n */\n\n\nCrypto.prototype.registerEventHandlers = function (eventEmitter) {\n  const crypto = this;\n  eventEmitter.on(\"RoomMember.membership\", function (event, member, oldMembership) {\n    try {\n      crypto._onRoomMembership(event, member, oldMembership);\n    } catch (e) {\n      _logger.logger.error(\"Error handling membership change:\", e);\n    }\n  });\n  eventEmitter.on(\"toDeviceEvent\", function (event) {\n    crypto._onToDeviceEvent(event);\n  });\n  eventEmitter.on(\"Room.timeline\", function (event) {\n    crypto._onTimelineEvent(event);\n  });\n  eventEmitter.on(\"Event.decrypted\", function (event) {\n    crypto._onTimelineEvent(event);\n  });\n};\n/** Start background processes related to crypto */\n\n\nCrypto.prototype.start = function () {\n  this._outgoingRoomKeyRequestManager.start();\n};\n/** Stop background processes related to crypto */\n\n\nCrypto.prototype.stop = function () {\n  this._outgoingRoomKeyRequestManager.stop();\n\n  this._deviceList.stop();\n};\n/**\n * @return {string} The version of Olm.\n */\n\n\nCrypto.getOlmVersion = function () {\n  return _OlmDevice.OlmDevice.getOlmVersion();\n};\n/**\n * Get the Ed25519 key for this device\n *\n * @return {string} base64-encoded ed25519 key.\n */\n\n\nCrypto.prototype.getDeviceEd25519Key = function () {\n  return this._olmDevice.deviceEd25519Key;\n};\n/**\n * Set the global override for whether the client should ever send encrypted\n * messages to unverified devices.  This provides the default for rooms which\n * do not specify a value.\n *\n * @param {boolean} value whether to blacklist all unverified devices by default\n */\n\n\nCrypto.prototype.setGlobalBlacklistUnverifiedDevices = function (value) {\n  this._globalBlacklistUnverifiedDevices = value;\n};\n/**\n * @return {boolean} whether to blacklist all unverified devices by default\n */\n\n\nCrypto.prototype.getGlobalBlacklistUnverifiedDevices = function () {\n  return this._globalBlacklistUnverifiedDevices;\n};\n/**\n * Set whether sendMessage in a room with unknown and unverified devices\n * should throw an error and not send them message. This has 'Global' for\n * symmertry with setGlobalBlacklistUnverifiedDevices but there is currently\n * no room-level equivalent for this setting.\n *\n * This API is currently UNSTABLE and may change or be removed without notice.\n *\n * @param {boolean} value whether error on unknown devices\n */\n\n\nCrypto.prototype.setGlobalErrorOnUnknownDevices = function (value) {\n  this._globalErrorOnUnknownDevices = value;\n};\n/**\n * @return {boolean} whether to error on unknown devices\n *\n * This API is currently UNSTABLE and may change or be removed without notice.\n */\n\n\nCrypto.prototype.getGlobalErrorOnUnknownDevices = function () {\n  return this._globalErrorOnUnknownDevices;\n};\n/**\n * Upload the device keys to the homeserver.\n * @return {object} A promise that will resolve when the keys are uploaded.\n */\n\n\nCrypto.prototype.uploadDeviceKeys = function () {\n  const crypto = this;\n  const userId = crypto._userId;\n  const deviceId = crypto._deviceId;\n  const deviceKeys = {\n    algorithms: crypto._supportedAlgorithms,\n    device_id: deviceId,\n    keys: crypto._deviceKeys,\n    user_id: userId\n  };\n  return crypto._signObject(deviceKeys).then(() => {\n    return crypto._baseApis.uploadKeysRequest({\n      device_keys: deviceKeys\n    }, {\n      // for now, we set the device id explicitly, as we may not be using the\n      // same one as used in login.\n      device_id: deviceId\n    });\n  });\n};\n/**\n * Stores the current one_time_key count which will be handled later (in a call of\n * onSyncCompleted). The count is e.g. coming from a /sync response.\n *\n * @param {Number} currentCount The current count of one_time_keys to be stored\n */\n\n\nCrypto.prototype.updateOneTimeKeyCount = function (currentCount) {\n  if (isFinite(currentCount)) {\n    this._oneTimeKeyCount = currentCount;\n  } else {\n    throw new TypeError(\"Parameter for updateOneTimeKeyCount has to be a number\");\n  }\n}; // check if it's time to upload one-time keys, and do so if so.\n\n\nfunction _maybeUploadOneTimeKeys(crypto) {\n  // frequency with which to check & upload one-time keys\n  const uploadPeriod = 1000 * 60; // one minute\n  // max number of keys to upload at once\n  // Creating keys can be an expensive operation so we limit the\n  // number we generate in one go to avoid blocking the application\n  // for too long.\n\n  const maxKeysPerCycle = 5;\n\n  if (crypto._oneTimeKeyCheckInProgress) {\n    return;\n  }\n\n  const now = Date.now();\n\n  if (crypto._lastOneTimeKeyCheck !== null && now - crypto._lastOneTimeKeyCheck < uploadPeriod) {\n    // we've done a key upload recently.\n    return;\n  }\n\n  crypto._lastOneTimeKeyCheck = now; // We need to keep a pool of one time public keys on the server so that\n  // other devices can start conversations with us. But we can only store\n  // a finite number of private keys in the olm Account object.\n  // To complicate things further then can be a delay between a device\n  // claiming a public one time key from the server and it sending us a\n  // message. We need to keep the corresponding private key locally until\n  // we receive the message.\n  // But that message might never arrive leaving us stuck with duff\n  // private keys clogging up our local storage.\n  // So we need some kind of enginering compromise to balance all of\n  // these factors.\n  // Check how many keys we can store in the Account object.\n\n  const maxOneTimeKeys = crypto._olmDevice.maxNumberOfOneTimeKeys(); // Try to keep at most half that number on the server. This leaves the\n  // rest of the slots free to hold keys that have been claimed from the\n  // server but we haven't recevied a message for.\n  // If we run out of slots when generating new keys then olm will\n  // discard the oldest private keys first. This will eventually clean\n  // out stale private keys that won't receive a message.\n\n\n  const keyLimit = Math.floor(maxOneTimeKeys / 2);\n\n  function uploadLoop(keyCount) {\n    if (keyLimit <= keyCount) {\n      // If we don't need to generate any more keys then we are done.\n      return Promise.resolve();\n    }\n\n    const keysThisLoop = Math.min(keyLimit - keyCount, maxKeysPerCycle); // Ask olm to generate new one time keys, then upload them to synapse.\n\n    return crypto._olmDevice.generateOneTimeKeys(keysThisLoop).then(() => {\n      return _uploadOneTimeKeys(crypto);\n    }).then(res => {\n      if (res.one_time_key_counts && res.one_time_key_counts.signed_curve25519) {\n        // if the response contains a more up to date value use this\n        // for the next loop\n        return uploadLoop(res.one_time_key_counts.signed_curve25519);\n      } else {\n        throw new Error(\"response for uploading keys does not contain \" + \"one_time_key_counts.signed_curve25519\");\n      }\n    });\n  }\n\n  crypto._oneTimeKeyCheckInProgress = true;\n  Promise.resolve().then(() => {\n    if (crypto._oneTimeKeyCount !== undefined) {\n      // We already have the current one_time_key count from a /sync response.\n      // Use this value instead of asking the server for the current key count.\n      return Promise.resolve(crypto._oneTimeKeyCount);\n    } // ask the server how many keys we have\n\n\n    return crypto._baseApis.uploadKeysRequest({}, {\n      device_id: crypto._deviceId\n    }).then(res => {\n      return res.one_time_key_counts.signed_curve25519 || 0;\n    });\n  }).then(keyCount => {\n    // Start the uploadLoop with the current keyCount. The function checks if\n    // we need to upload new keys or not.\n    // If there are too many keys on the server then we don't need to\n    // create any more keys.\n    return uploadLoop(keyCount);\n  }).catch(e => {\n    _logger.logger.error(\"Error uploading one-time keys\", e.stack || e);\n  }).finally(() => {\n    // reset _oneTimeKeyCount to prevent start uploading based on old data.\n    // it will be set again on the next /sync-response\n    crypto._oneTimeKeyCount = undefined;\n    crypto._oneTimeKeyCheckInProgress = false;\n  });\n} // returns a promise which resolves to the response\n\n\nasync function _uploadOneTimeKeys(crypto) {\n  const oneTimeKeys = await crypto._olmDevice.getOneTimeKeys();\n  const oneTimeJson = {};\n  const promises = [];\n\n  for (const keyId in oneTimeKeys.curve25519) {\n    if (oneTimeKeys.curve25519.hasOwnProperty(keyId)) {\n      const k = {\n        key: oneTimeKeys.curve25519[keyId]\n      };\n      oneTimeJson[\"signed_curve25519:\" + keyId] = k;\n      promises.push(crypto._signObject(k));\n    }\n  }\n\n  await Promise.all(promises);\n  const res = await crypto._baseApis.uploadKeysRequest({\n    one_time_keys: oneTimeJson\n  }, {\n    // for now, we set the device id explicitly, as we may not be using the\n    // same one as used in login.\n    device_id: crypto._deviceId\n  });\n  await crypto._olmDevice.markKeysAsPublished();\n  return res;\n}\n/**\n * Download the keys for a list of users and stores the keys in the session\n * store.\n * @param {Array} userIds The users to fetch.\n * @param {bool} forceDownload Always download the keys even if cached.\n *\n * @return {Promise} A promise which resolves to a map userId->deviceId->{@link\n * module:crypto/deviceinfo|DeviceInfo}.\n */\n\n\nCrypto.prototype.downloadKeys = function (userIds, forceDownload) {\n  return this._deviceList.downloadKeys(userIds, forceDownload);\n};\n/**\n * Get the stored device keys for a user id\n *\n * @param {string} userId the user to list keys for.\n *\n * @return {module:crypto/deviceinfo[]|null} list of devices, or null if we haven't\n * managed to get a list of devices for this user yet.\n */\n\n\nCrypto.prototype.getStoredDevicesForUser = function (userId) {\n  return this._deviceList.getStoredDevicesForUser(userId);\n};\n/**\n * Get the stored keys for a single device\n *\n * @param {string} userId\n * @param {string} deviceId\n *\n * @return {module:crypto/deviceinfo?} device, or undefined\n * if we don't know about this device\n */\n\n\nCrypto.prototype.getStoredDevice = function (userId, deviceId) {\n  return this._deviceList.getStoredDevice(userId, deviceId);\n};\n/**\n * Save the device list, if necessary\n *\n * @param {integer} delay Time in ms before which the save actually happens.\n *     By default, the save is delayed for a short period in order to batch\n *     multiple writes, but this behaviour can be disabled by passing 0.\n *\n * @return {Promise<bool>} true if the data was saved, false if\n *     it was not (eg. because no changes were pending). The promise\n *     will only resolve once the data is saved, so may take some time\n *     to resolve.\n */\n\n\nCrypto.prototype.saveDeviceList = function (delay) {\n  return this._deviceList.saveIfDirty(delay);\n};\n/**\n * Update the blocked/verified state of the given device\n *\n * @param {string} userId owner of the device\n * @param {string} deviceId unique identifier for the device or user's\n * cross-signing public key ID.\n *\n * @param {?boolean} verified whether to mark the device as verified. Null to\n *     leave unchanged.\n *\n * @param {?boolean} blocked whether to mark the device as blocked. Null to\n *      leave unchanged.\n *\n * @param {?boolean} known whether to mark that the user has been made aware of\n *      the existence of this device. Null to leave unchanged\n *\n * @return {Promise<module:crypto/deviceinfo>} updated DeviceInfo\n */\n\n\nCrypto.prototype.setDeviceVerification = async function (userId, deviceId, verified, blocked, known) {\n  // get rid of any `undefined`s here so we can just check\n  // for null rather than null or undefined\n  if (verified === undefined) verified = null;\n  if (blocked === undefined) blocked = null;\n  if (known === undefined) known = null; // Check if the 'device' is actually a cross signing key\n  // The js-sdk's verification treats cross-signing keys as devices\n  // and so uses this method to mark them verified.\n\n  const xsk = this._deviceList.getStoredCrossSigningForUser(userId);\n\n  if (xsk && xsk.getId() === deviceId) {\n    if (blocked !== null || known !== null) {\n      throw new Error(\"Cannot set blocked or known for a cross-signing key\");\n    }\n\n    if (!verified) {\n      throw new Error(\"Cannot set a cross-signing key as unverified\");\n    }\n\n    const device = await this._crossSigningInfo.signUser(xsk);\n\n    if (device) {\n      await this._baseApis.uploadKeySignatures({\n        [userId]: {\n          [deviceId]: device\n        }\n      }); // This will emit events when it comes back down the sync\n      // (we could do local echo to speed things up)\n    }\n\n    return device;\n  }\n\n  const devices = this._deviceList.getRawStoredDevicesForUser(userId);\n\n  if (!devices || !devices[deviceId]) {\n    throw new Error(\"Unknown device \" + userId + \":\" + deviceId);\n  }\n\n  const dev = devices[deviceId];\n  let verificationStatus = dev.verified;\n\n  if (verified) {\n    verificationStatus = DeviceVerification.VERIFIED;\n  } else if (verified !== null && verificationStatus == DeviceVerification.VERIFIED) {\n    verificationStatus = DeviceVerification.UNVERIFIED;\n  }\n\n  if (blocked) {\n    verificationStatus = DeviceVerification.BLOCKED;\n  } else if (blocked !== null && verificationStatus == DeviceVerification.BLOCKED) {\n    verificationStatus = DeviceVerification.UNVERIFIED;\n  }\n\n  let knownStatus = dev.known;\n\n  if (known !== null) {\n    knownStatus = known;\n  }\n\n  if (dev.verified !== verificationStatus || dev.known !== knownStatus) {\n    dev.verified = verificationStatus;\n    dev.known = knownStatus;\n\n    this._deviceList.storeDevicesForUser(userId, devices);\n\n    this._deviceList.saveIfDirty();\n  } // do cross-signing\n\n\n  if (verified && userId === this._userId) {\n    const device = await this._crossSigningInfo.signDevice(userId, _deviceinfo.DeviceInfo.fromStorage(dev, deviceId));\n\n    if (device) {\n      await this._baseApis.uploadKeySignatures({\n        [userId]: {\n          [deviceId]: device\n        }\n      }); // XXX: we'll need to wait for the device list to be updated\n    }\n  }\n\n  const deviceObj = _deviceinfo.DeviceInfo.fromStorage(dev, deviceId);\n\n  this.emit(\"deviceVerificationChanged\", userId, deviceId, deviceObj);\n  return deviceObj;\n};\n\nCrypto.prototype.requestVerificationDM = async function (userId, roomId, methods) {\n  const channel = new _InRoomChannel.InRoomChannel(this._baseApis, roomId, userId);\n  const request = await this._requestVerificationWithChannel(userId, methods, channel, this._inRoomVerificationRequests);\n  return await request.waitForVerifier();\n};\n\nCrypto.prototype.acceptVerificationDM = function (event, method) {\n  if (!_InRoomChannel.InRoomChannel.validateEvent(event, this._baseApis)) {\n    return;\n  }\n\n  const sender = event.getSender();\n\n  const requestsByTxnId = this._inRoomVerificationRequests.get(sender);\n\n  if (!requestsByTxnId) {\n    return;\n  }\n\n  const transactionId = _InRoomChannel.InRoomChannel.getTransactionId(event);\n\n  const request = requestsByTxnId.get(transactionId);\n\n  if (!request) {\n    return;\n  }\n\n  return request.beginKeyVerification(method);\n};\n\nCrypto.prototype.requestVerification = async function (userId, methods, devices) {\n  if (!devices) {\n    devices = Object.keys(this._deviceList.getRawStoredDevicesForUser(userId));\n  }\n\n  const channel = new _ToDeviceChannel.ToDeviceChannel(this._baseApis, userId, devices);\n  const request = await this._requestVerificationWithChannel(userId, methods, channel, this._toDeviceVerificationRequests);\n  return await request.waitForVerifier();\n};\n\nCrypto.prototype._requestVerificationWithChannel = async function (userId, methods, channel, requestsMap) {\n  if (!methods) {\n    // .keys() returns an iterator, so we need to explicitly turn it into an array\n    methods = [...this._verificationMethods.keys()];\n  } // TODO: filter by given methods\n\n\n  const request = new _VerificationRequest.VerificationRequest(channel, this._verificationMethods, userId, this._baseApis);\n  await request.sendRequest();\n  let requestsByTxnId = requestsMap.get(userId);\n\n  if (!requestsByTxnId) {\n    requestsByTxnId = new Map();\n    requestsMap.set(userId, requestsByTxnId);\n  } // TODO: we're only adding the request to the map once it has been sent\n  // but if the other party is really fast they could potentially respond to the\n  // request before the server tells us the event got sent, and we would probably\n  // create a new request object\n\n\n  requestsByTxnId.set(channel.transactionId, request);\n  return request;\n};\n\nCrypto.prototype.beginKeyVerification = function (method, userId, deviceId, transactionId = null) {\n  let requestsByTxnId = this._toDeviceVerificationRequests.get(userId);\n\n  if (!requestsByTxnId) {\n    requestsByTxnId = new Map();\n\n    this._toDeviceVerificationRequests.set(userId, requestsByTxnId);\n  }\n\n  let request;\n\n  if (transactionId) {\n    request = requestsByTxnId.get(transactionId);\n  } else {\n    transactionId = _ToDeviceChannel.ToDeviceChannel.makeTransactionId();\n    const channel = new _ToDeviceChannel.ToDeviceChannel(this._baseApis, userId, [deviceId], transactionId, deviceId);\n    request = new _VerificationRequest.VerificationRequest(channel, this._verificationMethods, userId, this._baseApis);\n    requestsByTxnId.set(transactionId, request);\n  }\n\n  if (!request) {\n    throw new Error(`No request found for user ${userId} with transactionId ${transactionId}`);\n  }\n\n  return request.beginKeyVerification(method, {\n    userId,\n    deviceId\n  });\n};\n/**\n * Get information on the active olm sessions with a user\n * <p>\n * Returns a map from device id to an object with keys 'deviceIdKey' (the\n * device's curve25519 identity key) and 'sessions' (an array of objects in the\n * same format as that returned by\n * {@link module:crypto/OlmDevice#getSessionInfoForDevice}).\n * <p>\n * This method is provided for debugging purposes.\n *\n * @param {string} userId id of user to inspect\n *\n * @return {Promise<Object.<string, {deviceIdKey: string, sessions: object[]}>>}\n */\n\n\nCrypto.prototype.getOlmSessionsForUser = async function (userId) {\n  const devices = this.getStoredDevicesForUser(userId) || [];\n  const result = {};\n\n  for (let j = 0; j < devices.length; ++j) {\n    const device = devices[j];\n    const deviceKey = device.getIdentityKey();\n    const sessions = await this._olmDevice.getSessionInfoForDevice(deviceKey);\n    result[device.deviceId] = {\n      deviceIdKey: deviceKey,\n      sessions: sessions\n    };\n  }\n\n  return result;\n};\n/**\n * Get the device which sent an event\n *\n * @param {module:models/event.MatrixEvent} event event to be checked\n *\n * @return {module:crypto/deviceinfo?}\n */\n\n\nCrypto.prototype.getEventSenderDeviceInfo = function (event) {\n  const senderKey = event.getSenderKey();\n  const algorithm = event.getWireContent().algorithm;\n\n  if (!senderKey || !algorithm) {\n    return null;\n  }\n\n  const forwardingChain = event.getForwardingCurve25519KeyChain();\n\n  if (forwardingChain.length > 0) {\n    // we got this event from somewhere else\n    // TODO: check if we can trust the forwarders.\n    return null;\n  } // senderKey is the Curve25519 identity key of the device which the event\n  // was sent from. In the case of Megolm, it's actually the Curve25519\n  // identity key of the device which set up the Megolm session.\n\n\n  const device = this._deviceList.getDeviceByIdentityKey(algorithm, senderKey);\n\n  if (device === null) {\n    // we haven't downloaded the details of this device yet.\n    return null;\n  } // so far so good, but now we need to check that the sender of this event\n  // hadn't advertised someone else's Curve25519 key as their own. We do that\n  // by checking the Ed25519 claimed by the event (or, in the case of megolm,\n  // the event which set up the megolm session), to check that it matches the\n  // fingerprint of the purported sending device.\n  //\n  // (see https://github.com/vector-im/vector-web/issues/2215)\n\n\n  const claimedKey = event.getClaimedEd25519Key();\n\n  if (!claimedKey) {\n    _logger.logger.warn(\"Event \" + event.getId() + \" claims no ed25519 key: \" + \"cannot verify sending device\");\n\n    return null;\n  }\n\n  if (claimedKey !== device.getFingerprint()) {\n    _logger.logger.warn(\"Event \" + event.getId() + \" claims ed25519 key \" + claimedKey + \"but sender device has key \" + device.getFingerprint());\n\n    return null;\n  }\n\n  return device;\n};\n/**\n * Forces the current outbound group session to be discarded such\n * that another one will be created next time an event is sent.\n *\n * @param {string} roomId The ID of the room to discard the session for\n *\n * This should not normally be necessary.\n */\n\n\nCrypto.prototype.forceDiscardSession = function (roomId) {\n  const alg = this._roomEncryptors[roomId];\n  if (alg === undefined) throw new Error(\"Room not encrypted\");\n\n  if (alg.forceDiscardSession === undefined) {\n    throw new Error(\"Room encryption algorithm doesn't support session discarding\");\n  }\n\n  alg.forceDiscardSession();\n};\n/**\n * Configure a room to use encryption (ie, save a flag in the cryptoStore).\n *\n * @param {string} roomId The room ID to enable encryption in.\n *\n * @param {object} config The encryption config for the room.\n *\n * @param {boolean=} inhibitDeviceQuery true to suppress device list query for\n *   users in the room (for now). In case lazy loading is enabled,\n *   the device query is always inhibited as the members are not tracked.\n */\n\n\nCrypto.prototype.setRoomEncryption = async function (roomId, config, inhibitDeviceQuery) {\n  // ignore crypto events with no algorithm defined\n  // This will happen if a crypto event is redacted before we fetch the room state\n  // It would otherwise just throw later as an unknown algorithm would, but we may\n  // as well catch this here\n  if (!config.algorithm) {\n    _logger.logger.log(\"Ignoring setRoomEncryption with no algorithm\");\n\n    return;\n  } // if state is being replayed from storage, we might already have a configuration\n  // for this room as they are persisted as well.\n  // We just need to make sure the algorithm is initialized in this case.\n  // However, if the new config is different,\n  // we should bail out as room encryption can't be changed once set.\n\n\n  const existingConfig = this._roomList.getRoomEncryption(roomId);\n\n  if (existingConfig) {\n    if (JSON.stringify(existingConfig) != JSON.stringify(config)) {\n      _logger.logger.error(\"Ignoring m.room.encryption event which requests \" + \"a change of config in \" + roomId);\n\n      return;\n    }\n  } // if we already have encryption in this room, we should ignore this event,\n  // as it would reset the encryption algorithm.\n  // This is at least expected to be called twice, as sync calls onCryptoEvent\n  // for both the timeline and state sections in the /sync response,\n  // the encryption event would appear in both.\n  // If it's called more than twice though,\n  // it signals a bug on client or server.\n\n\n  const existingAlg = this._roomEncryptors[roomId];\n\n  if (existingAlg) {\n    return;\n  } // _roomList.getRoomEncryption will not race with _roomList.setRoomEncryption\n  // because it first stores in memory. We should await the promise only\n  // after all the in-memory state (_roomEncryptors and _roomList) has been updated\n  // to avoid races when calling this method multiple times. Hence keep a hold of the promise.\n\n\n  let storeConfigPromise = null;\n\n  if (!existingConfig) {\n    storeConfigPromise = this._roomList.setRoomEncryption(roomId, config);\n  }\n\n  const AlgClass = algorithms.ENCRYPTION_CLASSES[config.algorithm];\n\n  if (!AlgClass) {\n    throw new Error(\"Unable to encrypt with \" + config.algorithm);\n  }\n\n  const alg = new AlgClass({\n    userId: this._userId,\n    deviceId: this._deviceId,\n    crypto: this,\n    olmDevice: this._olmDevice,\n    baseApis: this._baseApis,\n    roomId: roomId,\n    config: config\n  });\n  this._roomEncryptors[roomId] = alg;\n\n  if (storeConfigPromise) {\n    await storeConfigPromise;\n  }\n\n  if (!this._lazyLoadMembers) {\n    _logger.logger.log(\"Enabling encryption in \" + roomId + \"; \" + \"starting to track device lists for all users therein\");\n\n    await this.trackRoomDevices(roomId); // TODO: this flag is only not used from MatrixClient::setRoomEncryption\n    // which is never used (inside riot at least)\n    // but didn't want to remove it as it technically would\n    // be a breaking change.\n\n    if (!this.inhibitDeviceQuery) {\n      this._deviceList.refreshOutdatedDeviceLists();\n    }\n  } else {\n    _logger.logger.log(\"Enabling encryption in \" + roomId);\n  }\n};\n/**\n * Make sure we are tracking the device lists for all users in this room.\n *\n * @param {string} roomId The room ID to start tracking devices in.\n * @returns {Promise} when all devices for the room have been fetched and marked to track\n */\n\n\nCrypto.prototype.trackRoomDevices = function (roomId) {\n  const trackMembers = async () => {\n    // not an encrypted room\n    if (!this._roomEncryptors[roomId]) {\n      return;\n    }\n\n    const room = this._clientStore.getRoom(roomId);\n\n    if (!room) {\n      throw new Error(`Unable to start tracking devices in unknown room ${roomId}`);\n    }\n\n    _logger.logger.log(`Starting to track devices for room ${roomId} ...`);\n\n    const members = await room.getEncryptionTargetMembers();\n    members.forEach(m => {\n      this._deviceList.startTrackingDeviceList(m.userId);\n    });\n  };\n\n  let promise = this._roomDeviceTrackingState[roomId];\n\n  if (!promise) {\n    promise = trackMembers();\n    this._roomDeviceTrackingState[roomId] = promise;\n  }\n\n  return promise;\n};\n/**\n * @typedef {Object} module:crypto~OlmSessionResult\n * @property {module:crypto/deviceinfo} device  device info\n * @property {string?} sessionId base64 olm session id; null if no session\n *    could be established\n */\n\n/**\n * Try to make sure we have established olm sessions for all known devices for\n * the given users.\n *\n * @param {string[]} users list of user ids\n *\n * @return {module:client.Promise} resolves once the sessions are complete, to\n *    an Object mapping from userId to deviceId to\n *    {@link module:crypto~OlmSessionResult}\n */\n\n\nCrypto.prototype.ensureOlmSessionsForUsers = function (users) {\n  const devicesByUser = {};\n\n  for (let i = 0; i < users.length; ++i) {\n    const userId = users[i];\n    devicesByUser[userId] = [];\n    const devices = this.getStoredDevicesForUser(userId) || [];\n\n    for (let j = 0; j < devices.length; ++j) {\n      const deviceInfo = devices[j];\n      const key = deviceInfo.getIdentityKey();\n\n      if (key == this._olmDevice.deviceCurve25519Key) {\n        // don't bother setting up session to ourself\n        continue;\n      }\n\n      if (deviceInfo.verified == DeviceVerification.BLOCKED) {\n        // don't bother setting up sessions with blocked users\n        continue;\n      }\n\n      devicesByUser[userId].push(deviceInfo);\n    }\n  }\n\n  return olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, devicesByUser);\n};\n/**\n * Get a list containing all of the room keys\n *\n * @return {module:crypto/OlmDevice.MegolmSessionData[]} a list of session export objects\n */\n\n\nCrypto.prototype.exportRoomKeys = async function () {\n  const exportedSessions = [];\n  await this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS], txn => {\n    this._cryptoStore.getAllEndToEndInboundGroupSessions(txn, s => {\n      if (s === null) return;\n\n      const sess = this._olmDevice.exportInboundGroupSession(s.senderKey, s.sessionId, s.sessionData);\n\n      delete sess.first_known_index;\n      sess.algorithm = olmlib.MEGOLM_ALGORITHM;\n      exportedSessions.push(sess);\n    });\n  });\n  return exportedSessions;\n};\n/**\n * Import a list of room keys previously exported by exportRoomKeys\n *\n * @param {Object[]} keys a list of session export objects\n * @return {module:client.Promise} a promise which resolves once the keys have been imported\n */\n\n\nCrypto.prototype.importRoomKeys = function (keys) {\n  return Promise.all(keys.map(key => {\n    if (!key.room_id || !key.algorithm) {\n      _logger.logger.warn(\"ignoring room key entry with missing fields\", key);\n\n      return null;\n    }\n\n    const alg = this._getRoomDecryptor(key.room_id, key.algorithm);\n\n    return alg.importRoomKey(key);\n  }));\n};\n/**\n * Schedules sending all keys waiting to be sent to the backup, if not already\n * scheduled. Retries if necessary.\n *\n * @param {number} maxDelay Maximum delay to wait in ms. 0 means no delay.\n */\n\n\nCrypto.prototype.scheduleKeyBackupSend = async function (maxDelay = 10000) {\n  if (this._sendingBackups) return;\n  this._sendingBackups = true;\n\n  try {\n    // wait between 0 and `maxDelay` seconds, to avoid backup\n    // requests from different clients hitting the server all at\n    // the same time when a new key is sent\n    const delay = Math.random() * maxDelay;\n    await (0, utils.sleep)(delay);\n    let numFailures = 0; // number of consecutive failures\n\n    while (1) {\n      if (!this.backupKey) {\n        return;\n      }\n\n      try {\n        const numBackedUp = await this._backupPendingKeys(KEY_BACKUP_KEYS_PER_REQUEST);\n\n        if (numBackedUp === 0) {\n          // no sessions left needing backup: we're done\n          return;\n        }\n\n        numFailures = 0;\n      } catch (err) {\n        numFailures++;\n\n        _logger.logger.log(\"Key backup request failed\", err);\n\n        if (err.data) {\n          if (err.data.errcode == 'M_NOT_FOUND' || err.data.errcode == 'M_WRONG_ROOM_KEYS_VERSION') {\n            // Re-check key backup status on error, so we can be\n            // sure to present the current situation when asked.\n            await this.checkKeyBackup(); // Backup version has changed or this backup version\n            // has been deleted\n\n            this.emit(\"crypto.keyBackupFailed\", err.data.errcode);\n            throw err;\n          }\n        }\n      }\n\n      if (numFailures) {\n        // exponential backoff if we have failures\n        await (0, utils.sleep)(1000 * Math.pow(2, Math.min(numFailures - 1, 4)));\n      }\n    }\n  } finally {\n    this._sendingBackups = false;\n  }\n};\n/**\n * Take some e2e keys waiting to be backed up and send them\n * to the backup.\n *\n * @param {integer} limit Maximum number of keys to back up\n * @returns {integer} Number of sessions backed up\n */\n\n\nCrypto.prototype._backupPendingKeys = async function (limit) {\n  const sessions = await this._cryptoStore.getSessionsNeedingBackup(limit);\n\n  if (!sessions.length) {\n    return 0;\n  }\n\n  let remaining = await this._cryptoStore.countSessionsNeedingBackup();\n  this.emit(\"crypto.keyBackupSessionsRemaining\", remaining);\n  const data = {};\n\n  for (const session of sessions) {\n    const roomId = session.sessionData.room_id;\n\n    if (data[roomId] === undefined) {\n      data[roomId] = {\n        sessions: {}\n      };\n    }\n\n    const sessionData = await this._olmDevice.exportInboundGroupSession(session.senderKey, session.sessionId, session.sessionData);\n    sessionData.algorithm = olmlib.MEGOLM_ALGORITHM;\n    delete sessionData.session_id;\n    delete sessionData.room_id;\n    const firstKnownIndex = sessionData.first_known_index;\n    delete sessionData.first_known_index;\n    const encrypted = this.backupKey.encrypt(JSON.stringify(sessionData));\n    const forwardedCount = (sessionData.forwarding_curve25519_key_chain || []).length;\n\n    const device = this._deviceList.getDeviceByIdentityKey(olmlib.MEGOLM_ALGORITHM, session.senderKey);\n\n    data[roomId]['sessions'][session.sessionId] = {\n      first_message_index: firstKnownIndex,\n      forwarded_count: forwardedCount,\n      is_verified: !!(device && device.isVerified()),\n      session_data: encrypted\n    };\n  }\n\n  await this._baseApis.sendKeyBackup(undefined, undefined, this.backupInfo.version, {\n    rooms: data\n  });\n  await this._cryptoStore.unmarkSessionsNeedingBackup(sessions);\n  remaining = await this._cryptoStore.countSessionsNeedingBackup();\n  this.emit(\"crypto.keyBackupSessionsRemaining\", remaining);\n  return sessions.length;\n};\n\nCrypto.prototype.backupGroupSession = async function (roomId, senderKey, forwardingCurve25519KeyChain, sessionId, sessionKey, keysClaimed, exportFormat) {\n  if (!this.backupInfo) {\n    throw new Error(\"Key backups are not enabled\");\n  }\n\n  await this._cryptoStore.markSessionsNeedingBackup([{\n    senderKey: senderKey,\n    sessionId: sessionId\n  }]); // don't wait for this to complete: it will delay so\n  // happens in the background\n\n  this.scheduleKeyBackupSend();\n};\n/**\n * Marks all group sessions as needing to be backed up and schedules them to\n * upload in the background as soon as possible.\n */\n\n\nCrypto.prototype.scheduleAllGroupSessionsForBackup = async function () {\n  await this.flagAllGroupSessionsForBackup(); // Schedule keys to upload in the background as soon as possible.\n\n  this.scheduleKeyBackupSend(0\n  /* maxDelay */\n  );\n};\n/**\n * Marks all group sessions as needing to be backed up without scheduling\n * them to upload in the background.\n * @returns {Promise<int>} Resolves to the number of sessions requiring a backup.\n */\n\n\nCrypto.prototype.flagAllGroupSessionsForBackup = async function () {\n  await this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, _indexeddbCryptoStore.IndexedDBCryptoStore.STORE_BACKUP], txn => {\n    this._cryptoStore.getAllEndToEndInboundGroupSessions(txn, session => {\n      if (session !== null) {\n        this._cryptoStore.markSessionsNeedingBackup([session], txn);\n      }\n    });\n  });\n  const remaining = await this._cryptoStore.countSessionsNeedingBackup();\n  this.emit(\"crypto.keyBackupSessionsRemaining\", remaining);\n  return remaining;\n};\n/* eslint-disable valid-jsdoc */\n//https://github.com/eslint/eslint/issues/7307\n\n/**\n * Encrypt an event according to the configuration of the room.\n *\n * @param {module:models/event.MatrixEvent} event  event to be sent\n *\n * @param {module:models/room} room destination room.\n *\n * @return {module:client.Promise?} Promise which resolves when the event has been\n *     encrypted, or null if nothing was needed\n */\n\n/* eslint-enable valid-jsdoc */\n\n\nCrypto.prototype.encryptEvent = async function (event, room) {\n  if (!room) {\n    throw new Error(\"Cannot send encrypted messages in unknown rooms\");\n  }\n\n  const roomId = event.getRoomId();\n  const alg = this._roomEncryptors[roomId];\n\n  if (!alg) {\n    // MatrixClient has already checked that this room should be encrypted,\n    // so this is an unexpected situation.\n    throw new Error(\"Room was previously configured to use encryption, but is \" + \"no longer. Perhaps the homeserver is hiding the \" + \"configuration event.\");\n  }\n\n  if (!this._roomDeviceTrackingState[roomId]) {\n    this.trackRoomDevices(roomId);\n  } // wait for all the room devices to be loaded\n\n\n  await this._roomDeviceTrackingState[roomId];\n  let content = event.getContent(); // If event has an m.relates_to then we need\n  // to put this on the wrapping event instead\n\n  const mRelatesTo = content['m.relates_to'];\n\n  if (mRelatesTo) {\n    // Clone content here so we don't remove `m.relates_to` from the local-echo\n    content = Object.assign({}, content);\n    delete content['m.relates_to'];\n  }\n\n  const encryptedContent = await alg.encryptMessage(room, event.getType(), content);\n\n  if (mRelatesTo) {\n    encryptedContent['m.relates_to'] = mRelatesTo;\n  }\n\n  event.makeEncrypted(\"m.room.encrypted\", encryptedContent, this._olmDevice.deviceCurve25519Key, this._olmDevice.deviceEd25519Key);\n};\n/**\n * Decrypt a received event\n *\n * @param {MatrixEvent} event\n *\n * @return {Promise<module:crypto~EventDecryptionResult>} resolves once we have\n *  finished decrypting. Rejects with an `algorithms.DecryptionError` if there\n *  is a problem decrypting the event.\n */\n\n\nCrypto.prototype.decryptEvent = function (event) {\n  if (event.isRedacted()) {\n    return Promise.resolve({\n      clearEvent: {\n        room_id: event.getRoomId(),\n        type: \"m.room.message\",\n        content: {}\n      }\n    });\n  }\n\n  const content = event.getWireContent();\n\n  const alg = this._getRoomDecryptor(event.getRoomId(), content.algorithm);\n\n  return alg.decryptEvent(event);\n};\n/**\n * Handle the notification from /sync or /keys/changes that device lists have\n * been changed.\n *\n * @param {Object} syncData Object containing sync tokens associated with this sync\n * @param {Object} syncDeviceLists device_lists field from /sync, or response from\n * /keys/changes\n */\n\n\nCrypto.prototype.handleDeviceListChanges = async function (syncData, syncDeviceLists) {\n  // Initial syncs don't have device change lists. We'll either get the complete list\n  // of changes for the interval or will have invalidated everything in willProcessSync\n  if (!syncData.oldSyncToken) return; // Here, we're relying on the fact that we only ever save the sync data after\n  // sucessfully saving the device list data, so we're guaranteed that the device\n  // list store is at least as fresh as the sync token from the sync store, ie.\n  // any device changes received in sync tokens prior to the 'next' token here\n  // have been processed and are reflected in the current device list.\n  // If we didn't make this assumption, we'd have to use the /keys/changes API\n  // to get key changes between the sync token in the device list and the 'old'\n  // sync token used here to make sure we didn't miss any.\n\n  await this._evalDeviceListChanges(syncDeviceLists);\n};\n/**\n * Send a request for some room keys, if we have not already done so\n *\n * @param {module:crypto~RoomKeyRequestBody} requestBody\n * @param {Array<{userId: string, deviceId: string}>} recipients\n * @param {boolean} resend whether to resend the key request if there is\n *    already one\n *\n * @return {Promise} a promise that resolves when the key request is queued\n */\n\n\nCrypto.prototype.requestRoomKey = function (requestBody, recipients, resend = false) {\n  return this._outgoingRoomKeyRequestManager.sendRoomKeyRequest(requestBody, recipients, resend).catch(e => {\n    // this normally means we couldn't talk to the store\n    _logger.logger.error('Error requesting key for event', e);\n  });\n};\n/**\n * Cancel any earlier room key request\n *\n * @param {module:crypto~RoomKeyRequestBody} requestBody\n *    parameters to match for cancellation\n */\n\n\nCrypto.prototype.cancelRoomKeyRequest = function (requestBody) {\n  this._outgoingRoomKeyRequestManager.cancelRoomKeyRequest(requestBody).catch(e => {\n    _logger.logger.warn(\"Error clearing pending room key requests\", e);\n  });\n};\n/**\n * handle an m.room.encryption event\n *\n * @param {module:models/event.MatrixEvent} event encryption event\n */\n\n\nCrypto.prototype.onCryptoEvent = async function (event) {\n  const roomId = event.getRoomId();\n  const content = event.getContent();\n\n  try {\n    // inhibit the device list refresh for now - it will happen once we've\n    // finished processing the sync, in onSyncCompleted.\n    await this.setRoomEncryption(roomId, content, true);\n  } catch (e) {\n    _logger.logger.error(\"Error configuring encryption in room \" + roomId + \":\", e);\n  }\n};\n/**\n * Called before the result of a sync is procesed\n *\n * @param {Object} syncData  the data from the 'MatrixClient.sync' event\n */\n\n\nCrypto.prototype.onSyncWillProcess = async function (syncData) {\n  if (!syncData.oldSyncToken) {\n    // If there is no old sync token, we start all our tracking from\n    // scratch, so mark everything as untracked. onCryptoEvent will\n    // be called for all e2e rooms during the processing of the sync,\n    // at which point we'll start tracking all the users of that room.\n    _logger.logger.log(\"Initial sync performed - resetting device tracking state\");\n\n    this._deviceList.stopTrackingAllDeviceLists(); // we always track our own device list (for key backups etc)\n\n\n    this._deviceList.startTrackingDeviceList(this._userId);\n\n    this._roomDeviceTrackingState = {};\n  }\n};\n/**\n * handle the completion of a /sync\n *\n * This is called after the processing of each successful /sync response.\n * It is an opportunity to do a batch process on the information received.\n *\n * @param {Object} syncData  the data from the 'MatrixClient.sync' event\n */\n\n\nCrypto.prototype.onSyncCompleted = async function (syncData) {\n  const nextSyncToken = syncData.nextSyncToken;\n\n  this._deviceList.setSyncToken(syncData.nextSyncToken);\n\n  this._deviceList.saveIfDirty(); // catch up on any new devices we got told about during the sync.\n\n\n  this._deviceList.lastKnownSyncToken = nextSyncToken; // we always track our own device list (for key backups etc)\n\n  this._deviceList.startTrackingDeviceList(this._userId);\n\n  this._deviceList.refreshOutdatedDeviceLists(); // we don't start uploading one-time keys until we've caught up with\n  // to-device messages, to help us avoid throwing away one-time-keys that we\n  // are about to receive messages for\n  // (https://github.com/vector-im/riot-web/issues/2782).\n\n\n  if (!syncData.catchingUp) {\n    _maybeUploadOneTimeKeys(this);\n\n    this._processReceivedRoomKeyRequests();\n  }\n};\n/**\n * Trigger the appropriate invalidations and removes for a given\n * device list\n *\n * @param {Object} deviceLists device_lists field from /sync, or response from\n * /keys/changes\n */\n\n\nCrypto.prototype._evalDeviceListChanges = async function (deviceLists) {\n  if (deviceLists.changed && Array.isArray(deviceLists.changed)) {\n    deviceLists.changed.forEach(u => {\n      this._deviceList.invalidateUserDeviceList(u);\n    });\n  }\n\n  if (deviceLists.left && Array.isArray(deviceLists.left) && deviceLists.left.length) {\n    // Check we really don't share any rooms with these users\n    // any more: the server isn't required to give us the\n    // exact correct set.\n    const e2eUserIds = new Set((await this._getTrackedE2eUsers()));\n    deviceLists.left.forEach(u => {\n      if (!e2eUserIds.has(u)) {\n        this._deviceList.stopTrackingDeviceList(u);\n      }\n    });\n  }\n};\n/**\n * Get a list of all the IDs of users we share an e2e room with\n * for which we are tracking devices already\n *\n * @returns {string[]} List of user IDs\n */\n\n\nCrypto.prototype._getTrackedE2eUsers = async function () {\n  const e2eUserIds = [];\n\n  for (const room of this._getTrackedE2eRooms()) {\n    const members = await room.getEncryptionTargetMembers();\n\n    for (const member of members) {\n      e2eUserIds.push(member.userId);\n    }\n  }\n\n  return e2eUserIds;\n};\n/**\n * Get a list of the e2e-enabled rooms we are members of,\n * and for which we are already tracking the devices\n *\n * @returns {module:models.Room[]}\n */\n\n\nCrypto.prototype._getTrackedE2eRooms = function () {\n  return this._clientStore.getRooms().filter(room => {\n    // check for rooms with encryption enabled\n    const alg = this._roomEncryptors[room.roomId];\n\n    if (!alg) {\n      return false;\n    }\n\n    if (!this._roomDeviceTrackingState[room.roomId]) {\n      return false;\n    } // ignore any rooms which we have left\n\n\n    const myMembership = room.getMyMembership();\n    return myMembership === \"join\" || myMembership === \"invite\";\n  });\n};\n\nCrypto.prototype._onToDeviceEvent = function (event) {\n  try {\n    _logger.logger.log(`received to_device ${event.getType()} from: ` + `${event.getSender()} id: ${event.getId()}`);\n\n    if (event.getType() == \"m.room_key\" || event.getType() == \"m.forwarded_room_key\") {\n      this._onRoomKeyEvent(event);\n    } else if (event.getType() == \"m.room_key_request\") {\n      this._onRoomKeyRequestEvent(event);\n    } else if (event.getType() === \"m.secret.request\") {\n      this._secretStorage._onRequestReceived(event);\n    } else if (event.getType() === \"m.secret.send\") {\n      this._secretStorage._onSecretReceived(event);\n    } else if (event.getType() === \"org.matrix.room_key.withheld\") {\n      this._onRoomKeyWithheldEvent(event);\n    } else if (event.getContent().transaction_id) {\n      this._onKeyVerificationMessage(event);\n    } else if (event.getContent().msgtype === \"m.bad.encrypted\") {\n      this._onToDeviceBadEncrypted(event);\n    } else if (event.isBeingDecrypted()) {\n      // once the event has been decrypted, try again\n      event.once('Event.decrypted', ev => {\n        this._onToDeviceEvent(ev);\n      });\n    }\n  } catch (e) {\n    _logger.logger.error(\"Error handling toDeviceEvent:\", e);\n  }\n};\n/**\n * Handle a key event\n *\n * @private\n * @param {module:models/event.MatrixEvent} event key event\n */\n\n\nCrypto.prototype._onRoomKeyEvent = function (event) {\n  const content = event.getContent();\n\n  if (!content.room_id || !content.algorithm) {\n    _logger.logger.error(\"key event is missing fields\");\n\n    return;\n  }\n\n  if (!this._checkedForBackup) {\n    // don't bother awaiting on this - the important thing is that we retry if we\n    // haven't managed to check before\n    this._checkAndStartKeyBackup();\n  }\n\n  const alg = this._getRoomDecryptor(content.room_id, content.algorithm);\n\n  alg.onRoomKeyEvent(event);\n};\n/**\n * Handle a key withheld event\n *\n * @private\n * @param {module:models/event.MatrixEvent} event key withheld event\n */\n\n\nCrypto.prototype._onRoomKeyWithheldEvent = function (event) {\n  const content = event.getContent();\n\n  if (content.code !== \"m.no_olm\" && (!content.room_id || !content.session_id) || !content.algorithm || !content.sender_key) {\n    _logger.logger.error(\"key withheld event is missing fields\");\n\n    return;\n  }\n\n  _logger.logger.info(`Got room key withheld event from ${event.getSender()} (${content.sender_key}) ` + `for ${content.algorithm}/${content.room_id}/${content.session_id} ` + `with reason ${content.code} (${content.reason})`);\n\n  const alg = this._getRoomDecryptor(content.room_id, content.algorithm);\n\n  if (alg.onRoomKeyWithheldEvent) {\n    alg.onRoomKeyWithheldEvent(event);\n  }\n\n  if (!content.room_id) {\n    // retry decryption for all events sent by the sender_key.  This will\n    // update the events to show a message indicating that the olm session was\n    // wedged.\n    const roomDecryptors = this._getRoomDecryptors(content.algorithm);\n\n    for (const decryptor of roomDecryptors) {\n      decryptor.retryDecryptionFromSender(content.sender_key);\n    }\n  }\n};\n/**\n * Handle a general key verification event.\n *\n * @private\n * @param {module:models/event.MatrixEvent} event verification start event\n */\n\n\nCrypto.prototype._onKeyVerificationMessage = function (event) {\n  if (!_ToDeviceChannel.ToDeviceChannel.validateEvent(event, this._baseApis)) {\n    return;\n  }\n\n  const transactionId = _ToDeviceChannel.ToDeviceChannel.getTransactionId(event);\n\n  const createRequest = event => {\n    if (!_ToDeviceChannel.ToDeviceChannel.canCreateRequest(_ToDeviceChannel.ToDeviceChannel.getEventType(event))) {\n      return;\n    }\n\n    const content = event.getContent();\n    const deviceId = content && content.from_device;\n\n    if (!deviceId) {\n      return;\n    }\n\n    const userId = event.getSender();\n    const channel = new _ToDeviceChannel.ToDeviceChannel(this._baseApis, userId, [deviceId]);\n    return new _VerificationRequest.VerificationRequest(channel, this._verificationMethods, userId, this._baseApis);\n  };\n\n  this._handleVerificationEvent(event, transactionId, this._toDeviceVerificationRequests, createRequest);\n};\n/**\n * Handle key verification requests sent as timeline events\n *\n * @private\n * @param {module:models/event.MatrixEvent} event the timeline event\n */\n\n\nCrypto.prototype._onTimelineEvent = function (event) {\n  if (!_InRoomChannel.InRoomChannel.validateEvent(event, this._baseApis)) {\n    return;\n  }\n\n  const transactionId = _InRoomChannel.InRoomChannel.getTransactionId(event);\n\n  const createRequest = event => {\n    if (!_InRoomChannel.InRoomChannel.canCreateRequest(_InRoomChannel.InRoomChannel.getEventType(event))) {\n      return;\n    }\n\n    const userId = event.getSender();\n    const channel = new _InRoomChannel.InRoomChannel(this._baseApis, event.getRoomId(), userId);\n    return new _VerificationRequest.VerificationRequest(channel, this._verificationMethods, userId, this._baseApis);\n  };\n\n  this._handleVerificationEvent(event, transactionId, this._inRoomVerificationRequests, createRequest);\n};\n\nCrypto.prototype._handleVerificationEvent = async function (event, transactionId, requestsMap, createRequest) {\n  const sender = event.getSender();\n  let requestsByTxnId = requestsMap.get(sender);\n  let isNewRequest = false;\n  let request = requestsByTxnId && requestsByTxnId.get(transactionId);\n\n  if (!request) {\n    request = createRequest(event); // a request could not be made from this event, so ignore event\n\n    if (!request) {\n      return;\n    }\n\n    isNewRequest = true;\n\n    if (!requestsByTxnId) {\n      requestsByTxnId = new Map();\n      requestsMap.set(sender, requestsByTxnId);\n    }\n\n    requestsByTxnId.set(transactionId, request);\n  }\n\n  try {\n    const hadVerifier = !!request.verifier;\n    await request.channel.handleEvent(event, request); // emit start event when verifier got set\n\n    if (!hadVerifier && request.verifier) {\n      this._baseApis.emit(\"crypto.verification.start\", request.verifier);\n    }\n  } catch (err) {\n    console.error(\"error while handling verification event\", event, err);\n  }\n\n  if (!request.pending) {\n    requestsByTxnId.delete(transactionId);\n\n    if (requestsByTxnId.size === 0) {\n      requestsMap.delete(sender);\n    }\n  } else if (isNewRequest && !request.initiatedByMe) {\n    this._baseApis.emit(\"crypto.verification.request\", request);\n  }\n};\n/**\n * Handle a toDevice event that couldn't be decrypted\n *\n * @private\n * @param {module:models/event.MatrixEvent} event undecryptable event\n */\n\n\nCrypto.prototype._onToDeviceBadEncrypted = async function (event) {\n  const content = event.getWireContent();\n  const sender = event.getSender();\n  const algorithm = content.algorithm;\n  const deviceKey = content.sender_key; // retry decryption for all events sent by the sender_key.  This will\n  // update the events to show a message indicating that the olm session was\n  // wedged.\n\n  const retryDecryption = () => {\n    const roomDecryptors = this._getRoomDecryptors(olmlib.MEGOLM_ALGORITHM);\n\n    for (const decryptor of roomDecryptors) {\n      decryptor.retryDecryptionFromSender(deviceKey);\n    }\n  };\n\n  if (sender === undefined || deviceKey === undefined || deviceKey === undefined) {\n    return;\n  } // check when we last forced a new session with this device: if we've already done so\n  // recently, don't do it again.\n\n\n  this._lastNewSessionForced[sender] = this._lastNewSessionForced[sender] || {};\n  const lastNewSessionForced = this._lastNewSessionForced[sender][deviceKey] || 0;\n\n  if (lastNewSessionForced + MIN_FORCE_SESSION_INTERVAL_MS > Date.now()) {\n    _logger.logger.debug(\"New session already forced with device \" + sender + \":\" + deviceKey + \" at \" + lastNewSessionForced + \": not forcing another\");\n\n    await this._olmDevice.recordSessionProblem(deviceKey, \"wedged\", true);\n    retryDecryption();\n    return;\n  } // establish a new olm session with this device since we're failing to decrypt messages\n  // on a current session.\n  // Note that an undecryptable message from another device could easily be spoofed -\n  // is there anything we can do to mitigate this?\n\n\n  const device = this._deviceList.getDeviceByIdentityKey(algorithm, deviceKey);\n\n  if (!device) {\n    _logger.logger.info(\"Couldn't find device for identity key \" + deviceKey + \": not re-establishing session\");\n\n    await this._olmDevice.recordSessionProblem(deviceKey, \"wedged\", false);\n    retryDecryption();\n    return;\n  }\n\n  const devicesByUser = {};\n  devicesByUser[sender] = [device];\n  await olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, devicesByUser, true);\n  this._lastNewSessionForced[sender][deviceKey] = Date.now(); // Now send a blank message on that session so the other side knows about it.\n  // (The keyshare request is sent in the clear so that won't do)\n  // We send this first such that, as long as the toDevice messages arrive in the\n  // same order we sent them, the other end will get this first, set up the new session,\n  // then get the keyshare request and send the key over this new session (because it\n  // is the session it has most recently received a message on).\n\n  const encryptedContent = {\n    algorithm: olmlib.OLM_ALGORITHM,\n    sender_key: this._olmDevice.deviceCurve25519Key,\n    ciphertext: {}\n  };\n  await olmlib.encryptMessageForDevice(encryptedContent.ciphertext, this._userId, this._deviceId, this._olmDevice, sender, device, {\n    type: \"m.dummy\"\n  });\n  await this._olmDevice.recordSessionProblem(deviceKey, \"wedged\", true);\n  retryDecryption();\n  await this._baseApis.sendToDevice(\"m.room.encrypted\", {\n    [sender]: {\n      [device.deviceId]: encryptedContent\n    }\n  }); // Most of the time this probably won't be necessary since we'll have queued up a key request when\n  // we failed to decrypt the message and will be waiting a bit for the key to arrive before sending\n  // it. This won't always be the case though so we need to re-send any that have already been sent\n  // to avoid races.\n\n  const requestsToResend = await this._outgoingRoomKeyRequestManager.getOutgoingSentRoomKeyRequest(sender, device.deviceId);\n\n  for (const keyReq of requestsToResend) {\n    this.requestRoomKey(keyReq.requestBody, keyReq.recipients, true);\n  }\n};\n/**\n * Handle a change in the membership state of a member of a room\n *\n * @private\n * @param {module:models/event.MatrixEvent} event  event causing the change\n * @param {module:models/room-member} member  user whose membership changed\n * @param {string=} oldMembership  previous membership\n */\n\n\nCrypto.prototype._onRoomMembership = function (event, member, oldMembership) {\n  // this event handler is registered on the *client* (as opposed to the room\n  // member itself), which means it is only called on changes to the *live*\n  // membership state (ie, it is not called when we back-paginate, nor when\n  // we load the state in the initialsync).\n  //\n  // Further, it is automatically registered and called when new members\n  // arrive in the room.\n  const roomId = member.roomId;\n  const alg = this._roomEncryptors[roomId];\n\n  if (!alg) {\n    // not encrypting in this room\n    return;\n  } // only mark users in this room as tracked if we already started tracking in this room\n  // this way we don't start device queries after sync on behalf of this room which we won't use\n  // the result of anyway, as we'll need to do a query again once all the members are fetched\n  // by calling _trackRoomDevices\n\n\n  if (this._roomDeviceTrackingState[roomId]) {\n    if (member.membership == 'join') {\n      _logger.logger.log('Join event for ' + member.userId + ' in ' + roomId); // make sure we are tracking the deviceList for this user\n\n\n      this._deviceList.startTrackingDeviceList(member.userId);\n    } else if (member.membership == 'invite' && this._clientStore.getRoom(roomId).shouldEncryptForInvitedMembers()) {\n      _logger.logger.log('Invite event for ' + member.userId + ' in ' + roomId);\n\n      this._deviceList.startTrackingDeviceList(member.userId);\n    }\n  }\n\n  alg.onRoomMembership(event, member, oldMembership);\n};\n/**\n * Called when we get an m.room_key_request event.\n *\n * @private\n * @param {module:models/event.MatrixEvent} event key request event\n */\n\n\nCrypto.prototype._onRoomKeyRequestEvent = function (event) {\n  const content = event.getContent();\n\n  if (content.action === \"request\") {\n    // Queue it up for now, because they tend to arrive before the room state\n    // events at initial sync, and we want to see if we know anything about the\n    // room before passing them on to the app.\n    const req = new IncomingRoomKeyRequest(event);\n\n    this._receivedRoomKeyRequests.push(req);\n  } else if (content.action === \"request_cancellation\") {\n    const req = new IncomingRoomKeyRequestCancellation(event);\n\n    this._receivedRoomKeyRequestCancellations.push(req);\n  }\n};\n/**\n * Process any m.room_key_request events which were queued up during the\n * current sync.\n *\n * @private\n */\n\n\nCrypto.prototype._processReceivedRoomKeyRequests = async function () {\n  if (this._processingRoomKeyRequests) {\n    // we're still processing last time's requests; keep queuing new ones\n    // up for now.\n    return;\n  }\n\n  this._processingRoomKeyRequests = true;\n\n  try {\n    // we need to grab and clear the queues in the synchronous bit of this method,\n    // so that we don't end up racing with the next /sync.\n    const requests = this._receivedRoomKeyRequests;\n    this._receivedRoomKeyRequests = [];\n    const cancellations = this._receivedRoomKeyRequestCancellations;\n    this._receivedRoomKeyRequestCancellations = []; // Process all of the requests, *then* all of the cancellations.\n    //\n    // This makes sure that if we get a request and its cancellation in the\n    // same /sync result, then we process the request before the\n    // cancellation (and end up with a cancelled request), rather than the\n    // cancellation before the request (and end up with an outstanding\n    // request which should have been cancelled.)\n\n    await Promise.all(requests.map(req => this._processReceivedRoomKeyRequest(req)));\n    await Promise.all(cancellations.map(cancellation => this._processReceivedRoomKeyRequestCancellation(cancellation)));\n  } catch (e) {\n    _logger.logger.error(`Error processing room key requsts: ${e}`);\n  } finally {\n    this._processingRoomKeyRequests = false;\n  }\n};\n/**\n * Helper for processReceivedRoomKeyRequests\n *\n * @param {IncomingRoomKeyRequest} req\n */\n\n\nCrypto.prototype._processReceivedRoomKeyRequest = async function (req) {\n  const userId = req.userId;\n  const deviceId = req.deviceId;\n  const body = req.requestBody;\n  const roomId = body.room_id;\n  const alg = body.algorithm;\n\n  _logger.logger.log(`m.room_key_request from ${userId}:${deviceId}` + ` for ${roomId} / ${body.session_id} (id ${req.requestId})`);\n\n  if (userId !== this._userId) {\n    if (!this._roomEncryptors[roomId]) {\n      _logger.logger.debug(`room key request for unencrypted room ${roomId}`);\n\n      return;\n    }\n\n    const encryptor = this._roomEncryptors[roomId];\n\n    const device = this._deviceList.getStoredDevice(userId, deviceId);\n\n    if (!device) {\n      _logger.logger.debug(`Ignoring keyshare for unknown device ${userId}:${deviceId}`);\n\n      return;\n    }\n\n    try {\n      await encryptor.reshareKeyWithDevice(body.sender_key, body.session_id, userId, device);\n    } catch (e) {\n      _logger.logger.warn(\"Failed to re-share keys for session \" + body.session_id + \" with device \" + userId + \":\" + device.deviceId, e);\n    }\n\n    return;\n  } // todo: should we queue up requests we don't yet have keys for,\n  // in case they turn up later?\n  // if we don't have a decryptor for this room/alg, we don't have\n  // the keys for the requested events, and can drop the requests.\n\n\n  if (!this._roomDecryptors[roomId]) {\n    _logger.logger.log(`room key request for unencrypted room ${roomId}`);\n\n    return;\n  }\n\n  const decryptor = this._roomDecryptors[roomId][alg];\n\n  if (!decryptor) {\n    _logger.logger.log(`room key request for unknown alg ${alg} in room ${roomId}`);\n\n    return;\n  }\n\n  if (!(await decryptor.hasKeysForKeyRequest(req))) {\n    _logger.logger.log(`room key request for unknown session ${roomId} / ` + body.session_id);\n\n    return;\n  }\n\n  req.share = () => {\n    decryptor.shareKeysWithDevice(req);\n  }; // if the device is is verified already, share the keys\n\n\n  const device = this._deviceList.getStoredDevice(userId, deviceId);\n\n  if (device && device.isVerified()) {\n    _logger.logger.log('device is already verified: sharing keys');\n\n    req.share();\n    return;\n  }\n\n  this.emit(\"crypto.roomKeyRequest\", req);\n};\n/**\n * Helper for processReceivedRoomKeyRequests\n *\n * @param {IncomingRoomKeyRequestCancellation} cancellation\n */\n\n\nCrypto.prototype._processReceivedRoomKeyRequestCancellation = async function (cancellation) {\n  _logger.logger.log(`m.room_key_request cancellation for ${cancellation.userId}:` + `${cancellation.deviceId} (id ${cancellation.requestId})`); // we should probably only notify the app of cancellations we told it\n  // about, but we don't currently have a record of that, so we just pass\n  // everything through.\n\n\n  this.emit(\"crypto.roomKeyRequestCancellation\", cancellation);\n};\n/**\n * Get a decryptor for a given room and algorithm.\n *\n * If we already have a decryptor for the given room and algorithm, return\n * it. Otherwise try to instantiate it.\n *\n * @private\n *\n * @param {string?} roomId   room id for decryptor. If undefined, a temporary\n * decryptor is instantiated.\n *\n * @param {string} algorithm  crypto algorithm\n *\n * @return {module:crypto.algorithms.base.DecryptionAlgorithm}\n *\n * @raises {module:crypto.algorithms.DecryptionError} if the algorithm is\n * unknown\n */\n\n\nCrypto.prototype._getRoomDecryptor = function (roomId, algorithm) {\n  let decryptors;\n  let alg;\n  roomId = roomId || null;\n\n  if (roomId) {\n    decryptors = this._roomDecryptors[roomId];\n\n    if (!decryptors) {\n      this._roomDecryptors[roomId] = decryptors = {};\n    }\n\n    alg = decryptors[algorithm];\n\n    if (alg) {\n      return alg;\n    }\n  }\n\n  const AlgClass = algorithms.DECRYPTION_CLASSES[algorithm];\n\n  if (!AlgClass) {\n    throw new algorithms.DecryptionError('UNKNOWN_ENCRYPTION_ALGORITHM', 'Unknown encryption algorithm \"' + algorithm + '\".');\n  }\n\n  alg = new AlgClass({\n    userId: this._userId,\n    crypto: this,\n    olmDevice: this._olmDevice,\n    baseApis: this._baseApis,\n    roomId: roomId\n  });\n\n  if (decryptors) {\n    decryptors[algorithm] = alg;\n  }\n\n  return alg;\n};\n/**\n * Get all the room decryptors for a given encryption algorithm.\n *\n * @param {string} algorithm The encryption algorithm\n *\n * @return {array} An array of room decryptors\n */\n\n\nCrypto.prototype._getRoomDecryptors = function (algorithm) {\n  const decryptors = [];\n\n  for (const d of Object.values(this._roomDecryptors)) {\n    if (algorithm in d) {\n      decryptors.push(d[algorithm]);\n    }\n  }\n\n  return decryptors;\n};\n/**\n * sign the given object with our ed25519 key\n *\n * @param {Object} obj  Object to which we will add a 'signatures' property\n */\n\n\nCrypto.prototype._signObject = async function (obj) {\n  const sigs = obj.signatures || {};\n  const unsigned = obj.unsigned;\n  delete obj.signatures;\n  delete obj.unsigned;\n  sigs[this._userId] = sigs[this._userId] || {};\n  sigs[this._userId][\"ed25519:\" + this._deviceId] = await this._olmDevice.sign(_anotherJson.default.stringify(obj));\n  obj.signatures = sigs;\n  if (unsigned !== undefined) obj.unsigned = unsigned;\n};\n/**\n * The parameters of a room key request. The details of the request may\n * vary with the crypto algorithm, but the management and storage layers for\n * outgoing requests expect it to have 'room_id' and 'session_id' properties.\n *\n * @typedef {Object} RoomKeyRequestBody\n */\n\n/**\n * Represents a received m.room_key_request event\n *\n * @property {string} userId    user requesting the key\n * @property {string} deviceId  device requesting the key\n * @property {string} requestId unique id for the request\n * @property {module:crypto~RoomKeyRequestBody} requestBody\n * @property {function()} share  callback which, when called, will ask\n *    the relevant crypto algorithm implementation to share the keys for\n *    this request.\n */\n\n\nclass IncomingRoomKeyRequest {\n  constructor(event) {\n    const content = event.getContent();\n    this.userId = event.getSender();\n    this.deviceId = content.requesting_device_id;\n    this.requestId = content.request_id;\n    this.requestBody = content.body || {};\n\n    this.share = () => {\n      throw new Error(\"don't know how to share keys for this request yet\");\n    };\n  }\n\n}\n/**\n * Represents a received m.room_key_request cancellation\n *\n * @property {string} userId    user requesting the cancellation\n * @property {string} deviceId  device requesting the cancellation\n * @property {string} requestId unique id for the request to be cancelled\n */\n\n\nclass IncomingRoomKeyRequestCancellation {\n  constructor(event) {\n    const content = event.getContent();\n    this.userId = event.getSender();\n    this.deviceId = content.requesting_device_id;\n    this.requestId = content.request_id;\n  }\n\n}\n/**\n * The result of a (successful) call to decryptEvent.\n *\n * @typedef {Object} EventDecryptionResult\n *\n * @property {Object} clearEvent The plaintext payload for the event\n *     (typically containing <tt>type</tt> and <tt>content</tt> fields).\n *\n * @property {?string} senderCurve25519Key Key owned by the sender of this\n *    event.  See {@link module:models/event.MatrixEvent#getSenderKey}.\n *\n * @property {?string} claimedEd25519Key ed25519 key claimed by the sender of\n *    this event. See\n *    {@link module:models/event.MatrixEvent#getClaimedEd25519Key}.\n *\n * @property {?Array<string>} forwardingCurve25519KeyChain list of curve25519\n *     keys involved in telling us about the senderCurve25519Key and\n *     claimedEd25519Key. See\n *     {@link module:models/event.MatrixEvent#getForwardingCurve25519KeyChain}.\n */\n\n/**\n * Fires when we receive a room key request\n *\n * @event module:client~MatrixClient#\"crypto.roomKeyRequest\"\n * @param {module:crypto~IncomingRoomKeyRequest} req  request details\n */\n\n/**\n * Fires when we receive a room key request cancellation\n *\n * @event module:client~MatrixClient#\"crypto.roomKeyRequestCancellation\"\n * @param {module:crypto~IncomingRoomKeyRequestCancellation} req\n */\n\n/**\n * Fires when the app may wish to warn the user about something related\n * the end-to-end crypto.\n *\n * @event module:client~MatrixClient#\"crypto.warning\"\n * @param {string} type One of the strings listed above\n */"]},"metadata":{},"sourceType":"script"}