{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScanQRCode = exports.ShowQRCode = void 0;\n\nvar _Base = require(\"./Base\");\n\nvar _Error = require(\"./Error\");\n/*\nCopyright 2018 New Vector Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * QR code key verification.\n * @module crypto/verification/QRCode\n */\n\n\nconst MATRIXTO_REGEXP = /^(?:https?:\\/\\/)?(?:www\\.)?matrix\\.to\\/#\\/([#@!+][^?]+)\\?(.+)$/;\nconst KEY_REGEXP = /^key_([^:]+:.+)$/;\nconst newQRCodeError = (0, _Error.errorFactory)(\"m.qr_code.invalid\", \"Invalid QR code\");\n/**\n * @class crypto/verification/QRCode/ShowQRCode\n * @extends {module:crypto/verification/Base}\n */\n\nclass ShowQRCode extends _Base.VerificationBase {\n  _doVerification() {\n    if (!this._done) {\n      const url = \"https://matrix.to/#/\" + this._baseApis.getUserId() + \"?device=\" + encodeURIComponent(this._baseApis.deviceId) + \"&action=verify&key_ed25519%3A\" + encodeURIComponent(this._baseApis.deviceId) + \"=\" + encodeURIComponent(this._baseApis.getDeviceEd25519Key());\n      this.emit(\"show_qr_code\", {\n        url: url\n      });\n    }\n  }\n\n}\n\nexports.ShowQRCode = ShowQRCode;\nShowQRCode.NAME = \"m.qr_code.show.v1\";\n/**\n * @class crypto/verification/QRCode/ScanQRCode\n * @extends {module:crypto/verification/Base}\n */\n\nclass ScanQRCode extends _Base.VerificationBase {\n  static factory(...args) {\n    return new ScanQRCode(...args);\n  }\n\n  async _doVerification() {\n    const code = await new Promise((resolve, reject) => {\n      this.emit(\"scan\", {\n        done: resolve,\n        cancel: () => reject((0, _Error.newUserCancelledError)())\n      });\n    });\n    const match = code.match(MATRIXTO_REGEXP);\n    let deviceId;\n    const keys = {};\n\n    if (!match) {\n      throw newQRCodeError();\n    }\n\n    const userId = match[1];\n    const params = match[2].split(\"&\").map(x => x.split(\"=\", 2).map(decodeURIComponent));\n    let action;\n\n    for (const [name, value] of params) {\n      if (name === \"device\") {\n        deviceId = value;\n      } else if (name === \"action\") {\n        action = value;\n      } else {\n        const keyMatch = name.match(KEY_REGEXP);\n\n        if (keyMatch) {\n          keys[keyMatch[1]] = value;\n        }\n      }\n    }\n\n    if (!deviceId || action !== \"verify\" || Object.keys(keys).length === 0) {\n      throw newQRCodeError();\n    }\n\n    if (!this.userId) {\n      await new Promise((resolve, reject) => {\n        this.emit(\"confirm_user_id\", {\n          userId: userId,\n          confirm: resolve,\n          cancel: () => reject((0, _Error.newUserMismatchError)())\n        });\n      });\n    } else if (this.userId !== userId) {\n      throw (0, _Error.newUserMismatchError)({\n        expected: this.userId,\n        actual: userId\n      });\n    }\n\n    await this._verifyKeys(userId, keys, (keyId, device, key) => {\n      if (device.keys[keyId] !== key) {\n        throw (0, _Error.newKeyMismatchError)();\n      }\n    });\n  }\n\n}\n\nexports.ScanQRCode = ScanQRCode;\nScanQRCode.NAME = \"m.qr_code.scan.v1\";","map":{"version":3,"sources":["/home/kimist/Developpement/React/watcha_client/node_modules/matrix-js-sdk/lib/crypto/verification/QRCode.js"],"names":["Object","defineProperty","exports","value","ScanQRCode","ShowQRCode","_Base","require","_Error","MATRIXTO_REGEXP","KEY_REGEXP","newQRCodeError","errorFactory","VerificationBase","_doVerification","_done","url","_baseApis","getUserId","encodeURIComponent","deviceId","getDeviceEd25519Key","emit","NAME","factory","args","code","Promise","resolve","reject","done","cancel","newUserCancelledError","match","keys","userId","params","split","map","x","decodeURIComponent","action","name","keyMatch","length","confirm","newUserMismatchError","expected","actual","_verifyKeys","keyId","device","key","newKeyMismatchError"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScanQRCode = exports.ShowQRCode = void 0;\n\nvar _Base = require(\"./Base\");\n\nvar _Error = require(\"./Error\");\n\n/*\nCopyright 2018 New Vector Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * QR code key verification.\n * @module crypto/verification/QRCode\n */\nconst MATRIXTO_REGEXP = /^(?:https?:\\/\\/)?(?:www\\.)?matrix\\.to\\/#\\/([#@!+][^?]+)\\?(.+)$/;\nconst KEY_REGEXP = /^key_([^:]+:.+)$/;\nconst newQRCodeError = (0, _Error.errorFactory)(\"m.qr_code.invalid\", \"Invalid QR code\");\n/**\n * @class crypto/verification/QRCode/ShowQRCode\n * @extends {module:crypto/verification/Base}\n */\n\nclass ShowQRCode extends _Base.VerificationBase {\n  _doVerification() {\n    if (!this._done) {\n      const url = \"https://matrix.to/#/\" + this._baseApis.getUserId() + \"?device=\" + encodeURIComponent(this._baseApis.deviceId) + \"&action=verify&key_ed25519%3A\" + encodeURIComponent(this._baseApis.deviceId) + \"=\" + encodeURIComponent(this._baseApis.getDeviceEd25519Key());\n      this.emit(\"show_qr_code\", {\n        url: url\n      });\n    }\n  }\n\n}\n\nexports.ShowQRCode = ShowQRCode;\nShowQRCode.NAME = \"m.qr_code.show.v1\";\n/**\n * @class crypto/verification/QRCode/ScanQRCode\n * @extends {module:crypto/verification/Base}\n */\n\nclass ScanQRCode extends _Base.VerificationBase {\n  static factory(...args) {\n    return new ScanQRCode(...args);\n  }\n\n  async _doVerification() {\n    const code = await new Promise((resolve, reject) => {\n      this.emit(\"scan\", {\n        done: resolve,\n        cancel: () => reject((0, _Error.newUserCancelledError)())\n      });\n    });\n    const match = code.match(MATRIXTO_REGEXP);\n    let deviceId;\n    const keys = {};\n\n    if (!match) {\n      throw newQRCodeError();\n    }\n\n    const userId = match[1];\n    const params = match[2].split(\"&\").map(x => x.split(\"=\", 2).map(decodeURIComponent));\n    let action;\n\n    for (const [name, value] of params) {\n      if (name === \"device\") {\n        deviceId = value;\n      } else if (name === \"action\") {\n        action = value;\n      } else {\n        const keyMatch = name.match(KEY_REGEXP);\n\n        if (keyMatch) {\n          keys[keyMatch[1]] = value;\n        }\n      }\n    }\n\n    if (!deviceId || action !== \"verify\" || Object.keys(keys).length === 0) {\n      throw newQRCodeError();\n    }\n\n    if (!this.userId) {\n      await new Promise((resolve, reject) => {\n        this.emit(\"confirm_user_id\", {\n          userId: userId,\n          confirm: resolve,\n          cancel: () => reject((0, _Error.newUserMismatchError)())\n        });\n      });\n    } else if (this.userId !== userId) {\n      throw (0, _Error.newUserMismatchError)({\n        expected: this.userId,\n        actual: userId\n      });\n    }\n\n    await this._verifyKeys(userId, keys, (keyId, device, key) => {\n      if (device.keys[keyId] !== key) {\n        throw (0, _Error.newKeyMismatchError)();\n      }\n    });\n  }\n\n}\n\nexports.ScanQRCode = ScanQRCode;\nScanQRCode.NAME = \"m.qr_code.scan.v1\";"]},"metadata":{},"sourceType":"script"}