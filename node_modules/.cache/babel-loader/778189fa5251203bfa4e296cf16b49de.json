{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _logger = require(\"../../logger\");\n\nvar utils = _interopRequireWildcard(require(\"../../utils\"));\n\nvar olmlib = _interopRequireWildcard(require(\"../olmlib\"));\n\nvar _base = require(\"./base\");\n\nvar _OlmDevice = require(\"../OlmDevice\");\n/*\nCopyright 2015, 2016 OpenMarket Ltd\nCopyright 2018 New Vector Ltd\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Defines m.olm encryption/decryption\n *\n * @module crypto/algorithms/megolm\n */\n\n/**\n * @private\n * @constructor\n *\n * @param {string} sessionId\n *\n * @property {string} sessionId\n * @property {Number} useCount     number of times this session has been used\n * @property {Number} creationTime when the session was created (ms since the epoch)\n *\n * @property {object} sharedWithDevices\n *    devices with which we have shared the session key\n *        userId -> {deviceId -> msgindex}\n */\n\n\nfunction OutboundSessionInfo(sessionId) {\n  this.sessionId = sessionId;\n  this.useCount = 0;\n  this.creationTime = new Date().getTime();\n  this.sharedWithDevices = {};\n  this.blockedDevicesNotified = {};\n}\n/**\n * Check if it's time to rotate the session\n *\n * @param {Number} rotationPeriodMsgs\n * @param {Number} rotationPeriodMs\n * @return {Boolean}\n */\n\n\nOutboundSessionInfo.prototype.needsRotation = function (rotationPeriodMsgs, rotationPeriodMs) {\n  const sessionLifetime = new Date().getTime() - this.creationTime;\n\n  if (this.useCount >= rotationPeriodMsgs || sessionLifetime >= rotationPeriodMs) {\n    _logger.logger.log(\"Rotating megolm session after \" + this.useCount + \" messages, \" + sessionLifetime + \"ms\");\n\n    return true;\n  }\n\n  return false;\n};\n\nOutboundSessionInfo.prototype.markSharedWithDevice = function (userId, deviceId, chainIndex) {\n  if (!this.sharedWithDevices[userId]) {\n    this.sharedWithDevices[userId] = {};\n  }\n\n  this.sharedWithDevices[userId][deviceId] = chainIndex;\n};\n\nOutboundSessionInfo.prototype.markNotifiedBlockedDevice = function (userId, deviceId) {\n  if (!this.blockedDevicesNotified[userId]) {\n    this.blockedDevicesNotified[userId] = {};\n  }\n\n  this.blockedDevicesNotified[userId][deviceId] = true;\n};\n/**\n * Determine if this session has been shared with devices which it shouldn't\n * have been.\n *\n * @param {Object} devicesInRoom userId -> {deviceId -> object}\n *   devices we should shared the session with.\n *\n * @return {Boolean} true if we have shared the session with devices which aren't\n * in devicesInRoom.\n */\n\n\nOutboundSessionInfo.prototype.sharedWithTooManyDevices = function (devicesInRoom) {\n  for (const userId in this.sharedWithDevices) {\n    if (!this.sharedWithDevices.hasOwnProperty(userId)) {\n      continue;\n    }\n\n    if (!devicesInRoom.hasOwnProperty(userId)) {\n      _logger.logger.log(\"Starting new megolm session because we shared with \" + userId);\n\n      return true;\n    }\n\n    for (const deviceId in this.sharedWithDevices[userId]) {\n      if (!this.sharedWithDevices[userId].hasOwnProperty(deviceId)) {\n        continue;\n      }\n\n      if (!devicesInRoom[userId].hasOwnProperty(deviceId)) {\n        _logger.logger.log(\"Starting new megolm session because we shared with \" + userId + \":\" + deviceId);\n\n        return true;\n      }\n    }\n  }\n};\n/**\n * Megolm encryption implementation\n *\n * @constructor\n * @extends {module:crypto/algorithms/EncryptionAlgorithm}\n *\n * @param {object} params parameters, as per\n *     {@link module:crypto/algorithms/EncryptionAlgorithm}\n */\n\n\nfunction MegolmEncryption(params) {\n  (0, utils.polyfillSuper)(this, _base.EncryptionAlgorithm, params); // the most recent attempt to set up a session. This is used to serialise\n  // the session setups, so that we have a race-free view of which session we\n  // are using, and which devices we have shared the keys with. It resolves\n  // with an OutboundSessionInfo (or undefined, for the first message in the\n  // room).\n\n  this._setupPromise = Promise.resolve(); // Map of outbound sessions by sessions ID. Used if we need a particular\n  // session (the session we're currently using to send is always obtained\n  // using _setupPromise).\n\n  this._outboundSessions = {}; // default rotation periods\n\n  this._sessionRotationPeriodMsgs = 100;\n  this._sessionRotationPeriodMs = 7 * 24 * 3600 * 1000;\n\n  if (params.config.rotation_period_ms !== undefined) {\n    this._sessionRotationPeriodMs = params.config.rotation_period_ms;\n  }\n\n  if (params.config.rotation_period_msgs !== undefined) {\n    this._sessionRotationPeriodMsgs = params.config.rotation_period_msgs;\n  }\n}\n\nutils.inherits(MegolmEncryption, _base.EncryptionAlgorithm);\n/**\n * @private\n *\n * @param {Object} devicesInRoom The devices in this room, indexed by user ID\n * @param {Object} blocked The devices that are blocked, indexed by user ID\n *\n * @return {module:client.Promise} Promise which resolves to the\n *    OutboundSessionInfo when setup is complete.\n */\n\nMegolmEncryption.prototype._ensureOutboundSession = async function (devicesInRoom, blocked) {\n  const self = this;\n  let session; // takes the previous OutboundSessionInfo, and considers whether to create\n  // a new one. Also shares the key with any (new) devices in the room.\n  // Updates `session` to hold the final OutboundSessionInfo.\n  //\n  // returns a promise which resolves once the keyshare is successful.\n\n  async function prepareSession(oldSession) {\n    session = oldSession; // need to make a brand new session?\n\n    if (session && session.needsRotation(self._sessionRotationPeriodMsgs, self._sessionRotationPeriodMs)) {\n      _logger.logger.log(\"Starting new megolm session because we need to rotate.\");\n\n      session = null;\n    } // determine if we have shared with anyone we shouldn't have\n\n\n    if (session && session.sharedWithTooManyDevices(devicesInRoom)) {\n      session = null;\n    }\n\n    if (!session) {\n      _logger.logger.log(`Starting new megolm session for room ${self._roomId}`);\n\n      session = await self._prepareNewSession();\n\n      _logger.logger.log(`Started new megolm session ${session.sessionId} ` + `for room ${self._roomId}`);\n\n      self._outboundSessions[session.sessionId] = session;\n    } // now check if we need to share with any devices\n\n\n    const shareMap = {};\n\n    for (const userId in devicesInRoom) {\n      if (!devicesInRoom.hasOwnProperty(userId)) {\n        continue;\n      }\n\n      const userDevices = devicesInRoom[userId];\n\n      for (const deviceId in userDevices) {\n        if (!userDevices.hasOwnProperty(deviceId)) {\n          continue;\n        }\n\n        const deviceInfo = userDevices[deviceId];\n        const key = deviceInfo.getIdentityKey();\n\n        if (key == self._olmDevice.deviceCurve25519Key) {\n          // don't bother sending to ourself\n          continue;\n        }\n\n        if (!session.sharedWithDevices[userId] || session.sharedWithDevices[userId][deviceId] === undefined) {\n          shareMap[userId] = shareMap[userId] || [];\n          shareMap[userId].push(deviceInfo);\n        }\n      }\n    }\n\n    const errorDevices = [];\n    await self._shareKeyWithDevices(session, shareMap, errorDevices); // are there any new blocked devices that we need to notify?\n\n    const blockedMap = {};\n\n    for (const userId in blocked) {\n      if (!blocked.hasOwnProperty(userId)) {\n        continue;\n      }\n\n      const userBlockedDevices = blocked[userId];\n\n      for (const deviceId in userBlockedDevices) {\n        if (!userBlockedDevices.hasOwnProperty(deviceId)) {\n          continue;\n        }\n\n        if (!session.blockedDevicesNotified[userId] || session.blockedDevicesNotified[userId][deviceId] === undefined) {\n          blockedMap[userId] = blockedMap[userId] || [];\n          blockedMap[userId].push(userBlockedDevices[deviceId]);\n        }\n      }\n    }\n\n    const filteredErrorDevices = await self._olmDevice.filterOutNotifiedErrorDevices(errorDevices);\n\n    for (const {\n      userId,\n      deviceInfo\n    } of filteredErrorDevices) {\n      blockedMap[userId] = blockedMap[userId] || [];\n      blockedMap[userId].push({\n        code: \"m.no_olm\",\n        reason: _OlmDevice.WITHHELD_MESSAGES[\"m.no_olm\"],\n        deviceInfo\n      });\n    } // notify blocked devices that they're blocked\n\n\n    await self._notifyBlockedDevices(session, blockedMap);\n  } // helper which returns the session prepared by prepareSession\n\n\n  function returnSession() {\n    return session;\n  } // first wait for the previous share to complete\n\n\n  const prom = this._setupPromise.then(prepareSession); // _setupPromise resolves to `session` whether or not the share succeeds\n\n\n  this._setupPromise = prom.then(returnSession, returnSession); // but we return a promise which only resolves if the share was successful.\n\n  return prom.then(returnSession);\n};\n/**\n * @private\n *\n * @return {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n */\n\n\nMegolmEncryption.prototype._prepareNewSession = async function () {\n  const sessionId = this._olmDevice.createOutboundGroupSession();\n\n  const key = this._olmDevice.getOutboundGroupSessionKey(sessionId);\n\n  await this._olmDevice.addInboundGroupSession(this._roomId, this._olmDevice.deviceCurve25519Key, [], sessionId, key.key, {\n    ed25519: this._olmDevice.deviceEd25519Key\n  });\n\n  if (this._crypto.backupInfo) {\n    // don't wait for it to complete\n    this._crypto.backupGroupSession(this._roomId, this._olmDevice.deviceCurve25519Key, [], sessionId, key.key).catch(e => {\n      // This throws if the upload failed, but this is fine\n      // since it will have written it to the db and will retry.\n      _logger.logger.log(\"Failed to back up megolm session\", e);\n    });\n  }\n\n  return new OutboundSessionInfo(sessionId);\n};\n/**\n * Splits the user device map into multiple chunks to reduce the number of\n * devices we encrypt to per API call. Also filters out devices we don't have\n * a session with.\n *\n * @private\n *\n * @param {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n *\n * @param {number} chainIndex current chain index\n *\n * @param {object<userId, deviceId>} devicemap\n *   mapping from userId to deviceId to {@link module:crypto~OlmSessionResult}\n *\n * @param {object<string, module:crypto/deviceinfo[]>} devicesByUser\n *    map from userid to list of devices\n *\n * @param {array<object>} errorDevices\n *    array that will be populated with the devices that can't get an\n *    olm session for\n *\n * @return {array<object<userid, deviceInfo>>}\n */\n\n\nMegolmEncryption.prototype._splitUserDeviceMap = function (session, chainIndex, devicemap, devicesByUser, errorDevices) {\n  const maxUsersPerRequest = 20; // use an array where the slices of a content map gets stored\n\n  const mapSlices = [];\n  let currentSliceId = 0; // start inserting in the first slice\n\n  let entriesInCurrentSlice = 0;\n\n  for (const userId of Object.keys(devicesByUser)) {\n    const devicesToShareWith = devicesByUser[userId];\n    const sessionResults = devicemap[userId];\n\n    for (let i = 0; i < devicesToShareWith.length; i++) {\n      const deviceInfo = devicesToShareWith[i];\n      const deviceId = deviceInfo.deviceId;\n      const sessionResult = sessionResults[deviceId];\n\n      if (!sessionResult.sessionId) {\n        // no session with this device, probably because there\n        // were no one-time keys.\n        //\n        // we could send them a to_device message anyway, as a\n        // signal that they have missed out on the key sharing\n        // message because of the lack of keys, but there's not\n        // much point in that really; it will mostly serve to clog\n        // up to_device inboxes.\n        // mark this device as \"handled\" because we don't want to try\n        // to claim a one-time-key for dead devices on every message.\n        session.markSharedWithDevice(userId, deviceId, chainIndex);\n        errorDevices.push({\n          userId,\n          deviceInfo\n        }); // ensureOlmSessionsForUsers has already done the logging,\n        // so just skip it.\n\n        continue;\n      }\n\n      _logger.logger.log(\"share keys with device \" + userId + \":\" + deviceId);\n\n      if (!mapSlices[currentSliceId]) {\n        mapSlices[currentSliceId] = [];\n      }\n\n      mapSlices[currentSliceId].push({\n        userId: userId,\n        deviceInfo: deviceInfo\n      });\n      entriesInCurrentSlice++;\n    } // We do this in the per-user loop as we prefer that all messages to the\n    // same user end up in the same API call to make it easier for the\n    // server (e.g. only have to send one EDU if a remote user, etc). This\n    // does mean that if a user has many devices we may go over the desired\n    // limit, but its not a hard limit so that is fine.\n\n\n    if (entriesInCurrentSlice > maxUsersPerRequest) {\n      // the current slice is filled up. Start inserting into the next slice\n      entriesInCurrentSlice = 0;\n      currentSliceId++;\n    }\n  }\n\n  return mapSlices;\n};\n/**\n * Splits the user device map into multiple chunks to reduce the number of\n * devices we encrypt to per API call.\n *\n * @private\n *\n * @param {object} devicesByUser map from userid to list of devices\n *\n * @return {array<array<object>>} the blocked devices, split into chunks\n */\n\n\nMegolmEncryption.prototype._splitBlockedDevices = function (devicesByUser) {\n  const maxUsersPerRequest = 20; // use an array where the slices of a content map gets stored\n\n  let currentSlice = [];\n  const mapSlices = [currentSlice];\n\n  for (const userId of Object.keys(devicesByUser)) {\n    const userBlockedDevicesToShareWith = devicesByUser[userId];\n\n    for (const blockedInfo of userBlockedDevicesToShareWith) {\n      currentSlice.push({\n        userId: userId,\n        blockedInfo: blockedInfo\n      });\n    } // We do this in the per-user loop as we prefer that all messages to the\n    // same user end up in the same API call to make it easier for the\n    // server (e.g. only have to send one EDU if a remote user, etc). This\n    // does mean that if a user has many devices we may go over the desired\n    // limit, but its not a hard limit so that is fine.\n\n\n    if (currentSlice.length > maxUsersPerRequest) {\n      // the current slice is filled up. Start inserting into the next slice\n      currentSlice = [];\n      mapSlices.push(currentSlice);\n    }\n  }\n\n  if (currentSlice.length === 0) {\n    mapSlices.pop();\n  }\n\n  return mapSlices;\n};\n/**\n * @private\n *\n * @param {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n *\n * @param {number} chainIndex current chain index\n *\n * @param {object<userId, deviceInfo>} userDeviceMap\n *   mapping from userId to deviceInfo\n *\n * @param {object} payload fields to include in the encrypted payload\n *\n * @return {module:client.Promise} Promise which resolves once the key sharing\n *     for the given userDeviceMap is generated and has been sent.\n */\n\n\nMegolmEncryption.prototype._encryptAndSendKeysToDevices = function (session, chainIndex, userDeviceMap, payload) {\n  const contentMap = {};\n  const promises = [];\n\n  for (let i = 0; i < userDeviceMap.length; i++) {\n    const encryptedContent = {\n      algorithm: olmlib.OLM_ALGORITHM,\n      sender_key: this._olmDevice.deviceCurve25519Key,\n      ciphertext: {}\n    };\n    const val = userDeviceMap[i];\n    const userId = val.userId;\n    const deviceInfo = val.deviceInfo;\n    const deviceId = deviceInfo.deviceId;\n\n    if (!contentMap[userId]) {\n      contentMap[userId] = {};\n    }\n\n    contentMap[userId][deviceId] = encryptedContent;\n    promises.push(olmlib.encryptMessageForDevice(encryptedContent.ciphertext, this._userId, this._deviceId, this._olmDevice, userId, deviceInfo, payload));\n  }\n\n  return Promise.all(promises).then(() => {\n    return this._baseApis.sendToDevice(\"m.room.encrypted\", contentMap).then(() => {\n      // store that we successfully uploaded the keys of the current slice\n      for (const userId of Object.keys(contentMap)) {\n        for (const deviceId of Object.keys(contentMap[userId])) {\n          session.markSharedWithDevice(userId, deviceId, chainIndex);\n        }\n      }\n    });\n  });\n};\n/**\n * @private\n *\n * @param {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n *\n * @param {array<object>} userDeviceMap list of blocked devices to notify\n *\n * @param {object} payload fields to include in the notification payload\n *\n * @return {module:client.Promise} Promise which resolves once the notifications\n *     for the given userDeviceMap is generated and has been sent.\n */\n\n\nMegolmEncryption.prototype._sendBlockedNotificationsToDevices = async function (session, userDeviceMap, payload) {\n  const contentMap = {};\n\n  for (const val of userDeviceMap) {\n    const userId = val.userId;\n    const blockedInfo = val.blockedInfo;\n    const deviceInfo = blockedInfo.deviceInfo;\n    const deviceId = deviceInfo.deviceId;\n    const message = Object.assign({}, payload);\n    message.code = blockedInfo.code;\n    message.reason = blockedInfo.reason;\n\n    if (message.code === \"m.no_olm\") {\n      delete message.room_id;\n      delete message.session_id;\n    }\n\n    if (!contentMap[userId]) {\n      contentMap[userId] = {};\n    }\n\n    contentMap[userId][deviceId] = message;\n  }\n\n  await this._baseApis.sendToDevice(\"org.matrix.room_key.withheld\", contentMap); // store that we successfully uploaded the keys of the current slice\n\n  for (const userId of Object.keys(contentMap)) {\n    for (const deviceId of Object.keys(contentMap[userId])) {\n      session.markNotifiedBlockedDevice(userId, deviceId);\n    }\n  }\n};\n/**\n * Re-shares a megolm session key with devices if the key has already been\n * sent to them.\n *\n * @param {string} senderKey The key of the originating device for the session\n * @param {string} sessionId ID of the outbound session to share\n * @param {string} userId ID of the user who owns the target device\n * @param {module:crypto/deviceinfo} device The target device\n */\n\n\nMegolmEncryption.prototype.reshareKeyWithDevice = async function (senderKey, sessionId, userId, device) {\n  const obSessionInfo = this._outboundSessions[sessionId];\n\n  if (!obSessionInfo) {\n    _logger.logger.debug(`megolm session ${sessionId} not found: not re-sharing keys`);\n\n    return;\n  } // The chain index of the key we previously sent this device\n\n\n  if (obSessionInfo.sharedWithDevices[userId] === undefined) {\n    _logger.logger.debug(`megolm session ${sessionId} never shared with user ${userId}`);\n\n    return;\n  }\n\n  const sentChainIndex = obSessionInfo.sharedWithDevices[userId][device.deviceId];\n\n  if (sentChainIndex === undefined) {\n    _logger.logger.debug(\"megolm session ID \" + sessionId + \" never shared with device \" + userId + \":\" + device.deviceId);\n\n    return;\n  } // get the key from the inbound session: the outbound one will already\n  // have been ratcheted to the next chain index.\n\n\n  const key = await this._olmDevice.getInboundGroupSessionKey(this._roomId, senderKey, sessionId, sentChainIndex);\n\n  if (!key) {\n    _logger.logger.warn(`No inbound session key found for megolm ${sessionId}: not re-sharing keys`);\n\n    return;\n  }\n\n  await olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, {\n    [userId]: {\n      [device.deviceId]: device\n    }\n  });\n  const payload = {\n    type: \"m.forwarded_room_key\",\n    content: {\n      algorithm: olmlib.MEGOLM_ALGORITHM,\n      room_id: this._roomId,\n      session_id: sessionId,\n      session_key: key.key,\n      chain_index: key.chain_index,\n      sender_key: senderKey,\n      sender_claimed_ed25519_key: key.sender_claimed_ed25519_key,\n      forwarding_curve25519_key_chain: key.forwarding_curve25519_key_chain\n    }\n  };\n  const encryptedContent = {\n    algorithm: olmlib.OLM_ALGORITHM,\n    sender_key: this._olmDevice.deviceCurve25519Key,\n    ciphertext: {}\n  };\n  await olmlib.encryptMessageForDevice(encryptedContent.ciphertext, this._userId, this._deviceId, this._olmDevice, userId, device, payload);\n  await this._baseApis.sendToDevice(\"m.room.encrypted\", {\n    [userId]: {\n      [device.deviceId]: encryptedContent\n    }\n  });\n\n  _logger.logger.debug(`Re-shared key for megolm session ${sessionId} ` + `with ${userId}:${device.deviceId}`);\n};\n/**\n * @param {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n *\n * @param {object<string, module:crypto/deviceinfo[]>} devicesByUser\n *    map from userid to list of devices\n *\n * @param {array<object>} errorDevices\n *    array that will be populated with the devices that we can't get an\n *    olm session for\n */\n\n\nMegolmEncryption.prototype._shareKeyWithDevices = async function (session, devicesByUser, errorDevices) {\n  const key = this._olmDevice.getOutboundGroupSessionKey(session.sessionId);\n\n  const payload = {\n    type: \"m.room_key\",\n    content: {\n      algorithm: olmlib.MEGOLM_ALGORITHM,\n      room_id: this._roomId,\n      session_id: session.sessionId,\n      session_key: key.key,\n      chain_index: key.chain_index\n    }\n  };\n  const devicemap = await olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, devicesByUser);\n\n  const userDeviceMaps = this._splitUserDeviceMap(session, key.chain_index, devicemap, devicesByUser, errorDevices);\n\n  for (let i = 0; i < userDeviceMaps.length; i++) {\n    try {\n      await this._encryptAndSendKeysToDevices(session, key.chain_index, userDeviceMaps[i], payload);\n\n      _logger.logger.log(`Completed megolm keyshare for ${session.sessionId} ` + `in ${this._roomId} (slice ${i + 1}/${userDeviceMaps.length})`);\n    } catch (e) {\n      _logger.logger.log(`megolm keyshare for ${session.sessionId} in ${this._roomId} ` + `(slice ${i + 1}/${userDeviceMaps.length}) failed`);\n\n      throw e;\n    }\n  }\n};\n/**\n * Notify blocked devices that they have been blocked.\n *\n * @param {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n *\n * @param {object<string, object>} devicesByUser\n *    map from userid to device ID to blocked data\n */\n\n\nMegolmEncryption.prototype._notifyBlockedDevices = async function (session, devicesByUser) {\n  const payload = {\n    room_id: this._roomId,\n    session_id: session.sessionId,\n    algorithm: olmlib.MEGOLM_ALGORITHM,\n    sender_key: this._olmDevice.deviceCurve25519Key\n  };\n\n  const userDeviceMaps = this._splitBlockedDevices(devicesByUser);\n\n  for (let i = 0; i < userDeviceMaps.length; i++) {\n    try {\n      await this._sendBlockedNotificationsToDevices(session, userDeviceMaps[i], payload);\n\n      _logger.logger.log(`Completed blacklist notification for ${session.sessionId} ` + `in ${this._roomId} (slice ${i + 1}/${userDeviceMaps.length})`);\n    } catch (e) {\n      _logger.logger.log(`blacklist notification for ${session.sessionId} in ` + `${this._roomId} (slice ${i + 1}/${userDeviceMaps.length}) failed`);\n\n      throw e;\n    }\n  }\n};\n/**\n * @inheritdoc\n *\n * @param {module:models/room} room\n * @param {string} eventType\n * @param {object} content plaintext event content\n *\n * @return {module:client.Promise} Promise which resolves to the new event body\n */\n\n\nMegolmEncryption.prototype.encryptMessage = async function (room, eventType, content) {\n  const self = this;\n\n  _logger.logger.log(`Starting to encrypt event for ${this._roomId}`);\n\n  const [devicesInRoom, blocked] = await this._getDevicesInRoom(room); // check if any of these devices are not yet known to the user.\n  // if so, warn the user so they can verify or ignore.\n\n  if (this._crypto.getGlobalErrorOnUnknownDevices()) {\n    self._checkForUnknownDevices(devicesInRoom);\n  }\n\n  const session = await self._ensureOutboundSession(devicesInRoom, blocked);\n  const payloadJson = {\n    room_id: self._roomId,\n    type: eventType,\n    content: content\n  };\n\n  const ciphertext = self._olmDevice.encryptGroupMessage(session.sessionId, JSON.stringify(payloadJson));\n\n  const encryptedContent = {\n    algorithm: olmlib.MEGOLM_ALGORITHM,\n    sender_key: self._olmDevice.deviceCurve25519Key,\n    ciphertext: ciphertext,\n    session_id: session.sessionId,\n    // Include our device ID so that recipients can send us a\n    // m.new_device message if they don't have our session key.\n    // XXX: Do we still need this now that m.new_device messages\n    // no longer exist since #483?\n    device_id: self._deviceId\n  };\n  session.useCount++;\n  return encryptedContent;\n};\n/**\n * Forces the current outbound group session to be discarded such\n * that another one will be created next time an event is sent.\n *\n * This should not normally be necessary.\n */\n\n\nMegolmEncryption.prototype.forceDiscardSession = function () {\n  this._setupPromise = this._setupPromise.then(() => null);\n};\n/**\n * Checks the devices we're about to send to and see if any are entirely\n * unknown to the user.  If so, warn the user, and mark them as known to\n * give the user a chance to go verify them before re-sending this message.\n *\n * @param {Object} devicesInRoom userId -> {deviceId -> object}\n *   devices we should shared the session with.\n */\n\n\nMegolmEncryption.prototype._checkForUnknownDevices = function (devicesInRoom) {\n  const unknownDevices = {};\n  Object.keys(devicesInRoom).forEach(userId => {\n    Object.keys(devicesInRoom[userId]).forEach(deviceId => {\n      const device = devicesInRoom[userId][deviceId];\n\n      if (device.isUnverified() && !device.isKnown()) {\n        if (!unknownDevices[userId]) {\n          unknownDevices[userId] = {};\n        }\n\n        unknownDevices[userId][deviceId] = device;\n      }\n    });\n  });\n\n  if (Object.keys(unknownDevices).length) {\n    // it'd be kind to pass unknownDevices up to the user in this error\n    throw new _base.UnknownDeviceError(\"This room contains unknown devices which have not been verified. \" + \"We strongly recommend you verify them before continuing.\", unknownDevices);\n  }\n};\n/**\n * Get the list of unblocked devices for all users in the room\n *\n * @param {module:models/room} room\n *\n * @return {module:client.Promise} Promise which resolves to an array whose\n *     first element is a map from userId to deviceId to deviceInfo indicating\n *     the devices that messages should be encrypted to, and whose second\n *     element is a map from userId to deviceId to data indicating the devices\n *     that are in the room but that have been blocked\n */\n\n\nMegolmEncryption.prototype._getDevicesInRoom = async function (room) {\n  const members = await room.getEncryptionTargetMembers();\n  const roomMembers = utils.map(members, function (u) {\n    return u.userId;\n  }); // The global value is treated as a default for when rooms don't specify a value.\n\n  let isBlacklisting = this._crypto.getGlobalBlacklistUnverifiedDevices();\n\n  if (typeof room.getBlacklistUnverifiedDevices() === 'boolean') {\n    isBlacklisting = room.getBlacklistUnverifiedDevices();\n  } // We are happy to use a cached version here: we assume that if we already\n  // have a list of the user's devices, then we already share an e2e room\n  // with them, which means that they will have announced any new devices via\n  // device_lists in their /sync response.  This cache should then be maintained\n  // using all the device_lists changes and left fields.\n  // See https://github.com/vector-im/riot-web/issues/2305 for details.\n\n\n  const devices = await this._crypto.downloadKeys(roomMembers, false);\n  const blocked = {}; // remove any blocked devices\n\n  for (const userId in devices) {\n    if (!devices.hasOwnProperty(userId)) {\n      continue;\n    }\n\n    const userDevices = devices[userId];\n\n    for (const deviceId in userDevices) {\n      if (!userDevices.hasOwnProperty(deviceId)) {\n        continue;\n      }\n\n      if (userDevices[deviceId].isBlocked() || userDevices[deviceId].isUnverified() && isBlacklisting) {\n        if (!blocked[userId]) {\n          blocked[userId] = {};\n        }\n\n        const blockedInfo = userDevices[deviceId].isBlocked() ? {\n          code: \"m.blacklisted\",\n          reason: _OlmDevice.WITHHELD_MESSAGES[\"m.blacklisted\"]\n        } : {\n          code: \"m.unverified\",\n          reason: _OlmDevice.WITHHELD_MESSAGES[\"m.unverified\"]\n        };\n        blockedInfo.deviceInfo = userDevices[deviceId];\n        blocked[userId][deviceId] = blockedInfo;\n        delete userDevices[deviceId];\n      }\n    }\n  }\n\n  return [devices, blocked];\n};\n/**\n * Megolm decryption implementation\n *\n * @constructor\n * @extends {module:crypto/algorithms/DecryptionAlgorithm}\n *\n * @param {object} params parameters, as per\n *     {@link module:crypto/algorithms/DecryptionAlgorithm}\n */\n\n\nfunction MegolmDecryption(params) {\n  (0, utils.polyfillSuper)(this, _base.DecryptionAlgorithm, params); // events which we couldn't decrypt due to unknown sessions / indexes: map from\n  // senderKey|sessionId to Set of MatrixEvents\n\n  this._pendingEvents = {}; // this gets stubbed out by the unit tests.\n\n  this.olmlib = olmlib;\n}\n\nutils.inherits(MegolmDecryption, _base.DecryptionAlgorithm);\nconst PROBLEM_DESCRIPTIONS = {\n  no_olm: \"The sender was unable to establish a secure channel.\",\n  unknown: \"The secure channel with the sender was corrupted.\"\n};\n/**\n * @inheritdoc\n *\n * @param {MatrixEvent} event\n *\n * returns a promise which resolves to a\n * {@link module:crypto~EventDecryptionResult} once we have finished\n * decrypting, or rejects with an `algorithms.DecryptionError` if there is a\n * problem decrypting the event.\n */\n\nMegolmDecryption.prototype.decryptEvent = async function (event) {\n  const content = event.getWireContent();\n\n  if (!content.sender_key || !content.session_id || !content.ciphertext) {\n    throw new _base.DecryptionError(\"MEGOLM_MISSING_FIELDS\", \"Missing fields in input\");\n  } // we add the event to the pending list *before* we start decryption.\n  //\n  // then, if the key turns up while decryption is in progress (and\n  // decryption fails), we will schedule a retry.\n  // (fixes https://github.com/vector-im/riot-web/issues/5001)\n\n\n  this._addEventToPendingList(event);\n\n  let res;\n\n  try {\n    res = await this._olmDevice.decryptGroupMessage(event.getRoomId(), content.sender_key, content.session_id, content.ciphertext, event.getId(), event.getTs());\n  } catch (e) {\n    if (e.name === \"DecryptionError\") {\n      // re-throw decryption errors as-is\n      throw e;\n    }\n\n    let errorCode = \"OLM_DECRYPT_GROUP_MESSAGE_ERROR\";\n\n    if (e && e.message === 'OLM.UNKNOWN_MESSAGE_INDEX') {\n      this._requestKeysForEvent(event);\n\n      errorCode = 'OLM_UNKNOWN_MESSAGE_INDEX';\n    }\n\n    throw new _base.DecryptionError(errorCode, e ? e.toString() : \"Unknown Error: Error is undefined\", {\n      session: content.sender_key + '|' + content.session_id\n    });\n  }\n\n  if (res === null) {\n    // We've got a message for a session we don't have.\n    //\n    // (XXX: We might actually have received this key since we started\n    // decrypting, in which case we'll have scheduled a retry, and this\n    // request will be redundant. We could probably check to see if the\n    // event is still in the pending list; if not, a retry will have been\n    // scheduled, so we needn't send out the request here.)\n    this._requestKeysForEvent(event); // See if there was a problem with the olm session at the time the\n    // event was sent.  Use a fuzz factor of 2 minutes.\n\n\n    const problem = await this._olmDevice.sessionMayHaveProblems(content.sender_key, event.getTs() - 120000);\n\n    if (problem) {\n      let problemDescription = PROBLEM_DESCRIPTIONS[problem.type] || PROBLEM_DESCRIPTIONS.unknown;\n\n      if (problem.fixed) {\n        problemDescription += \" Trying to create a new secure channel and re-requesting the keys.\";\n      }\n\n      throw new _base.DecryptionError(\"MEGOLM_UNKNOWN_INBOUND_SESSION_ID\", problemDescription, {\n        session: content.sender_key + '|' + content.session_id\n      });\n    }\n\n    throw new _base.DecryptionError(\"MEGOLM_UNKNOWN_INBOUND_SESSION_ID\", \"The sender's device has not sent us the keys for this message.\", {\n      session: content.sender_key + '|' + content.session_id\n    });\n  } // success. We can remove the event from the pending list, if that hasn't\n  // already happened.\n\n\n  this._removeEventFromPendingList(event);\n\n  const payload = JSON.parse(res.result); // belt-and-braces check that the room id matches that indicated by the HS\n  // (this is somewhat redundant, since the megolm session is scoped to the\n  // room, so neither the sender nor a MITM can lie about the room_id).\n\n  if (payload.room_id !== event.getRoomId()) {\n    throw new _base.DecryptionError(\"MEGOLM_BAD_ROOM\", \"Message intended for room \" + payload.room_id);\n  }\n\n  return {\n    clearEvent: payload,\n    senderCurve25519Key: res.senderKey,\n    claimedEd25519Key: res.keysClaimed.ed25519,\n    forwardingCurve25519KeyChain: res.forwardingCurve25519KeyChain\n  };\n};\n\nMegolmDecryption.prototype._requestKeysForEvent = function (event) {\n  const wireContent = event.getWireContent();\n  const recipients = event.getKeyRequestRecipients(this._userId);\n\n  this._crypto.requestRoomKey({\n    room_id: event.getRoomId(),\n    algorithm: wireContent.algorithm,\n    sender_key: wireContent.sender_key,\n    session_id: wireContent.session_id\n  }, recipients);\n};\n/**\n * Add an event to the list of those awaiting their session keys.\n *\n * @private\n *\n * @param {module:models/event.MatrixEvent} event\n */\n\n\nMegolmDecryption.prototype._addEventToPendingList = function (event) {\n  const content = event.getWireContent();\n  const senderKey = content.sender_key;\n  const sessionId = content.session_id;\n\n  if (!this._pendingEvents[senderKey]) {\n    this._pendingEvents[senderKey] = new Map();\n  }\n\n  const senderPendingEvents = this._pendingEvents[senderKey];\n\n  if (!senderPendingEvents.has(sessionId)) {\n    senderPendingEvents.set(sessionId, new Set());\n  }\n\n  senderPendingEvents.get(sessionId).add(event);\n};\n/**\n * Remove an event from the list of those awaiting their session keys.\n *\n * @private\n *\n * @param {module:models/event.MatrixEvent} event\n */\n\n\nMegolmDecryption.prototype._removeEventFromPendingList = function (event) {\n  const content = event.getWireContent();\n  const senderKey = content.sender_key;\n  const sessionId = content.session_id;\n  const senderPendingEvents = this._pendingEvents[senderKey];\n  const pendingEvents = senderPendingEvents && senderPendingEvents.get(sessionId);\n\n  if (!pendingEvents) {\n    return;\n  }\n\n  pendingEvents.delete(event);\n\n  if (pendingEvents.size === 0) {\n    senderPendingEvents.delete(senderKey);\n  }\n\n  if (senderPendingEvents.size === 0) {\n    delete this._pendingEvents[senderKey];\n  }\n};\n/**\n * @inheritdoc\n *\n * @param {module:models/event.MatrixEvent} event key event\n */\n\n\nMegolmDecryption.prototype.onRoomKeyEvent = function (event) {\n  const content = event.getContent();\n  const sessionId = content.session_id;\n  let senderKey = event.getSenderKey();\n  let forwardingKeyChain = [];\n  let exportFormat = false;\n  let keysClaimed;\n\n  if (!content.room_id || !sessionId || !content.session_key) {\n    _logger.logger.error(\"key event is missing fields\");\n\n    return;\n  }\n\n  if (!senderKey) {\n    _logger.logger.error(\"key event has no sender key (not encrypted?)\");\n\n    return;\n  }\n\n  if (event.getType() == \"m.forwarded_room_key\") {\n    exportFormat = true;\n    forwardingKeyChain = content.forwarding_curve25519_key_chain;\n\n    if (!utils.isArray(forwardingKeyChain)) {\n      forwardingKeyChain = [];\n    } // copy content before we modify it\n\n\n    forwardingKeyChain = forwardingKeyChain.slice();\n    forwardingKeyChain.push(senderKey);\n    senderKey = content.sender_key;\n\n    if (!senderKey) {\n      _logger.logger.error(\"forwarded_room_key event is missing sender_key field\");\n\n      return;\n    }\n\n    const ed25519Key = content.sender_claimed_ed25519_key;\n\n    if (!ed25519Key) {\n      _logger.logger.error(`forwarded_room_key_event is missing sender_claimed_ed25519_key field`);\n\n      return;\n    }\n\n    keysClaimed = {\n      ed25519: ed25519Key\n    };\n  } else {\n    keysClaimed = event.getKeysClaimed();\n  }\n\n  _logger.logger.log(`Received and adding key for megolm session ${senderKey}|${sessionId}`);\n\n  return this._olmDevice.addInboundGroupSession(content.room_id, senderKey, forwardingKeyChain, sessionId, content.session_key, keysClaimed, exportFormat).then(() => {\n    // have another go at decrypting events sent with this session.\n    this._retryDecryption(senderKey, sessionId).then(success => {\n      // cancel any outstanding room key requests for this session.\n      // Only do this if we managed to decrypt every message in the\n      // session, because if we didn't, we leave the other key\n      // requests in the hopes that someone sends us a key that\n      // includes an earlier index.\n      if (success) {\n        this._crypto.cancelRoomKeyRequest({\n          algorithm: content.algorithm,\n          room_id: content.room_id,\n          session_id: content.session_id,\n          sender_key: senderKey\n        });\n      }\n    });\n  }).then(() => {\n    if (this._crypto.backupInfo) {\n      // don't wait for the keys to be backed up for the server\n      this._crypto.backupGroupSession(content.room_id, senderKey, forwardingKeyChain, content.session_id, content.session_key, keysClaimed, exportFormat).catch(e => {\n        // This throws if the upload failed, but this is fine\n        // since it will have written it to the db and will retry.\n        _logger.logger.log(\"Failed to back up megolm session\", e);\n      });\n    }\n  }).catch(e => {\n    _logger.logger.error(`Error handling m.room_key_event: ${e}`);\n  });\n};\n/**\n * @inheritdoc\n *\n * @param {module:models/event.MatrixEvent} event key event\n */\n\n\nMegolmDecryption.prototype.onRoomKeyWithheldEvent = async function (event) {\n  const content = event.getContent();\n  const senderKey = content.sender_key;\n\n  if (content.code === \"m.no_olm\") {\n    const sender = event.getSender(); // if the sender says that they haven't been able to establish an olm\n    // session, let's proactively establish one\n    // Note: after we record that the olm session has had a problem, we\n    // trigger retrying decryption for all the messages from the sender's\n    // key, so that we can update the error message to indicate the olm\n    // session problem.\n\n    if (await this._olmDevice.getSessionIdForDevice(senderKey)) {\n      // a session has already been established, so we don't need to\n      // create a new one.\n      await this._olmDevice.recordSessionProblem(senderKey, \"no_olm\", true);\n      this.retryDecryptionFromSender(senderKey);\n      return;\n    }\n\n    const device = this._crypto._deviceList.getDeviceByIdentityKey(content.algorithm, senderKey);\n\n    if (!device) {\n      _logger.logger.info(\"Couldn't find device for identity key \" + senderKey + \": not establishing session\");\n\n      await this._olmDevice.recordSessionProblem(senderKey, \"no_olm\", false);\n      this.retryDecryptionFromSender(senderKey);\n      return;\n    }\n\n    await olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, {\n      [sender]: [device]\n    }, false);\n    const encryptedContent = {\n      algorithm: olmlib.OLM_ALGORITHM,\n      sender_key: this._olmDevice.deviceCurve25519Key,\n      ciphertext: {}\n    };\n    await olmlib.encryptMessageForDevice(encryptedContent.ciphertext, this._userId, this._deviceId, this._olmDevice, sender, device, {\n      type: \"m.dummy\"\n    });\n    await this._olmDevice.recordSessionProblem(senderKey, \"no_olm\", true);\n    this.retryDecryptionFromSender(senderKey);\n    await this._baseApis.sendToDevice(\"m.room.encrypted\", {\n      [sender]: {\n        [device.deviceId]: encryptedContent\n      }\n    });\n  } else {\n    await this._olmDevice.addInboundGroupSessionWithheld(content.room_id, senderKey, content.session_id, content.code, content.reason);\n  }\n};\n/**\n * @inheritdoc\n */\n\n\nMegolmDecryption.prototype.hasKeysForKeyRequest = function (keyRequest) {\n  const body = keyRequest.requestBody;\n  return this._olmDevice.hasInboundSessionKeys(body.room_id, body.sender_key, body.session_id // TODO: ratchet index\n  );\n};\n/**\n * @inheritdoc\n */\n\n\nMegolmDecryption.prototype.shareKeysWithDevice = function (keyRequest) {\n  const userId = keyRequest.userId;\n  const deviceId = keyRequest.deviceId;\n\n  const deviceInfo = this._crypto.getStoredDevice(userId, deviceId);\n\n  const body = keyRequest.requestBody;\n  this.olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, {\n    [userId]: [deviceInfo]\n  }).then(devicemap => {\n    const olmSessionResult = devicemap[userId][deviceId];\n\n    if (!olmSessionResult.sessionId) {\n      // no session with this device, probably because there\n      // were no one-time keys.\n      //\n      // ensureOlmSessionsForUsers has already done the logging,\n      // so just skip it.\n      return null;\n    }\n\n    _logger.logger.log(\"sharing keys for session \" + body.sender_key + \"|\" + body.session_id + \" with device \" + userId + \":\" + deviceId);\n\n    return this._buildKeyForwardingMessage(body.room_id, body.sender_key, body.session_id);\n  }).then(payload => {\n    const encryptedContent = {\n      algorithm: olmlib.OLM_ALGORITHM,\n      sender_key: this._olmDevice.deviceCurve25519Key,\n      ciphertext: {}\n    };\n    return this.olmlib.encryptMessageForDevice(encryptedContent.ciphertext, this._userId, this._deviceId, this._olmDevice, userId, deviceInfo, payload).then(() => {\n      const contentMap = {\n        [userId]: {\n          [deviceId]: encryptedContent\n        }\n      }; // TODO: retries\n\n      return this._baseApis.sendToDevice(\"m.room.encrypted\", contentMap);\n    });\n  });\n};\n\nMegolmDecryption.prototype._buildKeyForwardingMessage = async function (roomId, senderKey, sessionId) {\n  const key = await this._olmDevice.getInboundGroupSessionKey(roomId, senderKey, sessionId);\n  return {\n    type: \"m.forwarded_room_key\",\n    content: {\n      algorithm: olmlib.MEGOLM_ALGORITHM,\n      room_id: roomId,\n      sender_key: senderKey,\n      sender_claimed_ed25519_key: key.sender_claimed_ed25519_key,\n      session_id: sessionId,\n      session_key: key.key,\n      chain_index: key.chain_index,\n      forwarding_curve25519_key_chain: key.forwarding_curve25519_key_chain\n    }\n  };\n};\n/**\n * @inheritdoc\n *\n * @param {module:crypto/OlmDevice.MegolmSessionData} session\n */\n\n\nMegolmDecryption.prototype.importRoomKey = function (session) {\n  return this._olmDevice.addInboundGroupSession(session.room_id, session.sender_key, session.forwarding_curve25519_key_chain, session.session_id, session.session_key, session.sender_claimed_keys, true).then(() => {\n    if (this._crypto.backupInfo) {\n      // don't wait for it to complete\n      this._crypto.backupGroupSession(session.room_id, session.sender_key, session.forwarding_curve25519_key_chain, session.session_id, session.session_key, session.sender_claimed_keys, true).catch(e => {\n        // This throws if the upload failed, but this is fine\n        // since it will have written it to the db and will retry.\n        _logger.logger.log(\"Failed to back up megolm session\", e);\n      });\n    } // have another go at decrypting events sent with this session.\n\n\n    this._retryDecryption(session.sender_key, session.session_id);\n  });\n};\n/**\n * Have another go at decrypting events after we receive a key\n *\n * @private\n * @param {String} senderKey\n * @param {String} sessionId\n *\n * @return {Boolean} whether all messages were successfully decrypted\n */\n\n\nMegolmDecryption.prototype._retryDecryption = async function (senderKey, sessionId) {\n  const senderPendingEvents = this._pendingEvents[senderKey];\n\n  if (!senderPendingEvents) {\n    return true;\n  }\n\n  const pending = senderPendingEvents.get(sessionId);\n\n  if (!pending) {\n    return true;\n  }\n\n  pending.delete(sessionId);\n\n  if (pending.size === 0) {\n    this._pendingEvents[senderKey];\n  }\n\n  await Promise.all([...pending].map(async ev => {\n    try {\n      await ev.attemptDecryption(this._crypto);\n    } catch (e) {// don't die if something goes wrong\n    }\n  })); // ev.attemptDecryption will re-add to this._pendingEvents if an event\n  // couldn't be decrypted\n\n  return !(this._pendingEvents[senderKey] || {})[sessionId];\n};\n\nMegolmDecryption.prototype.retryDecryptionFromSender = async function (senderKey) {\n  const senderPendingEvents = this._pendingEvents[senderKey];\n\n  _logger.logger.warn(senderPendingEvents);\n\n  if (!senderPendingEvents) {\n    return true;\n  }\n\n  delete this._pendingEvents[senderKey];\n  await Promise.all([...senderPendingEvents].map(async ([_sessionId, pending]) => {\n    await Promise.all([...pending].map(async ev => {\n      try {\n        _logger.logger.warn(ev.getId());\n\n        await ev.attemptDecryption(this._crypto);\n      } catch (e) {// don't die if something goes wrong\n      }\n    }));\n  }));\n  return !this._pendingEvents[senderKey];\n};\n\n(0, _base.registerAlgorithm)(olmlib.MEGOLM_ALGORITHM, MegolmEncryption, MegolmDecryption);","map":{"version":3,"sources":["/home/kimist/Developpement/React/watcha_client/node_modules/matrix-js-sdk/lib/crypto/algorithms/megolm.js"],"names":["_interopRequireWildcard","require","_logger","utils","olmlib","_base","_OlmDevice","OutboundSessionInfo","sessionId","useCount","creationTime","Date","getTime","sharedWithDevices","blockedDevicesNotified","prototype","needsRotation","rotationPeriodMsgs","rotationPeriodMs","sessionLifetime","logger","log","markSharedWithDevice","userId","deviceId","chainIndex","markNotifiedBlockedDevice","sharedWithTooManyDevices","devicesInRoom","hasOwnProperty","MegolmEncryption","params","polyfillSuper","EncryptionAlgorithm","_setupPromise","Promise","resolve","_outboundSessions","_sessionRotationPeriodMsgs","_sessionRotationPeriodMs","config","rotation_period_ms","undefined","rotation_period_msgs","inherits","_ensureOutboundSession","blocked","self","session","prepareSession","oldSession","_roomId","_prepareNewSession","shareMap","userDevices","deviceInfo","key","getIdentityKey","_olmDevice","deviceCurve25519Key","push","errorDevices","_shareKeyWithDevices","blockedMap","userBlockedDevices","filteredErrorDevices","filterOutNotifiedErrorDevices","code","reason","WITHHELD_MESSAGES","_notifyBlockedDevices","returnSession","prom","then","createOutboundGroupSession","getOutboundGroupSessionKey","addInboundGroupSession","ed25519","deviceEd25519Key","_crypto","backupInfo","backupGroupSession","catch","e","_splitUserDeviceMap","devicemap","devicesByUser","maxUsersPerRequest","mapSlices","currentSliceId","entriesInCurrentSlice","Object","keys","devicesToShareWith","sessionResults","i","length","sessionResult","_splitBlockedDevices","currentSlice","userBlockedDevicesToShareWith","blockedInfo","pop","_encryptAndSendKeysToDevices","userDeviceMap","payload","contentMap","promises","encryptedContent","algorithm","OLM_ALGORITHM","sender_key","ciphertext","val","encryptMessageForDevice","_userId","_deviceId","all","_baseApis","sendToDevice","_sendBlockedNotificationsToDevices","message","assign","room_id","session_id","reshareKeyWithDevice","senderKey","device","obSessionInfo","debug","sentChainIndex","getInboundGroupSessionKey","warn","ensureOlmSessionsForDevices","type","content","MEGOLM_ALGORITHM","session_key","chain_index","sender_claimed_ed25519_key","forwarding_curve25519_key_chain","userDeviceMaps","encryptMessage","room","eventType","_getDevicesInRoom","getGlobalErrorOnUnknownDevices","_checkForUnknownDevices","payloadJson","encryptGroupMessage","JSON","stringify","device_id","forceDiscardSession","unknownDevices","forEach","isUnverified","isKnown","UnknownDeviceError","members","getEncryptionTargetMembers","roomMembers","map","u","isBlacklisting","getGlobalBlacklistUnverifiedDevices","getBlacklistUnverifiedDevices","devices","downloadKeys","isBlocked","MegolmDecryption","DecryptionAlgorithm","_pendingEvents","PROBLEM_DESCRIPTIONS","no_olm","unknown","decryptEvent","event","getWireContent","DecryptionError","_addEventToPendingList","res","decryptGroupMessage","getRoomId","getId","getTs","name","errorCode","_requestKeysForEvent","toString","problem","sessionMayHaveProblems","problemDescription","fixed","_removeEventFromPendingList","parse","result","clearEvent","senderCurve25519Key","claimedEd25519Key","keysClaimed","forwardingCurve25519KeyChain","wireContent","recipients","getKeyRequestRecipients","requestRoomKey","Map","senderPendingEvents","has","set","Set","get","add","pendingEvents","delete","size","onRoomKeyEvent","getContent","getSenderKey","forwardingKeyChain","exportFormat","error","getType","isArray","slice","ed25519Key","getKeysClaimed","_retryDecryption","success","cancelRoomKeyRequest","onRoomKeyWithheldEvent","sender","getSender","getSessionIdForDevice","recordSessionProblem","retryDecryptionFromSender","_deviceList","getDeviceByIdentityKey","info","addInboundGroupSessionWithheld","hasKeysForKeyRequest","keyRequest","body","requestBody","hasInboundSessionKeys","shareKeysWithDevice","getStoredDevice","olmSessionResult","_buildKeyForwardingMessage","roomId","importRoomKey","sender_claimed_keys","pending","ev","attemptDecryption","_sessionId","registerAlgorithm"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _logger = require(\"../../logger\");\n\nvar utils = _interopRequireWildcard(require(\"../../utils\"));\n\nvar olmlib = _interopRequireWildcard(require(\"../olmlib\"));\n\nvar _base = require(\"./base\");\n\nvar _OlmDevice = require(\"../OlmDevice\");\n\n/*\nCopyright 2015, 2016 OpenMarket Ltd\nCopyright 2018 New Vector Ltd\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Defines m.olm encryption/decryption\n *\n * @module crypto/algorithms/megolm\n */\n\n/**\n * @private\n * @constructor\n *\n * @param {string} sessionId\n *\n * @property {string} sessionId\n * @property {Number} useCount     number of times this session has been used\n * @property {Number} creationTime when the session was created (ms since the epoch)\n *\n * @property {object} sharedWithDevices\n *    devices with which we have shared the session key\n *        userId -> {deviceId -> msgindex}\n */\nfunction OutboundSessionInfo(sessionId) {\n  this.sessionId = sessionId;\n  this.useCount = 0;\n  this.creationTime = new Date().getTime();\n  this.sharedWithDevices = {};\n  this.blockedDevicesNotified = {};\n}\n/**\n * Check if it's time to rotate the session\n *\n * @param {Number} rotationPeriodMsgs\n * @param {Number} rotationPeriodMs\n * @return {Boolean}\n */\n\n\nOutboundSessionInfo.prototype.needsRotation = function (rotationPeriodMsgs, rotationPeriodMs) {\n  const sessionLifetime = new Date().getTime() - this.creationTime;\n\n  if (this.useCount >= rotationPeriodMsgs || sessionLifetime >= rotationPeriodMs) {\n    _logger.logger.log(\"Rotating megolm session after \" + this.useCount + \" messages, \" + sessionLifetime + \"ms\");\n\n    return true;\n  }\n\n  return false;\n};\n\nOutboundSessionInfo.prototype.markSharedWithDevice = function (userId, deviceId, chainIndex) {\n  if (!this.sharedWithDevices[userId]) {\n    this.sharedWithDevices[userId] = {};\n  }\n\n  this.sharedWithDevices[userId][deviceId] = chainIndex;\n};\n\nOutboundSessionInfo.prototype.markNotifiedBlockedDevice = function (userId, deviceId) {\n  if (!this.blockedDevicesNotified[userId]) {\n    this.blockedDevicesNotified[userId] = {};\n  }\n\n  this.blockedDevicesNotified[userId][deviceId] = true;\n};\n/**\n * Determine if this session has been shared with devices which it shouldn't\n * have been.\n *\n * @param {Object} devicesInRoom userId -> {deviceId -> object}\n *   devices we should shared the session with.\n *\n * @return {Boolean} true if we have shared the session with devices which aren't\n * in devicesInRoom.\n */\n\n\nOutboundSessionInfo.prototype.sharedWithTooManyDevices = function (devicesInRoom) {\n  for (const userId in this.sharedWithDevices) {\n    if (!this.sharedWithDevices.hasOwnProperty(userId)) {\n      continue;\n    }\n\n    if (!devicesInRoom.hasOwnProperty(userId)) {\n      _logger.logger.log(\"Starting new megolm session because we shared with \" + userId);\n\n      return true;\n    }\n\n    for (const deviceId in this.sharedWithDevices[userId]) {\n      if (!this.sharedWithDevices[userId].hasOwnProperty(deviceId)) {\n        continue;\n      }\n\n      if (!devicesInRoom[userId].hasOwnProperty(deviceId)) {\n        _logger.logger.log(\"Starting new megolm session because we shared with \" + userId + \":\" + deviceId);\n\n        return true;\n      }\n    }\n  }\n};\n/**\n * Megolm encryption implementation\n *\n * @constructor\n * @extends {module:crypto/algorithms/EncryptionAlgorithm}\n *\n * @param {object} params parameters, as per\n *     {@link module:crypto/algorithms/EncryptionAlgorithm}\n */\n\n\nfunction MegolmEncryption(params) {\n  (0, utils.polyfillSuper)(this, _base.EncryptionAlgorithm, params); // the most recent attempt to set up a session. This is used to serialise\n  // the session setups, so that we have a race-free view of which session we\n  // are using, and which devices we have shared the keys with. It resolves\n  // with an OutboundSessionInfo (or undefined, for the first message in the\n  // room).\n\n  this._setupPromise = Promise.resolve(); // Map of outbound sessions by sessions ID. Used if we need a particular\n  // session (the session we're currently using to send is always obtained\n  // using _setupPromise).\n\n  this._outboundSessions = {}; // default rotation periods\n\n  this._sessionRotationPeriodMsgs = 100;\n  this._sessionRotationPeriodMs = 7 * 24 * 3600 * 1000;\n\n  if (params.config.rotation_period_ms !== undefined) {\n    this._sessionRotationPeriodMs = params.config.rotation_period_ms;\n  }\n\n  if (params.config.rotation_period_msgs !== undefined) {\n    this._sessionRotationPeriodMsgs = params.config.rotation_period_msgs;\n  }\n}\n\nutils.inherits(MegolmEncryption, _base.EncryptionAlgorithm);\n/**\n * @private\n *\n * @param {Object} devicesInRoom The devices in this room, indexed by user ID\n * @param {Object} blocked The devices that are blocked, indexed by user ID\n *\n * @return {module:client.Promise} Promise which resolves to the\n *    OutboundSessionInfo when setup is complete.\n */\n\nMegolmEncryption.prototype._ensureOutboundSession = async function (devicesInRoom, blocked) {\n  const self = this;\n  let session; // takes the previous OutboundSessionInfo, and considers whether to create\n  // a new one. Also shares the key with any (new) devices in the room.\n  // Updates `session` to hold the final OutboundSessionInfo.\n  //\n  // returns a promise which resolves once the keyshare is successful.\n\n  async function prepareSession(oldSession) {\n    session = oldSession; // need to make a brand new session?\n\n    if (session && session.needsRotation(self._sessionRotationPeriodMsgs, self._sessionRotationPeriodMs)) {\n      _logger.logger.log(\"Starting new megolm session because we need to rotate.\");\n\n      session = null;\n    } // determine if we have shared with anyone we shouldn't have\n\n\n    if (session && session.sharedWithTooManyDevices(devicesInRoom)) {\n      session = null;\n    }\n\n    if (!session) {\n      _logger.logger.log(`Starting new megolm session for room ${self._roomId}`);\n\n      session = await self._prepareNewSession();\n\n      _logger.logger.log(`Started new megolm session ${session.sessionId} ` + `for room ${self._roomId}`);\n\n      self._outboundSessions[session.sessionId] = session;\n    } // now check if we need to share with any devices\n\n\n    const shareMap = {};\n\n    for (const userId in devicesInRoom) {\n      if (!devicesInRoom.hasOwnProperty(userId)) {\n        continue;\n      }\n\n      const userDevices = devicesInRoom[userId];\n\n      for (const deviceId in userDevices) {\n        if (!userDevices.hasOwnProperty(deviceId)) {\n          continue;\n        }\n\n        const deviceInfo = userDevices[deviceId];\n        const key = deviceInfo.getIdentityKey();\n\n        if (key == self._olmDevice.deviceCurve25519Key) {\n          // don't bother sending to ourself\n          continue;\n        }\n\n        if (!session.sharedWithDevices[userId] || session.sharedWithDevices[userId][deviceId] === undefined) {\n          shareMap[userId] = shareMap[userId] || [];\n          shareMap[userId].push(deviceInfo);\n        }\n      }\n    }\n\n    const errorDevices = [];\n    await self._shareKeyWithDevices(session, shareMap, errorDevices); // are there any new blocked devices that we need to notify?\n\n    const blockedMap = {};\n\n    for (const userId in blocked) {\n      if (!blocked.hasOwnProperty(userId)) {\n        continue;\n      }\n\n      const userBlockedDevices = blocked[userId];\n\n      for (const deviceId in userBlockedDevices) {\n        if (!userBlockedDevices.hasOwnProperty(deviceId)) {\n          continue;\n        }\n\n        if (!session.blockedDevicesNotified[userId] || session.blockedDevicesNotified[userId][deviceId] === undefined) {\n          blockedMap[userId] = blockedMap[userId] || [];\n          blockedMap[userId].push(userBlockedDevices[deviceId]);\n        }\n      }\n    }\n\n    const filteredErrorDevices = await self._olmDevice.filterOutNotifiedErrorDevices(errorDevices);\n\n    for (const {\n      userId,\n      deviceInfo\n    } of filteredErrorDevices) {\n      blockedMap[userId] = blockedMap[userId] || [];\n      blockedMap[userId].push({\n        code: \"m.no_olm\",\n        reason: _OlmDevice.WITHHELD_MESSAGES[\"m.no_olm\"],\n        deviceInfo\n      });\n    } // notify blocked devices that they're blocked\n\n\n    await self._notifyBlockedDevices(session, blockedMap);\n  } // helper which returns the session prepared by prepareSession\n\n\n  function returnSession() {\n    return session;\n  } // first wait for the previous share to complete\n\n\n  const prom = this._setupPromise.then(prepareSession); // _setupPromise resolves to `session` whether or not the share succeeds\n\n\n  this._setupPromise = prom.then(returnSession, returnSession); // but we return a promise which only resolves if the share was successful.\n\n  return prom.then(returnSession);\n};\n/**\n * @private\n *\n * @return {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n */\n\n\nMegolmEncryption.prototype._prepareNewSession = async function () {\n  const sessionId = this._olmDevice.createOutboundGroupSession();\n\n  const key = this._olmDevice.getOutboundGroupSessionKey(sessionId);\n\n  await this._olmDevice.addInboundGroupSession(this._roomId, this._olmDevice.deviceCurve25519Key, [], sessionId, key.key, {\n    ed25519: this._olmDevice.deviceEd25519Key\n  });\n\n  if (this._crypto.backupInfo) {\n    // don't wait for it to complete\n    this._crypto.backupGroupSession(this._roomId, this._olmDevice.deviceCurve25519Key, [], sessionId, key.key).catch(e => {\n      // This throws if the upload failed, but this is fine\n      // since it will have written it to the db and will retry.\n      _logger.logger.log(\"Failed to back up megolm session\", e);\n    });\n  }\n\n  return new OutboundSessionInfo(sessionId);\n};\n/**\n * Splits the user device map into multiple chunks to reduce the number of\n * devices we encrypt to per API call. Also filters out devices we don't have\n * a session with.\n *\n * @private\n *\n * @param {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n *\n * @param {number} chainIndex current chain index\n *\n * @param {object<userId, deviceId>} devicemap\n *   mapping from userId to deviceId to {@link module:crypto~OlmSessionResult}\n *\n * @param {object<string, module:crypto/deviceinfo[]>} devicesByUser\n *    map from userid to list of devices\n *\n * @param {array<object>} errorDevices\n *    array that will be populated with the devices that can't get an\n *    olm session for\n *\n * @return {array<object<userid, deviceInfo>>}\n */\n\n\nMegolmEncryption.prototype._splitUserDeviceMap = function (session, chainIndex, devicemap, devicesByUser, errorDevices) {\n  const maxUsersPerRequest = 20; // use an array where the slices of a content map gets stored\n\n  const mapSlices = [];\n  let currentSliceId = 0; // start inserting in the first slice\n\n  let entriesInCurrentSlice = 0;\n\n  for (const userId of Object.keys(devicesByUser)) {\n    const devicesToShareWith = devicesByUser[userId];\n    const sessionResults = devicemap[userId];\n\n    for (let i = 0; i < devicesToShareWith.length; i++) {\n      const deviceInfo = devicesToShareWith[i];\n      const deviceId = deviceInfo.deviceId;\n      const sessionResult = sessionResults[deviceId];\n\n      if (!sessionResult.sessionId) {\n        // no session with this device, probably because there\n        // were no one-time keys.\n        //\n        // we could send them a to_device message anyway, as a\n        // signal that they have missed out on the key sharing\n        // message because of the lack of keys, but there's not\n        // much point in that really; it will mostly serve to clog\n        // up to_device inboxes.\n        // mark this device as \"handled\" because we don't want to try\n        // to claim a one-time-key for dead devices on every message.\n        session.markSharedWithDevice(userId, deviceId, chainIndex);\n        errorDevices.push({\n          userId,\n          deviceInfo\n        }); // ensureOlmSessionsForUsers has already done the logging,\n        // so just skip it.\n\n        continue;\n      }\n\n      _logger.logger.log(\"share keys with device \" + userId + \":\" + deviceId);\n\n      if (!mapSlices[currentSliceId]) {\n        mapSlices[currentSliceId] = [];\n      }\n\n      mapSlices[currentSliceId].push({\n        userId: userId,\n        deviceInfo: deviceInfo\n      });\n      entriesInCurrentSlice++;\n    } // We do this in the per-user loop as we prefer that all messages to the\n    // same user end up in the same API call to make it easier for the\n    // server (e.g. only have to send one EDU if a remote user, etc). This\n    // does mean that if a user has many devices we may go over the desired\n    // limit, but its not a hard limit so that is fine.\n\n\n    if (entriesInCurrentSlice > maxUsersPerRequest) {\n      // the current slice is filled up. Start inserting into the next slice\n      entriesInCurrentSlice = 0;\n      currentSliceId++;\n    }\n  }\n\n  return mapSlices;\n};\n/**\n * Splits the user device map into multiple chunks to reduce the number of\n * devices we encrypt to per API call.\n *\n * @private\n *\n * @param {object} devicesByUser map from userid to list of devices\n *\n * @return {array<array<object>>} the blocked devices, split into chunks\n */\n\n\nMegolmEncryption.prototype._splitBlockedDevices = function (devicesByUser) {\n  const maxUsersPerRequest = 20; // use an array where the slices of a content map gets stored\n\n  let currentSlice = [];\n  const mapSlices = [currentSlice];\n\n  for (const userId of Object.keys(devicesByUser)) {\n    const userBlockedDevicesToShareWith = devicesByUser[userId];\n\n    for (const blockedInfo of userBlockedDevicesToShareWith) {\n      currentSlice.push({\n        userId: userId,\n        blockedInfo: blockedInfo\n      });\n    } // We do this in the per-user loop as we prefer that all messages to the\n    // same user end up in the same API call to make it easier for the\n    // server (e.g. only have to send one EDU if a remote user, etc). This\n    // does mean that if a user has many devices we may go over the desired\n    // limit, but its not a hard limit so that is fine.\n\n\n    if (currentSlice.length > maxUsersPerRequest) {\n      // the current slice is filled up. Start inserting into the next slice\n      currentSlice = [];\n      mapSlices.push(currentSlice);\n    }\n  }\n\n  if (currentSlice.length === 0) {\n    mapSlices.pop();\n  }\n\n  return mapSlices;\n};\n/**\n * @private\n *\n * @param {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n *\n * @param {number} chainIndex current chain index\n *\n * @param {object<userId, deviceInfo>} userDeviceMap\n *   mapping from userId to deviceInfo\n *\n * @param {object} payload fields to include in the encrypted payload\n *\n * @return {module:client.Promise} Promise which resolves once the key sharing\n *     for the given userDeviceMap is generated and has been sent.\n */\n\n\nMegolmEncryption.prototype._encryptAndSendKeysToDevices = function (session, chainIndex, userDeviceMap, payload) {\n  const contentMap = {};\n  const promises = [];\n\n  for (let i = 0; i < userDeviceMap.length; i++) {\n    const encryptedContent = {\n      algorithm: olmlib.OLM_ALGORITHM,\n      sender_key: this._olmDevice.deviceCurve25519Key,\n      ciphertext: {}\n    };\n    const val = userDeviceMap[i];\n    const userId = val.userId;\n    const deviceInfo = val.deviceInfo;\n    const deviceId = deviceInfo.deviceId;\n\n    if (!contentMap[userId]) {\n      contentMap[userId] = {};\n    }\n\n    contentMap[userId][deviceId] = encryptedContent;\n    promises.push(olmlib.encryptMessageForDevice(encryptedContent.ciphertext, this._userId, this._deviceId, this._olmDevice, userId, deviceInfo, payload));\n  }\n\n  return Promise.all(promises).then(() => {\n    return this._baseApis.sendToDevice(\"m.room.encrypted\", contentMap).then(() => {\n      // store that we successfully uploaded the keys of the current slice\n      for (const userId of Object.keys(contentMap)) {\n        for (const deviceId of Object.keys(contentMap[userId])) {\n          session.markSharedWithDevice(userId, deviceId, chainIndex);\n        }\n      }\n    });\n  });\n};\n/**\n * @private\n *\n * @param {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n *\n * @param {array<object>} userDeviceMap list of blocked devices to notify\n *\n * @param {object} payload fields to include in the notification payload\n *\n * @return {module:client.Promise} Promise which resolves once the notifications\n *     for the given userDeviceMap is generated and has been sent.\n */\n\n\nMegolmEncryption.prototype._sendBlockedNotificationsToDevices = async function (session, userDeviceMap, payload) {\n  const contentMap = {};\n\n  for (const val of userDeviceMap) {\n    const userId = val.userId;\n    const blockedInfo = val.blockedInfo;\n    const deviceInfo = blockedInfo.deviceInfo;\n    const deviceId = deviceInfo.deviceId;\n    const message = Object.assign({}, payload);\n    message.code = blockedInfo.code;\n    message.reason = blockedInfo.reason;\n\n    if (message.code === \"m.no_olm\") {\n      delete message.room_id;\n      delete message.session_id;\n    }\n\n    if (!contentMap[userId]) {\n      contentMap[userId] = {};\n    }\n\n    contentMap[userId][deviceId] = message;\n  }\n\n  await this._baseApis.sendToDevice(\"org.matrix.room_key.withheld\", contentMap); // store that we successfully uploaded the keys of the current slice\n\n  for (const userId of Object.keys(contentMap)) {\n    for (const deviceId of Object.keys(contentMap[userId])) {\n      session.markNotifiedBlockedDevice(userId, deviceId);\n    }\n  }\n};\n/**\n * Re-shares a megolm session key with devices if the key has already been\n * sent to them.\n *\n * @param {string} senderKey The key of the originating device for the session\n * @param {string} sessionId ID of the outbound session to share\n * @param {string} userId ID of the user who owns the target device\n * @param {module:crypto/deviceinfo} device The target device\n */\n\n\nMegolmEncryption.prototype.reshareKeyWithDevice = async function (senderKey, sessionId, userId, device) {\n  const obSessionInfo = this._outboundSessions[sessionId];\n\n  if (!obSessionInfo) {\n    _logger.logger.debug(`megolm session ${sessionId} not found: not re-sharing keys`);\n\n    return;\n  } // The chain index of the key we previously sent this device\n\n\n  if (obSessionInfo.sharedWithDevices[userId] === undefined) {\n    _logger.logger.debug(`megolm session ${sessionId} never shared with user ${userId}`);\n\n    return;\n  }\n\n  const sentChainIndex = obSessionInfo.sharedWithDevices[userId][device.deviceId];\n\n  if (sentChainIndex === undefined) {\n    _logger.logger.debug(\"megolm session ID \" + sessionId + \" never shared with device \" + userId + \":\" + device.deviceId);\n\n    return;\n  } // get the key from the inbound session: the outbound one will already\n  // have been ratcheted to the next chain index.\n\n\n  const key = await this._olmDevice.getInboundGroupSessionKey(this._roomId, senderKey, sessionId, sentChainIndex);\n\n  if (!key) {\n    _logger.logger.warn(`No inbound session key found for megolm ${sessionId}: not re-sharing keys`);\n\n    return;\n  }\n\n  await olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, {\n    [userId]: {\n      [device.deviceId]: device\n    }\n  });\n  const payload = {\n    type: \"m.forwarded_room_key\",\n    content: {\n      algorithm: olmlib.MEGOLM_ALGORITHM,\n      room_id: this._roomId,\n      session_id: sessionId,\n      session_key: key.key,\n      chain_index: key.chain_index,\n      sender_key: senderKey,\n      sender_claimed_ed25519_key: key.sender_claimed_ed25519_key,\n      forwarding_curve25519_key_chain: key.forwarding_curve25519_key_chain\n    }\n  };\n  const encryptedContent = {\n    algorithm: olmlib.OLM_ALGORITHM,\n    sender_key: this._olmDevice.deviceCurve25519Key,\n    ciphertext: {}\n  };\n  await olmlib.encryptMessageForDevice(encryptedContent.ciphertext, this._userId, this._deviceId, this._olmDevice, userId, device, payload);\n  await this._baseApis.sendToDevice(\"m.room.encrypted\", {\n    [userId]: {\n      [device.deviceId]: encryptedContent\n    }\n  });\n\n  _logger.logger.debug(`Re-shared key for megolm session ${sessionId} ` + `with ${userId}:${device.deviceId}`);\n};\n/**\n * @param {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n *\n * @param {object<string, module:crypto/deviceinfo[]>} devicesByUser\n *    map from userid to list of devices\n *\n * @param {array<object>} errorDevices\n *    array that will be populated with the devices that we can't get an\n *    olm session for\n */\n\n\nMegolmEncryption.prototype._shareKeyWithDevices = async function (session, devicesByUser, errorDevices) {\n  const key = this._olmDevice.getOutboundGroupSessionKey(session.sessionId);\n\n  const payload = {\n    type: \"m.room_key\",\n    content: {\n      algorithm: olmlib.MEGOLM_ALGORITHM,\n      room_id: this._roomId,\n      session_id: session.sessionId,\n      session_key: key.key,\n      chain_index: key.chain_index\n    }\n  };\n  const devicemap = await olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, devicesByUser);\n\n  const userDeviceMaps = this._splitUserDeviceMap(session, key.chain_index, devicemap, devicesByUser, errorDevices);\n\n  for (let i = 0; i < userDeviceMaps.length; i++) {\n    try {\n      await this._encryptAndSendKeysToDevices(session, key.chain_index, userDeviceMaps[i], payload);\n\n      _logger.logger.log(`Completed megolm keyshare for ${session.sessionId} ` + `in ${this._roomId} (slice ${i + 1}/${userDeviceMaps.length})`);\n    } catch (e) {\n      _logger.logger.log(`megolm keyshare for ${session.sessionId} in ${this._roomId} ` + `(slice ${i + 1}/${userDeviceMaps.length}) failed`);\n\n      throw e;\n    }\n  }\n};\n/**\n * Notify blocked devices that they have been blocked.\n *\n * @param {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n *\n * @param {object<string, object>} devicesByUser\n *    map from userid to device ID to blocked data\n */\n\n\nMegolmEncryption.prototype._notifyBlockedDevices = async function (session, devicesByUser) {\n  const payload = {\n    room_id: this._roomId,\n    session_id: session.sessionId,\n    algorithm: olmlib.MEGOLM_ALGORITHM,\n    sender_key: this._olmDevice.deviceCurve25519Key\n  };\n\n  const userDeviceMaps = this._splitBlockedDevices(devicesByUser);\n\n  for (let i = 0; i < userDeviceMaps.length; i++) {\n    try {\n      await this._sendBlockedNotificationsToDevices(session, userDeviceMaps[i], payload);\n\n      _logger.logger.log(`Completed blacklist notification for ${session.sessionId} ` + `in ${this._roomId} (slice ${i + 1}/${userDeviceMaps.length})`);\n    } catch (e) {\n      _logger.logger.log(`blacklist notification for ${session.sessionId} in ` + `${this._roomId} (slice ${i + 1}/${userDeviceMaps.length}) failed`);\n\n      throw e;\n    }\n  }\n};\n/**\n * @inheritdoc\n *\n * @param {module:models/room} room\n * @param {string} eventType\n * @param {object} content plaintext event content\n *\n * @return {module:client.Promise} Promise which resolves to the new event body\n */\n\n\nMegolmEncryption.prototype.encryptMessage = async function (room, eventType, content) {\n  const self = this;\n\n  _logger.logger.log(`Starting to encrypt event for ${this._roomId}`);\n\n  const [devicesInRoom, blocked] = await this._getDevicesInRoom(room); // check if any of these devices are not yet known to the user.\n  // if so, warn the user so they can verify or ignore.\n\n  if (this._crypto.getGlobalErrorOnUnknownDevices()) {\n    self._checkForUnknownDevices(devicesInRoom);\n  }\n\n  const session = await self._ensureOutboundSession(devicesInRoom, blocked);\n  const payloadJson = {\n    room_id: self._roomId,\n    type: eventType,\n    content: content\n  };\n\n  const ciphertext = self._olmDevice.encryptGroupMessage(session.sessionId, JSON.stringify(payloadJson));\n\n  const encryptedContent = {\n    algorithm: olmlib.MEGOLM_ALGORITHM,\n    sender_key: self._olmDevice.deviceCurve25519Key,\n    ciphertext: ciphertext,\n    session_id: session.sessionId,\n    // Include our device ID so that recipients can send us a\n    // m.new_device message if they don't have our session key.\n    // XXX: Do we still need this now that m.new_device messages\n    // no longer exist since #483?\n    device_id: self._deviceId\n  };\n  session.useCount++;\n  return encryptedContent;\n};\n/**\n * Forces the current outbound group session to be discarded such\n * that another one will be created next time an event is sent.\n *\n * This should not normally be necessary.\n */\n\n\nMegolmEncryption.prototype.forceDiscardSession = function () {\n  this._setupPromise = this._setupPromise.then(() => null);\n};\n/**\n * Checks the devices we're about to send to and see if any are entirely\n * unknown to the user.  If so, warn the user, and mark them as known to\n * give the user a chance to go verify them before re-sending this message.\n *\n * @param {Object} devicesInRoom userId -> {deviceId -> object}\n *   devices we should shared the session with.\n */\n\n\nMegolmEncryption.prototype._checkForUnknownDevices = function (devicesInRoom) {\n  const unknownDevices = {};\n  Object.keys(devicesInRoom).forEach(userId => {\n    Object.keys(devicesInRoom[userId]).forEach(deviceId => {\n      const device = devicesInRoom[userId][deviceId];\n\n      if (device.isUnverified() && !device.isKnown()) {\n        if (!unknownDevices[userId]) {\n          unknownDevices[userId] = {};\n        }\n\n        unknownDevices[userId][deviceId] = device;\n      }\n    });\n  });\n\n  if (Object.keys(unknownDevices).length) {\n    // it'd be kind to pass unknownDevices up to the user in this error\n    throw new _base.UnknownDeviceError(\"This room contains unknown devices which have not been verified. \" + \"We strongly recommend you verify them before continuing.\", unknownDevices);\n  }\n};\n/**\n * Get the list of unblocked devices for all users in the room\n *\n * @param {module:models/room} room\n *\n * @return {module:client.Promise} Promise which resolves to an array whose\n *     first element is a map from userId to deviceId to deviceInfo indicating\n *     the devices that messages should be encrypted to, and whose second\n *     element is a map from userId to deviceId to data indicating the devices\n *     that are in the room but that have been blocked\n */\n\n\nMegolmEncryption.prototype._getDevicesInRoom = async function (room) {\n  const members = await room.getEncryptionTargetMembers();\n  const roomMembers = utils.map(members, function (u) {\n    return u.userId;\n  }); // The global value is treated as a default for when rooms don't specify a value.\n\n  let isBlacklisting = this._crypto.getGlobalBlacklistUnverifiedDevices();\n\n  if (typeof room.getBlacklistUnverifiedDevices() === 'boolean') {\n    isBlacklisting = room.getBlacklistUnverifiedDevices();\n  } // We are happy to use a cached version here: we assume that if we already\n  // have a list of the user's devices, then we already share an e2e room\n  // with them, which means that they will have announced any new devices via\n  // device_lists in their /sync response.  This cache should then be maintained\n  // using all the device_lists changes and left fields.\n  // See https://github.com/vector-im/riot-web/issues/2305 for details.\n\n\n  const devices = await this._crypto.downloadKeys(roomMembers, false);\n  const blocked = {}; // remove any blocked devices\n\n  for (const userId in devices) {\n    if (!devices.hasOwnProperty(userId)) {\n      continue;\n    }\n\n    const userDevices = devices[userId];\n\n    for (const deviceId in userDevices) {\n      if (!userDevices.hasOwnProperty(deviceId)) {\n        continue;\n      }\n\n      if (userDevices[deviceId].isBlocked() || userDevices[deviceId].isUnverified() && isBlacklisting) {\n        if (!blocked[userId]) {\n          blocked[userId] = {};\n        }\n\n        const blockedInfo = userDevices[deviceId].isBlocked() ? {\n          code: \"m.blacklisted\",\n          reason: _OlmDevice.WITHHELD_MESSAGES[\"m.blacklisted\"]\n        } : {\n          code: \"m.unverified\",\n          reason: _OlmDevice.WITHHELD_MESSAGES[\"m.unverified\"]\n        };\n        blockedInfo.deviceInfo = userDevices[deviceId];\n        blocked[userId][deviceId] = blockedInfo;\n        delete userDevices[deviceId];\n      }\n    }\n  }\n\n  return [devices, blocked];\n};\n/**\n * Megolm decryption implementation\n *\n * @constructor\n * @extends {module:crypto/algorithms/DecryptionAlgorithm}\n *\n * @param {object} params parameters, as per\n *     {@link module:crypto/algorithms/DecryptionAlgorithm}\n */\n\n\nfunction MegolmDecryption(params) {\n  (0, utils.polyfillSuper)(this, _base.DecryptionAlgorithm, params); // events which we couldn't decrypt due to unknown sessions / indexes: map from\n  // senderKey|sessionId to Set of MatrixEvents\n\n  this._pendingEvents = {}; // this gets stubbed out by the unit tests.\n\n  this.olmlib = olmlib;\n}\n\nutils.inherits(MegolmDecryption, _base.DecryptionAlgorithm);\nconst PROBLEM_DESCRIPTIONS = {\n  no_olm: \"The sender was unable to establish a secure channel.\",\n  unknown: \"The secure channel with the sender was corrupted.\"\n};\n/**\n * @inheritdoc\n *\n * @param {MatrixEvent} event\n *\n * returns a promise which resolves to a\n * {@link module:crypto~EventDecryptionResult} once we have finished\n * decrypting, or rejects with an `algorithms.DecryptionError` if there is a\n * problem decrypting the event.\n */\n\nMegolmDecryption.prototype.decryptEvent = async function (event) {\n  const content = event.getWireContent();\n\n  if (!content.sender_key || !content.session_id || !content.ciphertext) {\n    throw new _base.DecryptionError(\"MEGOLM_MISSING_FIELDS\", \"Missing fields in input\");\n  } // we add the event to the pending list *before* we start decryption.\n  //\n  // then, if the key turns up while decryption is in progress (and\n  // decryption fails), we will schedule a retry.\n  // (fixes https://github.com/vector-im/riot-web/issues/5001)\n\n\n  this._addEventToPendingList(event);\n\n  let res;\n\n  try {\n    res = await this._olmDevice.decryptGroupMessage(event.getRoomId(), content.sender_key, content.session_id, content.ciphertext, event.getId(), event.getTs());\n  } catch (e) {\n    if (e.name === \"DecryptionError\") {\n      // re-throw decryption errors as-is\n      throw e;\n    }\n\n    let errorCode = \"OLM_DECRYPT_GROUP_MESSAGE_ERROR\";\n\n    if (e && e.message === 'OLM.UNKNOWN_MESSAGE_INDEX') {\n      this._requestKeysForEvent(event);\n\n      errorCode = 'OLM_UNKNOWN_MESSAGE_INDEX';\n    }\n\n    throw new _base.DecryptionError(errorCode, e ? e.toString() : \"Unknown Error: Error is undefined\", {\n      session: content.sender_key + '|' + content.session_id\n    });\n  }\n\n  if (res === null) {\n    // We've got a message for a session we don't have.\n    //\n    // (XXX: We might actually have received this key since we started\n    // decrypting, in which case we'll have scheduled a retry, and this\n    // request will be redundant. We could probably check to see if the\n    // event is still in the pending list; if not, a retry will have been\n    // scheduled, so we needn't send out the request here.)\n    this._requestKeysForEvent(event); // See if there was a problem with the olm session at the time the\n    // event was sent.  Use a fuzz factor of 2 minutes.\n\n\n    const problem = await this._olmDevice.sessionMayHaveProblems(content.sender_key, event.getTs() - 120000);\n\n    if (problem) {\n      let problemDescription = PROBLEM_DESCRIPTIONS[problem.type] || PROBLEM_DESCRIPTIONS.unknown;\n\n      if (problem.fixed) {\n        problemDescription += \" Trying to create a new secure channel and re-requesting the keys.\";\n      }\n\n      throw new _base.DecryptionError(\"MEGOLM_UNKNOWN_INBOUND_SESSION_ID\", problemDescription, {\n        session: content.sender_key + '|' + content.session_id\n      });\n    }\n\n    throw new _base.DecryptionError(\"MEGOLM_UNKNOWN_INBOUND_SESSION_ID\", \"The sender's device has not sent us the keys for this message.\", {\n      session: content.sender_key + '|' + content.session_id\n    });\n  } // success. We can remove the event from the pending list, if that hasn't\n  // already happened.\n\n\n  this._removeEventFromPendingList(event);\n\n  const payload = JSON.parse(res.result); // belt-and-braces check that the room id matches that indicated by the HS\n  // (this is somewhat redundant, since the megolm session is scoped to the\n  // room, so neither the sender nor a MITM can lie about the room_id).\n\n  if (payload.room_id !== event.getRoomId()) {\n    throw new _base.DecryptionError(\"MEGOLM_BAD_ROOM\", \"Message intended for room \" + payload.room_id);\n  }\n\n  return {\n    clearEvent: payload,\n    senderCurve25519Key: res.senderKey,\n    claimedEd25519Key: res.keysClaimed.ed25519,\n    forwardingCurve25519KeyChain: res.forwardingCurve25519KeyChain\n  };\n};\n\nMegolmDecryption.prototype._requestKeysForEvent = function (event) {\n  const wireContent = event.getWireContent();\n  const recipients = event.getKeyRequestRecipients(this._userId);\n\n  this._crypto.requestRoomKey({\n    room_id: event.getRoomId(),\n    algorithm: wireContent.algorithm,\n    sender_key: wireContent.sender_key,\n    session_id: wireContent.session_id\n  }, recipients);\n};\n/**\n * Add an event to the list of those awaiting their session keys.\n *\n * @private\n *\n * @param {module:models/event.MatrixEvent} event\n */\n\n\nMegolmDecryption.prototype._addEventToPendingList = function (event) {\n  const content = event.getWireContent();\n  const senderKey = content.sender_key;\n  const sessionId = content.session_id;\n\n  if (!this._pendingEvents[senderKey]) {\n    this._pendingEvents[senderKey] = new Map();\n  }\n\n  const senderPendingEvents = this._pendingEvents[senderKey];\n\n  if (!senderPendingEvents.has(sessionId)) {\n    senderPendingEvents.set(sessionId, new Set());\n  }\n\n  senderPendingEvents.get(sessionId).add(event);\n};\n/**\n * Remove an event from the list of those awaiting their session keys.\n *\n * @private\n *\n * @param {module:models/event.MatrixEvent} event\n */\n\n\nMegolmDecryption.prototype._removeEventFromPendingList = function (event) {\n  const content = event.getWireContent();\n  const senderKey = content.sender_key;\n  const sessionId = content.session_id;\n  const senderPendingEvents = this._pendingEvents[senderKey];\n  const pendingEvents = senderPendingEvents && senderPendingEvents.get(sessionId);\n\n  if (!pendingEvents) {\n    return;\n  }\n\n  pendingEvents.delete(event);\n\n  if (pendingEvents.size === 0) {\n    senderPendingEvents.delete(senderKey);\n  }\n\n  if (senderPendingEvents.size === 0) {\n    delete this._pendingEvents[senderKey];\n  }\n};\n/**\n * @inheritdoc\n *\n * @param {module:models/event.MatrixEvent} event key event\n */\n\n\nMegolmDecryption.prototype.onRoomKeyEvent = function (event) {\n  const content = event.getContent();\n  const sessionId = content.session_id;\n  let senderKey = event.getSenderKey();\n  let forwardingKeyChain = [];\n  let exportFormat = false;\n  let keysClaimed;\n\n  if (!content.room_id || !sessionId || !content.session_key) {\n    _logger.logger.error(\"key event is missing fields\");\n\n    return;\n  }\n\n  if (!senderKey) {\n    _logger.logger.error(\"key event has no sender key (not encrypted?)\");\n\n    return;\n  }\n\n  if (event.getType() == \"m.forwarded_room_key\") {\n    exportFormat = true;\n    forwardingKeyChain = content.forwarding_curve25519_key_chain;\n\n    if (!utils.isArray(forwardingKeyChain)) {\n      forwardingKeyChain = [];\n    } // copy content before we modify it\n\n\n    forwardingKeyChain = forwardingKeyChain.slice();\n    forwardingKeyChain.push(senderKey);\n    senderKey = content.sender_key;\n\n    if (!senderKey) {\n      _logger.logger.error(\"forwarded_room_key event is missing sender_key field\");\n\n      return;\n    }\n\n    const ed25519Key = content.sender_claimed_ed25519_key;\n\n    if (!ed25519Key) {\n      _logger.logger.error(`forwarded_room_key_event is missing sender_claimed_ed25519_key field`);\n\n      return;\n    }\n\n    keysClaimed = {\n      ed25519: ed25519Key\n    };\n  } else {\n    keysClaimed = event.getKeysClaimed();\n  }\n\n  _logger.logger.log(`Received and adding key for megolm session ${senderKey}|${sessionId}`);\n\n  return this._olmDevice.addInboundGroupSession(content.room_id, senderKey, forwardingKeyChain, sessionId, content.session_key, keysClaimed, exportFormat).then(() => {\n    // have another go at decrypting events sent with this session.\n    this._retryDecryption(senderKey, sessionId).then(success => {\n      // cancel any outstanding room key requests for this session.\n      // Only do this if we managed to decrypt every message in the\n      // session, because if we didn't, we leave the other key\n      // requests in the hopes that someone sends us a key that\n      // includes an earlier index.\n      if (success) {\n        this._crypto.cancelRoomKeyRequest({\n          algorithm: content.algorithm,\n          room_id: content.room_id,\n          session_id: content.session_id,\n          sender_key: senderKey\n        });\n      }\n    });\n  }).then(() => {\n    if (this._crypto.backupInfo) {\n      // don't wait for the keys to be backed up for the server\n      this._crypto.backupGroupSession(content.room_id, senderKey, forwardingKeyChain, content.session_id, content.session_key, keysClaimed, exportFormat).catch(e => {\n        // This throws if the upload failed, but this is fine\n        // since it will have written it to the db and will retry.\n        _logger.logger.log(\"Failed to back up megolm session\", e);\n      });\n    }\n  }).catch(e => {\n    _logger.logger.error(`Error handling m.room_key_event: ${e}`);\n  });\n};\n/**\n * @inheritdoc\n *\n * @param {module:models/event.MatrixEvent} event key event\n */\n\n\nMegolmDecryption.prototype.onRoomKeyWithheldEvent = async function (event) {\n  const content = event.getContent();\n  const senderKey = content.sender_key;\n\n  if (content.code === \"m.no_olm\") {\n    const sender = event.getSender(); // if the sender says that they haven't been able to establish an olm\n    // session, let's proactively establish one\n    // Note: after we record that the olm session has had a problem, we\n    // trigger retrying decryption for all the messages from the sender's\n    // key, so that we can update the error message to indicate the olm\n    // session problem.\n\n    if (await this._olmDevice.getSessionIdForDevice(senderKey)) {\n      // a session has already been established, so we don't need to\n      // create a new one.\n      await this._olmDevice.recordSessionProblem(senderKey, \"no_olm\", true);\n      this.retryDecryptionFromSender(senderKey);\n      return;\n    }\n\n    const device = this._crypto._deviceList.getDeviceByIdentityKey(content.algorithm, senderKey);\n\n    if (!device) {\n      _logger.logger.info(\"Couldn't find device for identity key \" + senderKey + \": not establishing session\");\n\n      await this._olmDevice.recordSessionProblem(senderKey, \"no_olm\", false);\n      this.retryDecryptionFromSender(senderKey);\n      return;\n    }\n\n    await olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, {\n      [sender]: [device]\n    }, false);\n    const encryptedContent = {\n      algorithm: olmlib.OLM_ALGORITHM,\n      sender_key: this._olmDevice.deviceCurve25519Key,\n      ciphertext: {}\n    };\n    await olmlib.encryptMessageForDevice(encryptedContent.ciphertext, this._userId, this._deviceId, this._olmDevice, sender, device, {\n      type: \"m.dummy\"\n    });\n    await this._olmDevice.recordSessionProblem(senderKey, \"no_olm\", true);\n    this.retryDecryptionFromSender(senderKey);\n    await this._baseApis.sendToDevice(\"m.room.encrypted\", {\n      [sender]: {\n        [device.deviceId]: encryptedContent\n      }\n    });\n  } else {\n    await this._olmDevice.addInboundGroupSessionWithheld(content.room_id, senderKey, content.session_id, content.code, content.reason);\n  }\n};\n/**\n * @inheritdoc\n */\n\n\nMegolmDecryption.prototype.hasKeysForKeyRequest = function (keyRequest) {\n  const body = keyRequest.requestBody;\n  return this._olmDevice.hasInboundSessionKeys(body.room_id, body.sender_key, body.session_id // TODO: ratchet index\n  );\n};\n/**\n * @inheritdoc\n */\n\n\nMegolmDecryption.prototype.shareKeysWithDevice = function (keyRequest) {\n  const userId = keyRequest.userId;\n  const deviceId = keyRequest.deviceId;\n\n  const deviceInfo = this._crypto.getStoredDevice(userId, deviceId);\n\n  const body = keyRequest.requestBody;\n  this.olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, {\n    [userId]: [deviceInfo]\n  }).then(devicemap => {\n    const olmSessionResult = devicemap[userId][deviceId];\n\n    if (!olmSessionResult.sessionId) {\n      // no session with this device, probably because there\n      // were no one-time keys.\n      //\n      // ensureOlmSessionsForUsers has already done the logging,\n      // so just skip it.\n      return null;\n    }\n\n    _logger.logger.log(\"sharing keys for session \" + body.sender_key + \"|\" + body.session_id + \" with device \" + userId + \":\" + deviceId);\n\n    return this._buildKeyForwardingMessage(body.room_id, body.sender_key, body.session_id);\n  }).then(payload => {\n    const encryptedContent = {\n      algorithm: olmlib.OLM_ALGORITHM,\n      sender_key: this._olmDevice.deviceCurve25519Key,\n      ciphertext: {}\n    };\n    return this.olmlib.encryptMessageForDevice(encryptedContent.ciphertext, this._userId, this._deviceId, this._olmDevice, userId, deviceInfo, payload).then(() => {\n      const contentMap = {\n        [userId]: {\n          [deviceId]: encryptedContent\n        }\n      }; // TODO: retries\n\n      return this._baseApis.sendToDevice(\"m.room.encrypted\", contentMap);\n    });\n  });\n};\n\nMegolmDecryption.prototype._buildKeyForwardingMessage = async function (roomId, senderKey, sessionId) {\n  const key = await this._olmDevice.getInboundGroupSessionKey(roomId, senderKey, sessionId);\n  return {\n    type: \"m.forwarded_room_key\",\n    content: {\n      algorithm: olmlib.MEGOLM_ALGORITHM,\n      room_id: roomId,\n      sender_key: senderKey,\n      sender_claimed_ed25519_key: key.sender_claimed_ed25519_key,\n      session_id: sessionId,\n      session_key: key.key,\n      chain_index: key.chain_index,\n      forwarding_curve25519_key_chain: key.forwarding_curve25519_key_chain\n    }\n  };\n};\n/**\n * @inheritdoc\n *\n * @param {module:crypto/OlmDevice.MegolmSessionData} session\n */\n\n\nMegolmDecryption.prototype.importRoomKey = function (session) {\n  return this._olmDevice.addInboundGroupSession(session.room_id, session.sender_key, session.forwarding_curve25519_key_chain, session.session_id, session.session_key, session.sender_claimed_keys, true).then(() => {\n    if (this._crypto.backupInfo) {\n      // don't wait for it to complete\n      this._crypto.backupGroupSession(session.room_id, session.sender_key, session.forwarding_curve25519_key_chain, session.session_id, session.session_key, session.sender_claimed_keys, true).catch(e => {\n        // This throws if the upload failed, but this is fine\n        // since it will have written it to the db and will retry.\n        _logger.logger.log(\"Failed to back up megolm session\", e);\n      });\n    } // have another go at decrypting events sent with this session.\n\n\n    this._retryDecryption(session.sender_key, session.session_id);\n  });\n};\n/**\n * Have another go at decrypting events after we receive a key\n *\n * @private\n * @param {String} senderKey\n * @param {String} sessionId\n *\n * @return {Boolean} whether all messages were successfully decrypted\n */\n\n\nMegolmDecryption.prototype._retryDecryption = async function (senderKey, sessionId) {\n  const senderPendingEvents = this._pendingEvents[senderKey];\n\n  if (!senderPendingEvents) {\n    return true;\n  }\n\n  const pending = senderPendingEvents.get(sessionId);\n\n  if (!pending) {\n    return true;\n  }\n\n  pending.delete(sessionId);\n\n  if (pending.size === 0) {\n    this._pendingEvents[senderKey];\n  }\n\n  await Promise.all([...pending].map(async ev => {\n    try {\n      await ev.attemptDecryption(this._crypto);\n    } catch (e) {// don't die if something goes wrong\n    }\n  })); // ev.attemptDecryption will re-add to this._pendingEvents if an event\n  // couldn't be decrypted\n\n  return !(this._pendingEvents[senderKey] || {})[sessionId];\n};\n\nMegolmDecryption.prototype.retryDecryptionFromSender = async function (senderKey) {\n  const senderPendingEvents = this._pendingEvents[senderKey];\n\n  _logger.logger.warn(senderPendingEvents);\n\n  if (!senderPendingEvents) {\n    return true;\n  }\n\n  delete this._pendingEvents[senderKey];\n  await Promise.all([...senderPendingEvents].map(async ([_sessionId, pending]) => {\n    await Promise.all([...pending].map(async ev => {\n      try {\n        _logger.logger.warn(ev.getId());\n\n        await ev.attemptDecryption(this._crypto);\n      } catch (e) {// don't die if something goes wrong\n      }\n    }));\n  }));\n  return !this._pendingEvents[senderKey];\n};\n\n(0, _base.registerAlgorithm)(olmlib.MEGOLM_ALGORITHM, MegolmEncryption, MegolmDecryption);"]},"metadata":{},"sourceType":"script"}