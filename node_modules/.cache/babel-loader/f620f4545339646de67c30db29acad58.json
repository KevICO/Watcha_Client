{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndexedDBStore = IndexedDBStore;\n\nvar _memory = require(\"./memory\");\n\nvar utils = _interopRequireWildcard(require(\"../utils\"));\n\nvar _events = require(\"events\");\n\nvar _indexeddbLocalBackend = require(\"./indexeddb-local-backend.js\");\n\nvar _indexeddbRemoteBackend = require(\"./indexeddb-remote-backend.js\");\n\nvar _user = require(\"../models/user\");\n\nvar _event = require(\"../models/event\");\n\nvar _logger = require(\"../logger\");\n/*\nCopyright 2017 Vector Creations Ltd\nCopyright 2018 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/* eslint-disable babel/no-invalid-this */\n\n/**\n * This is an internal module. See {@link IndexedDBStore} for the public class.\n * @module store/indexeddb\n */\n// If this value is too small we'll be writing very often which will cause\n// noticable stop-the-world pauses. If this value is too big we'll be writing\n// so infrequently that the /sync size gets bigger on reload. Writing more\n// often does not affect the length of the pause since the entire /sync\n// response is persisted each time.\n\n\nconst WRITE_DELAY_MS = 1000 * 60 * 5; // once every 5 minutes\n\n/**\n * Construct a new Indexed Database store, which extends MemoryStore.\n *\n * This store functions like a MemoryStore except it periodically persists\n * the contents of the store to an IndexedDB backend.\n *\n * All data is still kept in-memory but can be loaded from disk by calling\n * <code>startup()</code>. This can make startup times quicker as a complete\n * sync from the server is not required. This does not reduce memory usage as all\n * the data is eagerly fetched when <code>startup()</code> is called.\n * <pre>\n * let opts = { localStorage: window.localStorage };\n * let store = new IndexedDBStore();\n * await store.startup(); // load from indexed db\n * let client = sdk.createClient({\n *     store: store,\n * });\n * client.startClient();\n * client.on(\"sync\", function(state, prevState, data) {\n *     if (state === \"PREPARED\") {\n *         console.log(\"Started up, now with go faster stripes!\");\n *     }\n * });\n * </pre>\n *\n * @constructor\n * @extends MemoryStore\n * @param {Object} opts Options object.\n * @param {Object} opts.indexedDB The Indexed DB interface e.g.\n * <code>window.indexedDB</code>\n * @param {string=} opts.dbName Optional database name. The same name must be used\n * to open the same database.\n * @param {string=} opts.workerScript Optional URL to a script to invoke a web\n * worker with to run IndexedDB queries on the web worker. The IndexedDbStoreWorker\n * class is provided for this purpose and requires the application to provide a\n * trivial wrapper script around it.\n * @param {Object=} opts.workerApi The webWorker API object. If omitted, the global Worker\n * object will be used if it exists.\n * @prop {IndexedDBStoreBackend} backend The backend instance. Call through to\n * this API if you need to perform specific indexeddb actions like deleting the\n * database.\n */\n\nfunction IndexedDBStore(opts) {\n  _memory.MemoryStore.call(this, opts);\n\n  if (!opts.indexedDB) {\n    throw new Error('Missing required option: indexedDB');\n  }\n\n  if (opts.workerScript) {\n    // try & find a webworker-compatible API\n    let workerApi = opts.workerApi;\n\n    if (!workerApi) {\n      // default to the global Worker object (which is where it in a browser)\n      workerApi = global.Worker;\n    }\n\n    this.backend = new _indexeddbRemoteBackend.RemoteIndexedDBStoreBackend(opts.workerScript, opts.dbName, workerApi);\n  } else {\n    this.backend = new _indexeddbLocalBackend.LocalIndexedDBStoreBackend(opts.indexedDB, opts.dbName);\n  }\n\n  this.startedUp = false;\n  this._syncTs = 0; // Records the last-modified-time of each user at the last point we saved\n  // the database, such that we can derive the set if users that have been\n  // modified since we last saved.\n\n  this._userModifiedMap = {// user_id : timestamp\n  };\n}\n\nutils.inherits(IndexedDBStore, _memory.MemoryStore);\nutils.extend(IndexedDBStore.prototype, _events.EventEmitter.prototype);\n\nIndexedDBStore.exists = function (indexedDB, dbName) {\n  return _indexeddbLocalBackend.LocalIndexedDBStoreBackend.exists(indexedDB, dbName);\n};\n/**\n * @return {Promise} Resolved when loaded from indexed db.\n  */\n\n\nIndexedDBStore.prototype.startup = function () {\n  if (this.startedUp) {\n    _logger.logger.log(`IndexedDBStore.startup: already started`);\n\n    return Promise.resolve();\n  }\n\n  _logger.logger.log(`IndexedDBStore.startup: connecting to backend`);\n\n  return this.backend.connect().then(() => {\n    _logger.logger.log(`IndexedDBStore.startup: loading presence events`);\n\n    return this.backend.getUserPresenceEvents();\n  }).then(userPresenceEvents => {\n    _logger.logger.log(`IndexedDBStore.startup: processing presence events`);\n\n    userPresenceEvents.forEach(([userId, rawEvent]) => {\n      const u = new _user.User(userId);\n\n      if (rawEvent) {\n        u.setPresenceEvent(new _event.MatrixEvent(rawEvent));\n      }\n\n      this._userModifiedMap[u.userId] = u.getLastModifiedTime();\n      this.storeUser(u);\n    });\n  });\n};\n/**\n * @return {Promise} Resolves with a sync response to restore the\n * client state to where it was at the last save, or null if there\n * is no saved sync data.\n */\n\n\nIndexedDBStore.prototype.getSavedSync = degradable(function () {\n  return this.backend.getSavedSync();\n}, \"getSavedSync\");\n/** @return {Promise<bool>} whether or not the database was newly created in this session. */\n\nIndexedDBStore.prototype.isNewlyCreated = degradable(function () {\n  return this.backend.isNewlyCreated();\n}, \"isNewlyCreated\");\n/**\n * @return {Promise} If there is a saved sync, the nextBatch token\n * for this sync, otherwise null.\n */\n\nIndexedDBStore.prototype.getSavedSyncToken = degradable(function () {\n  return this.backend.getNextBatchToken();\n}, \"getSavedSyncToken\"),\n/**\n * Delete all data from this store.\n * @return {Promise} Resolves if the data was deleted from the database.\n */\nIndexedDBStore.prototype.deleteAllData = degradable(function () {\n  _memory.MemoryStore.prototype.deleteAllData.call(this);\n\n  return this.backend.clearDatabase().then(() => {\n    _logger.logger.log(\"Deleted indexeddb data.\");\n  }, err => {\n    _logger.logger.error(`Failed to delete indexeddb data: ${err}`);\n\n    throw err;\n  });\n});\n/**\n * Whether this store would like to save its data\n * Note that obviously whether the store wants to save or\n * not could change between calling this function and calling\n * save().\n *\n * @return {boolean} True if calling save() will actually save\n *     (at the time this function is called).\n */\n\nIndexedDBStore.prototype.wantsSave = function () {\n  const now = Date.now();\n  return now - this._syncTs > WRITE_DELAY_MS;\n};\n/**\n * Possibly write data to the database.\n *\n * @param {bool} force True to force a save to happen\n * @return {Promise} Promise resolves after the write completes\n *     (or immediately if no write is performed)\n */\n\n\nIndexedDBStore.prototype.save = function (force) {\n  if (force || this.wantsSave()) {\n    return this._reallySave();\n  }\n\n  return Promise.resolve();\n};\n\nIndexedDBStore.prototype._reallySave = degradable(function () {\n  this._syncTs = Date.now(); // set now to guard against multi-writes\n  // work out changed users (this doesn't handle deletions but you\n  // can't 'delete' users as they are just presence events).\n\n  const userTuples = [];\n\n  for (const u of this.getUsers()) {\n    if (this._userModifiedMap[u.userId] === u.getLastModifiedTime()) continue;\n    if (!u.events.presence) continue;\n    userTuples.push([u.userId, u.events.presence.event]); // note that we've saved this version of the user\n\n    this._userModifiedMap[u.userId] = u.getLastModifiedTime();\n  }\n\n  return this.backend.syncToDatabase(userTuples);\n});\nIndexedDBStore.prototype.setSyncData = degradable(function (syncData) {\n  return this.backend.setSyncData(syncData);\n}, \"setSyncData\");\n/**\n * Returns the out-of-band membership events for this room that\n * were previously loaded.\n * @param {string} roomId\n * @returns {event[]} the events, potentially an empty array if OOB loading didn't yield any new members\n * @returns {null} in case the members for this room haven't been stored yet\n */\n\nIndexedDBStore.prototype.getOutOfBandMembers = degradable(function (roomId) {\n  return this.backend.getOutOfBandMembers(roomId);\n}, \"getOutOfBandMembers\");\n/**\n * Stores the out-of-band membership events for this room. Note that\n * it still makes sense to store an empty array as the OOB status for the room is\n * marked as fetched, and getOutOfBandMembers will return an empty array instead of null\n * @param {string} roomId\n * @param {event[]} membershipEvents the membership events to store\n * @returns {Promise} when all members have been stored\n */\n\nIndexedDBStore.prototype.setOutOfBandMembers = degradable(function (roomId, membershipEvents) {\n  _memory.MemoryStore.prototype.setOutOfBandMembers.call(this, roomId, membershipEvents);\n\n  return this.backend.setOutOfBandMembers(roomId, membershipEvents);\n}, \"setOutOfBandMembers\");\nIndexedDBStore.prototype.clearOutOfBandMembers = degradable(function (roomId) {\n  _memory.MemoryStore.prototype.clearOutOfBandMembers.call(this);\n\n  return this.backend.clearOutOfBandMembers(roomId);\n}, \"clearOutOfBandMembers\");\nIndexedDBStore.prototype.getClientOptions = degradable(function () {\n  return this.backend.getClientOptions();\n}, \"getClientOptions\");\nIndexedDBStore.prototype.storeClientOptions = degradable(function (options) {\n  _memory.MemoryStore.prototype.storeClientOptions.call(this, options);\n\n  return this.backend.storeClientOptions(options);\n}, \"storeClientOptions\");\n/**\n * All member functions of `IndexedDBStore` that access the backend use this wrapper to\n * watch for failures after initial store startup, including `QuotaExceededError` as\n * free disk space changes, etc.\n *\n * When IndexedDB fails via any of these paths, we degrade this back to a `MemoryStore`\n * in place so that the current operation and all future ones are in-memory only.\n *\n * @param {Function} func The degradable work to do.\n * @param {String} fallback The method name for fallback.\n * @returns {Function} A wrapped member function.\n */\n\nfunction degradable(func, fallback) {\n  return async function (...args) {\n    try {\n      return await func.call(this, ...args);\n    } catch (e) {\n      _logger.logger.error(\"IndexedDBStore failure, degrading to MemoryStore\", e);\n\n      this.emit(\"degraded\", e);\n\n      try {\n        // We try to delete IndexedDB after degrading since this store is only a\n        // cache (the app will still function correctly without the data).\n        // It's possible that deleting repair IndexedDB for the next app load,\n        // potenially by making a little more space available.\n        _logger.logger.log(\"IndexedDBStore trying to delete degraded data\");\n\n        await this.backend.clearDatabase();\n\n        _logger.logger.log(\"IndexedDBStore delete after degrading succeeeded\");\n      } catch (e) {\n        _logger.logger.warn(\"IndexedDBStore delete after degrading failed\", e);\n      } // Degrade the store from being an instance of `IndexedDBStore` to instead be\n      // an instance of `MemoryStore` so that future API calls use the memory path\n      // directly and skip IndexedDB entirely. This should be safe as\n      // `IndexedDBStore` already extends from `MemoryStore`, so we are making the\n      // store become its parent type in a way. The mutator methods of\n      // `IndexedDBStore` also maintain the state that `MemoryStore` uses (many are\n      // not overridden at all).\n\n\n      Object.setPrototypeOf(this, _memory.MemoryStore.prototype);\n\n      if (fallback) {\n        return await _memory.MemoryStore.prototype[fallback].call(this, ...args);\n      }\n    }\n  };\n}","map":{"version":3,"sources":["/home/kimist/Developpement/React/watcha_client/node_modules/matrix-js-sdk/lib/store/indexeddb.js"],"names":["_interopRequireWildcard","require","Object","defineProperty","exports","value","IndexedDBStore","_memory","utils","_events","_indexeddbLocalBackend","_indexeddbRemoteBackend","_user","_event","_logger","WRITE_DELAY_MS","opts","MemoryStore","call","indexedDB","Error","workerScript","workerApi","global","Worker","backend","RemoteIndexedDBStoreBackend","dbName","LocalIndexedDBStoreBackend","startedUp","_syncTs","_userModifiedMap","inherits","extend","prototype","EventEmitter","exists","startup","logger","log","Promise","resolve","connect","then","getUserPresenceEvents","userPresenceEvents","forEach","userId","rawEvent","u","User","setPresenceEvent","MatrixEvent","getLastModifiedTime","storeUser","getSavedSync","degradable","isNewlyCreated","getSavedSyncToken","getNextBatchToken","deleteAllData","clearDatabase","err","error","wantsSave","now","Date","save","force","_reallySave","userTuples","getUsers","events","presence","push","event","syncToDatabase","setSyncData","syncData","getOutOfBandMembers","roomId","setOutOfBandMembers","membershipEvents","clearOutOfBandMembers","getClientOptions","storeClientOptions","options","func","fallback","args","e","emit","warn","setPrototypeOf"],"mappings":"AAAA;;AAEA,IAAIA,uBAAuB,GAAGC,OAAO,CAAC,+CAAD,CAArC;;AAEAC,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,cAAR,GAAyBA,cAAzB;;AAEA,IAAIC,OAAO,GAAGN,OAAO,CAAC,UAAD,CAArB;;AAEA,IAAIO,KAAK,GAAGR,uBAAuB,CAACC,OAAO,CAAC,UAAD,CAAR,CAAnC;;AAEA,IAAIQ,OAAO,GAAGR,OAAO,CAAC,QAAD,CAArB;;AAEA,IAAIS,sBAAsB,GAAGT,OAAO,CAAC,8BAAD,CAApC;;AAEA,IAAIU,uBAAuB,GAAGV,OAAO,CAAC,+BAAD,CAArC;;AAEA,IAAIW,KAAK,GAAGX,OAAO,CAAC,gBAAD,CAAnB;;AAEA,IAAIY,MAAM,GAAGZ,OAAO,CAAC,iBAAD,CAApB;;AAEA,IAAIa,OAAO,GAAGb,OAAO,CAAC,WAAD,CAArB;AAEA;;;;;;;;;;;;;;;;;;AAkBA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;;AACA,MAAMc,cAAc,GAAG,OAAO,EAAP,GAAY,CAAnC,C,CAAsC;;AAEtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA,SAAST,cAAT,CAAwBU,IAAxB,EAA8B;AAC5BT,EAAAA,OAAO,CAACU,WAAR,CAAoBC,IAApB,CAAyB,IAAzB,EAA+BF,IAA/B;;AAEA,MAAI,CAACA,IAAI,CAACG,SAAV,EAAqB;AACnB,UAAM,IAAIC,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED,MAAIJ,IAAI,CAACK,YAAT,EAAuB;AACrB;AACA,QAAIC,SAAS,GAAGN,IAAI,CAACM,SAArB;;AAEA,QAAI,CAACA,SAAL,EAAgB;AACd;AACAA,MAAAA,SAAS,GAAGC,MAAM,CAACC,MAAnB;AACD;;AAED,SAAKC,OAAL,GAAe,IAAId,uBAAuB,CAACe,2BAA5B,CAAwDV,IAAI,CAACK,YAA7D,EAA2EL,IAAI,CAACW,MAAhF,EAAwFL,SAAxF,CAAf;AACD,GAVD,MAUO;AACL,SAAKG,OAAL,GAAe,IAAIf,sBAAsB,CAACkB,0BAA3B,CAAsDZ,IAAI,CAACG,SAA3D,EAAsEH,IAAI,CAACW,MAA3E,CAAf;AACD;;AAED,OAAKE,SAAL,GAAiB,KAAjB;AACA,OAAKC,OAAL,GAAe,CAAf,CAtB4B,CAsBV;AAClB;AACA;;AAEA,OAAKC,gBAAL,GAAwB,CAAC;AAAD,GAAxB;AAED;;AAEDvB,KAAK,CAACwB,QAAN,CAAe1B,cAAf,EAA+BC,OAAO,CAACU,WAAvC;AACAT,KAAK,CAACyB,MAAN,CAAa3B,cAAc,CAAC4B,SAA5B,EAAuCzB,OAAO,CAAC0B,YAAR,CAAqBD,SAA5D;;AAEA5B,cAAc,CAAC8B,MAAf,GAAwB,UAAUjB,SAAV,EAAqBQ,MAArB,EAA6B;AACnD,SAAOjB,sBAAsB,CAACkB,0BAAvB,CAAkDQ,MAAlD,CAAyDjB,SAAzD,EAAoEQ,MAApE,CAAP;AACD,CAFD;AAGA;;;;;AAKArB,cAAc,CAAC4B,SAAf,CAAyBG,OAAzB,GAAmC,YAAY;AAC7C,MAAI,KAAKR,SAAT,EAAoB;AAClBf,IAAAA,OAAO,CAACwB,MAAR,CAAeC,GAAf,CAAoB,yCAApB;;AAEA,WAAOC,OAAO,CAACC,OAAR,EAAP;AACD;;AAED3B,EAAAA,OAAO,CAACwB,MAAR,CAAeC,GAAf,CAAoB,+CAApB;;AAEA,SAAO,KAAKd,OAAL,CAAaiB,OAAb,GAAuBC,IAAvB,CAA4B,MAAM;AACvC7B,IAAAA,OAAO,CAACwB,MAAR,CAAeC,GAAf,CAAoB,iDAApB;;AAEA,WAAO,KAAKd,OAAL,CAAamB,qBAAb,EAAP;AACD,GAJM,EAIJD,IAJI,CAICE,kBAAkB,IAAI;AAC5B/B,IAAAA,OAAO,CAACwB,MAAR,CAAeC,GAAf,CAAoB,oDAApB;;AAEAM,IAAAA,kBAAkB,CAACC,OAAnB,CAA2B,CAAC,CAACC,MAAD,EAASC,QAAT,CAAD,KAAwB;AACjD,YAAMC,CAAC,GAAG,IAAIrC,KAAK,CAACsC,IAAV,CAAeH,MAAf,CAAV;;AAEA,UAAIC,QAAJ,EAAc;AACZC,QAAAA,CAAC,CAACE,gBAAF,CAAmB,IAAItC,MAAM,CAACuC,WAAX,CAAuBJ,QAAvB,CAAnB;AACD;;AAED,WAAKjB,gBAAL,CAAsBkB,CAAC,CAACF,MAAxB,IAAkCE,CAAC,CAACI,mBAAF,EAAlC;AACA,WAAKC,SAAL,CAAeL,CAAf;AACD,KATD;AAUD,GAjBM,CAAP;AAkBD,CA3BD;AA4BA;;;;;;;AAOA3C,cAAc,CAAC4B,SAAf,CAAyBqB,YAAzB,GAAwCC,UAAU,CAAC,YAAY;AAC7D,SAAO,KAAK/B,OAAL,CAAa8B,YAAb,EAAP;AACD,CAFiD,EAE/C,cAF+C,CAAlD;AAGA;;AAEAjD,cAAc,CAAC4B,SAAf,CAAyBuB,cAAzB,GAA0CD,UAAU,CAAC,YAAY;AAC/D,SAAO,KAAK/B,OAAL,CAAagC,cAAb,EAAP;AACD,CAFmD,EAEjD,gBAFiD,CAApD;AAGA;;;;;AAKAnD,cAAc,CAAC4B,SAAf,CAAyBwB,iBAAzB,GAA6CF,UAAU,CAAC,YAAY;AAClE,SAAO,KAAK/B,OAAL,CAAakC,iBAAb,EAAP;AACD,CAFsD,EAEpD,mBAFoD,CAAvD;AAGA;;;;AAIArD,cAAc,CAAC4B,SAAf,CAAyB0B,aAAzB,GAAyCJ,UAAU,CAAC,YAAY;AAC9DjD,EAAAA,OAAO,CAACU,WAAR,CAAoBiB,SAApB,CAA8B0B,aAA9B,CAA4C1C,IAA5C,CAAiD,IAAjD;;AAEA,SAAO,KAAKO,OAAL,CAAaoC,aAAb,GAA6BlB,IAA7B,CAAkC,MAAM;AAC7C7B,IAAAA,OAAO,CAACwB,MAAR,CAAeC,GAAf,CAAmB,yBAAnB;AACD,GAFM,EAEJuB,GAAG,IAAI;AACRhD,IAAAA,OAAO,CAACwB,MAAR,CAAeyB,KAAf,CAAsB,oCAAmCD,GAAI,EAA7D;;AAEA,UAAMA,GAAN;AACD,GANM,CAAP;AAOD,CAVkD,CAPnD;AAkBA;;;;;;;;;;AAUAxD,cAAc,CAAC4B,SAAf,CAAyB8B,SAAzB,GAAqC,YAAY;AAC/C,QAAMC,GAAG,GAAGC,IAAI,CAACD,GAAL,EAAZ;AACA,SAAOA,GAAG,GAAG,KAAKnC,OAAX,GAAqBf,cAA5B;AACD,CAHD;AAIA;;;;;;;;;AASAT,cAAc,CAAC4B,SAAf,CAAyBiC,IAAzB,GAAgC,UAAUC,KAAV,EAAiB;AAC/C,MAAIA,KAAK,IAAI,KAAKJ,SAAL,EAAb,EAA+B;AAC7B,WAAO,KAAKK,WAAL,EAAP;AACD;;AAED,SAAO7B,OAAO,CAACC,OAAR,EAAP;AACD,CAND;;AAQAnC,cAAc,CAAC4B,SAAf,CAAyBmC,WAAzB,GAAuCb,UAAU,CAAC,YAAY;AAC5D,OAAK1B,OAAL,GAAeoC,IAAI,CAACD,GAAL,EAAf,CAD4D,CACjC;AAC3B;AACA;;AAEA,QAAMK,UAAU,GAAG,EAAnB;;AAEA,OAAK,MAAMrB,CAAX,IAAgB,KAAKsB,QAAL,EAAhB,EAAiC;AAC/B,QAAI,KAAKxC,gBAAL,CAAsBkB,CAAC,CAACF,MAAxB,MAAoCE,CAAC,CAACI,mBAAF,EAAxC,EAAiE;AACjE,QAAI,CAACJ,CAAC,CAACuB,MAAF,CAASC,QAAd,EAAwB;AACxBH,IAAAA,UAAU,CAACI,IAAX,CAAgB,CAACzB,CAAC,CAACF,MAAH,EAAWE,CAAC,CAACuB,MAAF,CAASC,QAAT,CAAkBE,KAA7B,CAAhB,EAH+B,CAGuB;;AAEtD,SAAK5C,gBAAL,CAAsBkB,CAAC,CAACF,MAAxB,IAAkCE,CAAC,CAACI,mBAAF,EAAlC;AACD;;AAED,SAAO,KAAK5B,OAAL,CAAamD,cAAb,CAA4BN,UAA5B,CAAP;AACD,CAhBgD,CAAjD;AAiBAhE,cAAc,CAAC4B,SAAf,CAAyB2C,WAAzB,GAAuCrB,UAAU,CAAC,UAAUsB,QAAV,EAAoB;AACpE,SAAO,KAAKrD,OAAL,CAAaoD,WAAb,CAAyBC,QAAzB,CAAP;AACD,CAFgD,EAE9C,aAF8C,CAAjD;AAGA;;;;;;;;AAQAxE,cAAc,CAAC4B,SAAf,CAAyB6C,mBAAzB,GAA+CvB,UAAU,CAAC,UAAUwB,MAAV,EAAkB;AAC1E,SAAO,KAAKvD,OAAL,CAAasD,mBAAb,CAAiCC,MAAjC,CAAP;AACD,CAFwD,EAEtD,qBAFsD,CAAzD;AAGA;;;;;;;;;AASA1E,cAAc,CAAC4B,SAAf,CAAyB+C,mBAAzB,GAA+CzB,UAAU,CAAC,UAAUwB,MAAV,EAAkBE,gBAAlB,EAAoC;AAC5F3E,EAAAA,OAAO,CAACU,WAAR,CAAoBiB,SAApB,CAA8B+C,mBAA9B,CAAkD/D,IAAlD,CAAuD,IAAvD,EAA6D8D,MAA7D,EAAqEE,gBAArE;;AAEA,SAAO,KAAKzD,OAAL,CAAawD,mBAAb,CAAiCD,MAAjC,EAAyCE,gBAAzC,CAAP;AACD,CAJwD,EAItD,qBAJsD,CAAzD;AAKA5E,cAAc,CAAC4B,SAAf,CAAyBiD,qBAAzB,GAAiD3B,UAAU,CAAC,UAAUwB,MAAV,EAAkB;AAC5EzE,EAAAA,OAAO,CAACU,WAAR,CAAoBiB,SAApB,CAA8BiD,qBAA9B,CAAoDjE,IAApD,CAAyD,IAAzD;;AAEA,SAAO,KAAKO,OAAL,CAAa0D,qBAAb,CAAmCH,MAAnC,CAAP;AACD,CAJ0D,EAIxD,uBAJwD,CAA3D;AAKA1E,cAAc,CAAC4B,SAAf,CAAyBkD,gBAAzB,GAA4C5B,UAAU,CAAC,YAAY;AACjE,SAAO,KAAK/B,OAAL,CAAa2D,gBAAb,EAAP;AACD,CAFqD,EAEnD,kBAFmD,CAAtD;AAGA9E,cAAc,CAAC4B,SAAf,CAAyBmD,kBAAzB,GAA8C7B,UAAU,CAAC,UAAU8B,OAAV,EAAmB;AAC1E/E,EAAAA,OAAO,CAACU,WAAR,CAAoBiB,SAApB,CAA8BmD,kBAA9B,CAAiDnE,IAAjD,CAAsD,IAAtD,EAA4DoE,OAA5D;;AAEA,SAAO,KAAK7D,OAAL,CAAa4D,kBAAb,CAAgCC,OAAhC,CAAP;AACD,CAJuD,EAIrD,oBAJqD,CAAxD;AAKA;;;;;;;;;;;;;AAaA,SAAS9B,UAAT,CAAoB+B,IAApB,EAA0BC,QAA1B,EAAoC;AAClC,SAAO,gBAAgB,GAAGC,IAAnB,EAAyB;AAC9B,QAAI;AACF,aAAO,MAAMF,IAAI,CAACrE,IAAL,CAAU,IAAV,EAAgB,GAAGuE,IAAnB,CAAb;AACD,KAFD,CAEE,OAAOC,CAAP,EAAU;AACV5E,MAAAA,OAAO,CAACwB,MAAR,CAAeyB,KAAf,CAAqB,kDAArB,EAAyE2B,CAAzE;;AAEA,WAAKC,IAAL,CAAU,UAAV,EAAsBD,CAAtB;;AAEA,UAAI;AACF;AACA;AACA;AACA;AACA5E,QAAAA,OAAO,CAACwB,MAAR,CAAeC,GAAf,CAAmB,+CAAnB;;AAEA,cAAM,KAAKd,OAAL,CAAaoC,aAAb,EAAN;;AAEA/C,QAAAA,OAAO,CAACwB,MAAR,CAAeC,GAAf,CAAmB,kDAAnB;AACD,OAVD,CAUE,OAAOmD,CAAP,EAAU;AACV5E,QAAAA,OAAO,CAACwB,MAAR,CAAesD,IAAf,CAAoB,8CAApB,EAAoEF,CAApE;AACD,OAjBS,CAiBR;AACF;AACA;AACA;AACA;AACA;AACA;;;AAGAxF,MAAAA,MAAM,CAAC2F,cAAP,CAAsB,IAAtB,EAA4BtF,OAAO,CAACU,WAAR,CAAoBiB,SAAhD;;AAEA,UAAIsD,QAAJ,EAAc;AACZ,eAAO,MAAMjF,OAAO,CAACU,WAAR,CAAoBiB,SAApB,CAA8BsD,QAA9B,EAAwCtE,IAAxC,CAA6C,IAA7C,EAAmD,GAAGuE,IAAtD,CAAb;AACD;AACF;AACF,GAnCD;AAoCD","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndexedDBStore = IndexedDBStore;\n\nvar _memory = require(\"./memory\");\n\nvar utils = _interopRequireWildcard(require(\"../utils\"));\n\nvar _events = require(\"events\");\n\nvar _indexeddbLocalBackend = require(\"./indexeddb-local-backend.js\");\n\nvar _indexeddbRemoteBackend = require(\"./indexeddb-remote-backend.js\");\n\nvar _user = require(\"../models/user\");\n\nvar _event = require(\"../models/event\");\n\nvar _logger = require(\"../logger\");\n\n/*\nCopyright 2017 Vector Creations Ltd\nCopyright 2018 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/* eslint-disable babel/no-invalid-this */\n\n/**\n * This is an internal module. See {@link IndexedDBStore} for the public class.\n * @module store/indexeddb\n */\n// If this value is too small we'll be writing very often which will cause\n// noticable stop-the-world pauses. If this value is too big we'll be writing\n// so infrequently that the /sync size gets bigger on reload. Writing more\n// often does not affect the length of the pause since the entire /sync\n// response is persisted each time.\nconst WRITE_DELAY_MS = 1000 * 60 * 5; // once every 5 minutes\n\n/**\n * Construct a new Indexed Database store, which extends MemoryStore.\n *\n * This store functions like a MemoryStore except it periodically persists\n * the contents of the store to an IndexedDB backend.\n *\n * All data is still kept in-memory but can be loaded from disk by calling\n * <code>startup()</code>. This can make startup times quicker as a complete\n * sync from the server is not required. This does not reduce memory usage as all\n * the data is eagerly fetched when <code>startup()</code> is called.\n * <pre>\n * let opts = { localStorage: window.localStorage };\n * let store = new IndexedDBStore();\n * await store.startup(); // load from indexed db\n * let client = sdk.createClient({\n *     store: store,\n * });\n * client.startClient();\n * client.on(\"sync\", function(state, prevState, data) {\n *     if (state === \"PREPARED\") {\n *         console.log(\"Started up, now with go faster stripes!\");\n *     }\n * });\n * </pre>\n *\n * @constructor\n * @extends MemoryStore\n * @param {Object} opts Options object.\n * @param {Object} opts.indexedDB The Indexed DB interface e.g.\n * <code>window.indexedDB</code>\n * @param {string=} opts.dbName Optional database name. The same name must be used\n * to open the same database.\n * @param {string=} opts.workerScript Optional URL to a script to invoke a web\n * worker with to run IndexedDB queries on the web worker. The IndexedDbStoreWorker\n * class is provided for this purpose and requires the application to provide a\n * trivial wrapper script around it.\n * @param {Object=} opts.workerApi The webWorker API object. If omitted, the global Worker\n * object will be used if it exists.\n * @prop {IndexedDBStoreBackend} backend The backend instance. Call through to\n * this API if you need to perform specific indexeddb actions like deleting the\n * database.\n */\n\nfunction IndexedDBStore(opts) {\n  _memory.MemoryStore.call(this, opts);\n\n  if (!opts.indexedDB) {\n    throw new Error('Missing required option: indexedDB');\n  }\n\n  if (opts.workerScript) {\n    // try & find a webworker-compatible API\n    let workerApi = opts.workerApi;\n\n    if (!workerApi) {\n      // default to the global Worker object (which is where it in a browser)\n      workerApi = global.Worker;\n    }\n\n    this.backend = new _indexeddbRemoteBackend.RemoteIndexedDBStoreBackend(opts.workerScript, opts.dbName, workerApi);\n  } else {\n    this.backend = new _indexeddbLocalBackend.LocalIndexedDBStoreBackend(opts.indexedDB, opts.dbName);\n  }\n\n  this.startedUp = false;\n  this._syncTs = 0; // Records the last-modified-time of each user at the last point we saved\n  // the database, such that we can derive the set if users that have been\n  // modified since we last saved.\n\n  this._userModifiedMap = {// user_id : timestamp\n  };\n}\n\nutils.inherits(IndexedDBStore, _memory.MemoryStore);\nutils.extend(IndexedDBStore.prototype, _events.EventEmitter.prototype);\n\nIndexedDBStore.exists = function (indexedDB, dbName) {\n  return _indexeddbLocalBackend.LocalIndexedDBStoreBackend.exists(indexedDB, dbName);\n};\n/**\n * @return {Promise} Resolved when loaded from indexed db.\n  */\n\n\nIndexedDBStore.prototype.startup = function () {\n  if (this.startedUp) {\n    _logger.logger.log(`IndexedDBStore.startup: already started`);\n\n    return Promise.resolve();\n  }\n\n  _logger.logger.log(`IndexedDBStore.startup: connecting to backend`);\n\n  return this.backend.connect().then(() => {\n    _logger.logger.log(`IndexedDBStore.startup: loading presence events`);\n\n    return this.backend.getUserPresenceEvents();\n  }).then(userPresenceEvents => {\n    _logger.logger.log(`IndexedDBStore.startup: processing presence events`);\n\n    userPresenceEvents.forEach(([userId, rawEvent]) => {\n      const u = new _user.User(userId);\n\n      if (rawEvent) {\n        u.setPresenceEvent(new _event.MatrixEvent(rawEvent));\n      }\n\n      this._userModifiedMap[u.userId] = u.getLastModifiedTime();\n      this.storeUser(u);\n    });\n  });\n};\n/**\n * @return {Promise} Resolves with a sync response to restore the\n * client state to where it was at the last save, or null if there\n * is no saved sync data.\n */\n\n\nIndexedDBStore.prototype.getSavedSync = degradable(function () {\n  return this.backend.getSavedSync();\n}, \"getSavedSync\");\n/** @return {Promise<bool>} whether or not the database was newly created in this session. */\n\nIndexedDBStore.prototype.isNewlyCreated = degradable(function () {\n  return this.backend.isNewlyCreated();\n}, \"isNewlyCreated\");\n/**\n * @return {Promise} If there is a saved sync, the nextBatch token\n * for this sync, otherwise null.\n */\n\nIndexedDBStore.prototype.getSavedSyncToken = degradable(function () {\n  return this.backend.getNextBatchToken();\n}, \"getSavedSyncToken\"),\n/**\n * Delete all data from this store.\n * @return {Promise} Resolves if the data was deleted from the database.\n */\nIndexedDBStore.prototype.deleteAllData = degradable(function () {\n  _memory.MemoryStore.prototype.deleteAllData.call(this);\n\n  return this.backend.clearDatabase().then(() => {\n    _logger.logger.log(\"Deleted indexeddb data.\");\n  }, err => {\n    _logger.logger.error(`Failed to delete indexeddb data: ${err}`);\n\n    throw err;\n  });\n});\n/**\n * Whether this store would like to save its data\n * Note that obviously whether the store wants to save or\n * not could change between calling this function and calling\n * save().\n *\n * @return {boolean} True if calling save() will actually save\n *     (at the time this function is called).\n */\n\nIndexedDBStore.prototype.wantsSave = function () {\n  const now = Date.now();\n  return now - this._syncTs > WRITE_DELAY_MS;\n};\n/**\n * Possibly write data to the database.\n *\n * @param {bool} force True to force a save to happen\n * @return {Promise} Promise resolves after the write completes\n *     (or immediately if no write is performed)\n */\n\n\nIndexedDBStore.prototype.save = function (force) {\n  if (force || this.wantsSave()) {\n    return this._reallySave();\n  }\n\n  return Promise.resolve();\n};\n\nIndexedDBStore.prototype._reallySave = degradable(function () {\n  this._syncTs = Date.now(); // set now to guard against multi-writes\n  // work out changed users (this doesn't handle deletions but you\n  // can't 'delete' users as they are just presence events).\n\n  const userTuples = [];\n\n  for (const u of this.getUsers()) {\n    if (this._userModifiedMap[u.userId] === u.getLastModifiedTime()) continue;\n    if (!u.events.presence) continue;\n    userTuples.push([u.userId, u.events.presence.event]); // note that we've saved this version of the user\n\n    this._userModifiedMap[u.userId] = u.getLastModifiedTime();\n  }\n\n  return this.backend.syncToDatabase(userTuples);\n});\nIndexedDBStore.prototype.setSyncData = degradable(function (syncData) {\n  return this.backend.setSyncData(syncData);\n}, \"setSyncData\");\n/**\n * Returns the out-of-band membership events for this room that\n * were previously loaded.\n * @param {string} roomId\n * @returns {event[]} the events, potentially an empty array if OOB loading didn't yield any new members\n * @returns {null} in case the members for this room haven't been stored yet\n */\n\nIndexedDBStore.prototype.getOutOfBandMembers = degradable(function (roomId) {\n  return this.backend.getOutOfBandMembers(roomId);\n}, \"getOutOfBandMembers\");\n/**\n * Stores the out-of-band membership events for this room. Note that\n * it still makes sense to store an empty array as the OOB status for the room is\n * marked as fetched, and getOutOfBandMembers will return an empty array instead of null\n * @param {string} roomId\n * @param {event[]} membershipEvents the membership events to store\n * @returns {Promise} when all members have been stored\n */\n\nIndexedDBStore.prototype.setOutOfBandMembers = degradable(function (roomId, membershipEvents) {\n  _memory.MemoryStore.prototype.setOutOfBandMembers.call(this, roomId, membershipEvents);\n\n  return this.backend.setOutOfBandMembers(roomId, membershipEvents);\n}, \"setOutOfBandMembers\");\nIndexedDBStore.prototype.clearOutOfBandMembers = degradable(function (roomId) {\n  _memory.MemoryStore.prototype.clearOutOfBandMembers.call(this);\n\n  return this.backend.clearOutOfBandMembers(roomId);\n}, \"clearOutOfBandMembers\");\nIndexedDBStore.prototype.getClientOptions = degradable(function () {\n  return this.backend.getClientOptions();\n}, \"getClientOptions\");\nIndexedDBStore.prototype.storeClientOptions = degradable(function (options) {\n  _memory.MemoryStore.prototype.storeClientOptions.call(this, options);\n\n  return this.backend.storeClientOptions(options);\n}, \"storeClientOptions\");\n/**\n * All member functions of `IndexedDBStore` that access the backend use this wrapper to\n * watch for failures after initial store startup, including `QuotaExceededError` as\n * free disk space changes, etc.\n *\n * When IndexedDB fails via any of these paths, we degrade this back to a `MemoryStore`\n * in place so that the current operation and all future ones are in-memory only.\n *\n * @param {Function} func The degradable work to do.\n * @param {String} fallback The method name for fallback.\n * @returns {Function} A wrapped member function.\n */\n\nfunction degradable(func, fallback) {\n  return async function (...args) {\n    try {\n      return await func.call(this, ...args);\n    } catch (e) {\n      _logger.logger.error(\"IndexedDBStore failure, degrading to MemoryStore\", e);\n\n      this.emit(\"degraded\", e);\n\n      try {\n        // We try to delete IndexedDB after degrading since this store is only a\n        // cache (the app will still function correctly without the data).\n        // It's possible that deleting repair IndexedDB for the next app load,\n        // potenially by making a little more space available.\n        _logger.logger.log(\"IndexedDBStore trying to delete degraded data\");\n\n        await this.backend.clearDatabase();\n\n        _logger.logger.log(\"IndexedDBStore delete after degrading succeeeded\");\n      } catch (e) {\n        _logger.logger.warn(\"IndexedDBStore delete after degrading failed\", e);\n      } // Degrade the store from being an instance of `IndexedDBStore` to instead be\n      // an instance of `MemoryStore` so that future API calls use the memory path\n      // directly and skip IndexedDB entirely. This should be safe as\n      // `IndexedDBStore` already extends from `MemoryStore`, so we are making the\n      // store become its parent type in a way. The mutator methods of\n      // `IndexedDBStore` also maintain the state that `MemoryStore` uses (many are\n      // not overridden at all).\n\n\n      Object.setPrototypeOf(this, _memory.MemoryStore.prototype);\n\n      if (fallback) {\n        return await _memory.MemoryStore.prototype[fallback].call(this, ...args);\n      }\n    }\n  };\n}"]},"metadata":{},"sourceType":"script"}