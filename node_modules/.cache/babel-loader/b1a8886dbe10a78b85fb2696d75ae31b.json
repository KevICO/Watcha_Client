{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SAS = void 0;\n\nvar _Base = require(\"./Base\");\n\nvar _anotherJson = _interopRequireDefault(require(\"another-json\"));\n\nvar _Error = require(\"./Error\");\n/*\nCopyright 2018 New Vector Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Short Authentication String (SAS) verification.\n * @module crypto/verification/SAS\n */\n\n\nconst EVENTS = [\"m.key.verification.accept\", \"m.key.verification.key\", \"m.key.verification.mac\"];\nlet olmutil;\nconst newMismatchedSASError = (0, _Error.errorFactory)(\"m.mismatched_sas\", \"Mismatched short authentication string\");\nconst newMismatchedCommitmentError = (0, _Error.errorFactory)(\"m.mismatched_commitment\", \"Mismatched commitment\");\n\nfunction generateDecimalSas(sasBytes) {\n  /**\n   *      +--------+--------+--------+--------+--------+\n   *      | Byte 0 | Byte 1 | Byte 2 | Byte 3 | Byte 4 |\n   *      +--------+--------+--------+--------+--------+\n   * bits: 87654321 87654321 87654321 87654321 87654321\n   *       \\____________/\\_____________/\\____________/\n   *         1st number    2nd number     3rd number\n   */\n  return [(sasBytes[0] << 5 | sasBytes[1] >> 3) + 1000, ((sasBytes[1] & 0x7) << 10 | sasBytes[2] << 2 | sasBytes[3] >> 6) + 1000, ((sasBytes[3] & 0x3f) << 7 | sasBytes[4] >> 1) + 1000];\n}\n\nconst emojiMapping = [[\"🐶\", \"dog\"], //  0\n[\"🐱\", \"cat\"], //  1\n[\"🦁\", \"lion\"], //  2\n[\"🐎\", \"horse\"], //  3\n[\"🦄\", \"unicorn\"], //  4\n[\"🐷\", \"pig\"], //  5\n[\"🐘\", \"elephant\"], //  6\n[\"🐰\", \"rabbit\"], //  7\n[\"🐼\", \"panda\"], //  8\n[\"🐓\", \"rooster\"], //  9\n[\"🐧\", \"penguin\"], // 10\n[\"🐢\", \"turtle\"], // 11\n[\"🐟\", \"fish\"], // 12\n[\"🐙\", \"octopus\"], // 13\n[\"🦋\", \"butterfly\"], // 14\n[\"🌷\", \"flower\"], // 15\n[\"🌳\", \"tree\"], // 16\n[\"🌵\", \"cactus\"], // 17\n[\"🍄\", \"mushroom\"], // 18\n[\"🌏\", \"globe\"], // 19\n[\"🌙\", \"moon\"], // 20\n[\"☁️\", \"cloud\"], // 21\n[\"🔥\", \"fire\"], // 22\n[\"🍌\", \"banana\"], // 23\n[\"🍎\", \"apple\"], // 24\n[\"🍓\", \"strawberry\"], // 25\n[\"🌽\", \"corn\"], // 26\n[\"🍕\", \"pizza\"], // 27\n[\"🎂\", \"cake\"], // 28\n[\"❤️\", \"heart\"], // 29\n[\"🙂\", \"smiley\"], // 30\n[\"🤖\", \"robot\"], // 31\n[\"🎩\", \"hat\"], // 32\n[\"👓\", \"glasses\"], // 33\n[\"🔧\", \"spanner\"], // 34\n[\"🎅\", \"santa\"], // 35\n[\"👍\", \"thumbs up\"], // 36\n[\"☂️\", \"umbrella\"], // 37\n[\"⌛\", \"hourglass\"], // 38\n[\"⏰\", \"clock\"], // 39\n[\"🎁\", \"gift\"], // 40\n[\"💡\", \"light bulb\"], // 41\n[\"📕\", \"book\"], // 42\n[\"✏️\", \"pencil\"], // 43\n[\"📎\", \"paperclip\"], // 44\n[\"✂️\", \"scissors\"], // 45\n[\"🔒\", \"lock\"], // 46\n[\"🔑\", \"key\"], // 47\n[\"🔨\", \"hammer\"], // 48\n[\"☎️\", \"telephone\"], // 49\n[\"🏁\", \"flag\"], // 50\n[\"🚂\", \"train\"], // 51\n[\"🚲\", \"bicycle\"], // 52\n[\"✈️\", \"aeroplane\"], // 53\n[\"🚀\", \"rocket\"], // 54\n[\"🏆\", \"trophy\"], // 55\n[\"⚽\", \"ball\"], // 56\n[\"🎸\", \"guitar\"], // 57\n[\"🎺\", \"trumpet\"], // 58\n[\"🔔\", \"bell\"], // 59\n[\"⚓️\", \"anchor\"], // 60\n[\"🎧\", \"headphones\"], // 61\n[\"📁\", \"folder\"], // 62\n[\"📌\", \"pin\"] // 63\n];\n\nfunction generateEmojiSas(sasBytes) {\n  const emojis = [// just like base64 encoding\n  sasBytes[0] >> 2, (sasBytes[0] & 0x3) << 4 | sasBytes[1] >> 4, (sasBytes[1] & 0xf) << 2 | sasBytes[2] >> 6, sasBytes[2] & 0x3f, sasBytes[3] >> 2, (sasBytes[3] & 0x3) << 4 | sasBytes[4] >> 4, (sasBytes[4] & 0xf) << 2 | sasBytes[5] >> 6];\n  return emojis.map(num => emojiMapping[num]);\n}\n\nconst sasGenerators = {\n  decimal: generateDecimalSas,\n  emoji: generateEmojiSas\n};\n\nfunction generateSas(sasBytes, methods) {\n  const sas = {};\n\n  for (const method of methods) {\n    if (method in sasGenerators) {\n      sas[method] = sasGenerators[method](sasBytes);\n    }\n  }\n\n  return sas;\n}\n\nconst macMethods = {\n  \"hkdf-hmac-sha256\": \"calculate_mac\",\n  \"hmac-sha256\": \"calculate_mac_long_kdf\"\n};\n/* lists of algorithms/methods that are supported.  The key agreement, hashes,\n * and MAC lists should be sorted in order of preference (most preferred\n * first).\n */\n\nconst KEY_AGREEMENT_LIST = [\"curve25519\"];\nconst HASHES_LIST = [\"sha256\"];\nconst MAC_LIST = [\"hkdf-hmac-sha256\", \"hmac-sha256\"];\nconst SAS_LIST = Object.keys(sasGenerators);\nconst KEY_AGREEMENT_SET = new Set(KEY_AGREEMENT_LIST);\nconst HASHES_SET = new Set(HASHES_LIST);\nconst MAC_SET = new Set(MAC_LIST);\nconst SAS_SET = new Set(SAS_LIST);\n\nfunction intersection(anArray, aSet) {\n  return anArray instanceof Array ? anArray.filter(x => aSet.has(x)) : [];\n}\n/**\n * @alias module:crypto/verification/SAS\n * @extends {module:crypto/verification/Base}\n */\n\n\nclass SAS extends _Base.VerificationBase {\n  static get NAME() {\n    return \"m.sas.v1\";\n  }\n\n  get events() {\n    return EVENTS;\n  }\n\n  async _doVerification() {\n    await global.Olm.init();\n    olmutil = olmutil || new global.Olm.Utility(); // make sure user's keys are downloaded\n\n    await this._baseApis.downloadKeys([this.userId]);\n\n    if (this.startEvent) {\n      return await this._doRespondVerification();\n    } else {\n      return await this._doSendVerification();\n    }\n  }\n\n  async _doSendVerification() {\n    const type = \"m.key.verification.start\";\n\n    const initialMessage = this._channel.completeContent(type, {\n      method: SAS.NAME,\n      from_device: this._baseApis.deviceId,\n      key_agreement_protocols: KEY_AGREEMENT_LIST,\n      hashes: HASHES_LIST,\n      message_authentication_codes: MAC_LIST,\n      // FIXME: allow app to specify what SAS methods can be used\n      short_authentication_string: SAS_LIST\n    }); // add the transaction id to the message beforehand because\n    // it needs to be included in the commitment hash later on\n\n\n    this._channel.sendCompleted(type, initialMessage);\n\n    let e = await this._waitForEvent(\"m.key.verification.accept\");\n    let content = e.getContent();\n    const sasMethods = intersection(content.short_authentication_string, SAS_SET);\n\n    if (!(KEY_AGREEMENT_SET.has(content.key_agreement_protocol) && HASHES_SET.has(content.hash) && MAC_SET.has(content.message_authentication_code) && sasMethods.length)) {\n      throw (0, _Error.newUnknownMethodError)();\n    }\n\n    if (typeof content.commitment !== \"string\") {\n      throw (0, _Error.newInvalidMessageError)();\n    }\n\n    const macMethod = content.message_authentication_code;\n    const hashCommitment = content.commitment;\n    const olmSAS = new global.Olm.SAS();\n\n    try {\n      this._send(\"m.key.verification.key\", {\n        key: olmSAS.get_pubkey()\n      });\n\n      e = await this._waitForEvent(\"m.key.verification.key\"); // FIXME: make sure event is properly formed\n\n      content = e.getContent();\n\n      const commitmentStr = content.key + _anotherJson.default.stringify(initialMessage); // TODO: use selected hash function (when we support multiple)\n\n\n      if (olmutil.sha256(commitmentStr) !== hashCommitment) {\n        throw newMismatchedCommitmentError();\n      }\n\n      olmSAS.set_their_key(content.key);\n\n      const sasInfo = \"MATRIX_KEY_VERIFICATION_SAS\" + this._baseApis.getUserId() + this._baseApis.deviceId + this.userId + this.deviceId + this._channel.transactionId;\n\n      const sasBytes = olmSAS.generate_bytes(sasInfo, 6);\n      const verifySAS = new Promise((resolve, reject) => {\n        this.emit(\"show_sas\", {\n          sas: generateSas(sasBytes, sasMethods),\n          confirm: () => {\n            this._sendMAC(olmSAS, macMethod);\n\n            resolve();\n          },\n          cancel: () => reject((0, _Error.newUserCancelledError)()),\n          mismatch: () => reject(newMismatchedSASError())\n        });\n      });\n      [e] = await Promise.all([this._waitForEvent(\"m.key.verification.mac\").then(e => {\n        // we don't expect any more messages from the other\n        // party, and they may send a m.key.verification.done\n        // when they're done on their end\n        this._expectedEvent = \"m.key.verification.done\";\n        return e;\n      }), verifySAS]);\n      content = e.getContent();\n      await this._checkMAC(olmSAS, content, macMethod);\n    } finally {\n      olmSAS.free();\n    }\n  }\n\n  async _doRespondVerification() {\n    // as m.related_to is not included in the encrypted content in e2e rooms,\n    // we need to make sure it is added\n    let content = this._channel.completedContentFromEvent(this.startEvent); // Note: we intersect using our pre-made lists, rather than the sets,\n    // so that the result will be in our order of preference.  Then\n    // fetching the first element from the array will give our preferred\n    // method out of the ones offered by the other party.\n\n\n    const keyAgreement = intersection(KEY_AGREEMENT_LIST, new Set(content.key_agreement_protocols))[0];\n    const hashMethod = intersection(HASHES_LIST, new Set(content.hashes))[0];\n    const macMethod = intersection(MAC_LIST, new Set(content.message_authentication_codes))[0]; // FIXME: allow app to specify what SAS methods can be used\n\n    const sasMethods = intersection(content.short_authentication_string, SAS_SET);\n\n    if (!(keyAgreement !== undefined && hashMethod !== undefined && macMethod !== undefined && sasMethods.length)) {\n      throw (0, _Error.newUnknownMethodError)();\n    }\n\n    const olmSAS = new global.Olm.SAS();\n\n    try {\n      const commitmentStr = olmSAS.get_pubkey() + _anotherJson.default.stringify(content);\n\n      this._send(\"m.key.verification.accept\", {\n        key_agreement_protocol: keyAgreement,\n        hash: hashMethod,\n        message_authentication_code: macMethod,\n        short_authentication_string: sasMethods,\n        // TODO: use selected hash function (when we support multiple)\n        commitment: olmutil.sha256(commitmentStr)\n      });\n\n      let e = await this._waitForEvent(\"m.key.verification.key\"); // FIXME: make sure event is properly formed\n\n      content = e.getContent();\n      olmSAS.set_their_key(content.key);\n\n      this._send(\"m.key.verification.key\", {\n        key: olmSAS.get_pubkey()\n      });\n\n      const sasInfo = \"MATRIX_KEY_VERIFICATION_SAS\" + this.userId + this.deviceId + this._baseApis.getUserId() + this._baseApis.deviceId + this._channel.transactionId;\n\n      const sasBytes = olmSAS.generate_bytes(sasInfo, 6);\n      const verifySAS = new Promise((resolve, reject) => {\n        this.emit(\"show_sas\", {\n          sas: generateSas(sasBytes, sasMethods),\n          confirm: () => {\n            this._sendMAC(olmSAS, macMethod);\n\n            resolve();\n          },\n          cancel: () => reject((0, _Error.newUserCancelledError)()),\n          mismatch: () => reject(newMismatchedSASError())\n        });\n      });\n      [e] = await Promise.all([this._waitForEvent(\"m.key.verification.mac\").then(e => {\n        // we don't expect any more messages from the other\n        // party, and they may send a m.key.verification.done\n        // when they're done on their end\n        this._expectedEvent = \"m.key.verification.done\";\n        return e;\n      }), verifySAS]);\n      content = e.getContent();\n      await this._checkMAC(olmSAS, content, macMethod);\n    } finally {\n      olmSAS.free();\n    }\n  }\n\n  _sendMAC(olmSAS, method) {\n    const mac = {};\n    const keyList = [];\n\n    const baseInfo = \"MATRIX_KEY_VERIFICATION_MAC\" + this._baseApis.getUserId() + this._baseApis.deviceId + this.userId + this.deviceId + this._channel.transactionId;\n\n    const deviceKeyId = `ed25519:${this._baseApis.deviceId}`;\n    mac[deviceKeyId] = olmSAS[macMethods[method]](this._baseApis.getDeviceEd25519Key(), baseInfo + deviceKeyId);\n    keyList.push(deviceKeyId);\n\n    const crossSigningId = this._baseApis.getCrossSigningId();\n\n    if (crossSigningId) {\n      const crossSigningKeyId = `ed25519:${crossSigningId}`;\n      mac[crossSigningKeyId] = olmSAS[macMethods[method]](crossSigningId, baseInfo + crossSigningKeyId);\n      keyList.push(crossSigningKeyId);\n    }\n\n    const keys = olmSAS[macMethods[method]](keyList.sort().join(\",\"), baseInfo + \"KEY_IDS\");\n\n    this._send(\"m.key.verification.mac\", {\n      mac,\n      keys\n    });\n  }\n\n  async _checkMAC(olmSAS, content, method) {\n    const baseInfo = \"MATRIX_KEY_VERIFICATION_MAC\" + this.userId + this.deviceId + this._baseApis.getUserId() + this._baseApis.deviceId + this._channel.transactionId;\n\n    if (content.keys !== olmSAS[macMethods[method]](Object.keys(content.mac).sort().join(\",\"), baseInfo + \"KEY_IDS\")) {\n      throw (0, _Error.newKeyMismatchError)();\n    }\n\n    await this._verifyKeys(this.userId, content.mac, (keyId, device, keyInfo) => {\n      if (keyInfo !== olmSAS[macMethods[method]](device.keys[keyId], baseInfo + keyId)) {\n        throw (0, _Error.newKeyMismatchError)();\n      }\n    });\n  }\n\n}\n\nexports.SAS = SAS;","map":{"version":3,"sources":["/home/kimist/Developpement/React/watcha_client/node_modules/matrix-js-sdk/lib/crypto/verification/SAS.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","SAS","_Base","_anotherJson","_Error","EVENTS","olmutil","newMismatchedSASError","errorFactory","newMismatchedCommitmentError","generateDecimalSas","sasBytes","emojiMapping","generateEmojiSas","emojis","map","num","sasGenerators","decimal","emoji","generateSas","methods","sas","method","macMethods","KEY_AGREEMENT_LIST","HASHES_LIST","MAC_LIST","SAS_LIST","keys","KEY_AGREEMENT_SET","Set","HASHES_SET","MAC_SET","SAS_SET","intersection","anArray","aSet","Array","filter","x","has","VerificationBase","NAME","events","_doVerification","global","Olm","init","Utility","_baseApis","downloadKeys","userId","startEvent","_doRespondVerification","_doSendVerification","type","initialMessage","_channel","completeContent","from_device","deviceId","key_agreement_protocols","hashes","message_authentication_codes","short_authentication_string","sendCompleted","e","_waitForEvent","content","getContent","sasMethods","key_agreement_protocol","hash","message_authentication_code","length","newUnknownMethodError","commitment","newInvalidMessageError","macMethod","hashCommitment","olmSAS","_send","key","get_pubkey","commitmentStr","default","stringify","sha256","set_their_key","sasInfo","getUserId","transactionId","generate_bytes","verifySAS","Promise","resolve","reject","emit","confirm","_sendMAC","cancel","newUserCancelledError","mismatch","all","then","_expectedEvent","_checkMAC","free","completedContentFromEvent","keyAgreement","hashMethod","undefined","mac","keyList","baseInfo","deviceKeyId","getDeviceEd25519Key","push","crossSigningId","getCrossSigningId","crossSigningKeyId","sort","join","newKeyMismatchError","_verifyKeys","keyId","device","keyInfo"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SAS = void 0;\n\nvar _Base = require(\"./Base\");\n\nvar _anotherJson = _interopRequireDefault(require(\"another-json\"));\n\nvar _Error = require(\"./Error\");\n\n/*\nCopyright 2018 New Vector Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Short Authentication String (SAS) verification.\n * @module crypto/verification/SAS\n */\nconst EVENTS = [\"m.key.verification.accept\", \"m.key.verification.key\", \"m.key.verification.mac\"];\nlet olmutil;\nconst newMismatchedSASError = (0, _Error.errorFactory)(\"m.mismatched_sas\", \"Mismatched short authentication string\");\nconst newMismatchedCommitmentError = (0, _Error.errorFactory)(\"m.mismatched_commitment\", \"Mismatched commitment\");\n\nfunction generateDecimalSas(sasBytes) {\n  /**\n   *      +--------+--------+--------+--------+--------+\n   *      | Byte 0 | Byte 1 | Byte 2 | Byte 3 | Byte 4 |\n   *      +--------+--------+--------+--------+--------+\n   * bits: 87654321 87654321 87654321 87654321 87654321\n   *       \\____________/\\_____________/\\____________/\n   *         1st number    2nd number     3rd number\n   */\n  return [(sasBytes[0] << 5 | sasBytes[1] >> 3) + 1000, ((sasBytes[1] & 0x7) << 10 | sasBytes[2] << 2 | sasBytes[3] >> 6) + 1000, ((sasBytes[3] & 0x3f) << 7 | sasBytes[4] >> 1) + 1000];\n}\n\nconst emojiMapping = [[\"🐶\", \"dog\"], //  0\n[\"🐱\", \"cat\"], //  1\n[\"🦁\", \"lion\"], //  2\n[\"🐎\", \"horse\"], //  3\n[\"🦄\", \"unicorn\"], //  4\n[\"🐷\", \"pig\"], //  5\n[\"🐘\", \"elephant\"], //  6\n[\"🐰\", \"rabbit\"], //  7\n[\"🐼\", \"panda\"], //  8\n[\"🐓\", \"rooster\"], //  9\n[\"🐧\", \"penguin\"], // 10\n[\"🐢\", \"turtle\"], // 11\n[\"🐟\", \"fish\"], // 12\n[\"🐙\", \"octopus\"], // 13\n[\"🦋\", \"butterfly\"], // 14\n[\"🌷\", \"flower\"], // 15\n[\"🌳\", \"tree\"], // 16\n[\"🌵\", \"cactus\"], // 17\n[\"🍄\", \"mushroom\"], // 18\n[\"🌏\", \"globe\"], // 19\n[\"🌙\", \"moon\"], // 20\n[\"☁️\", \"cloud\"], // 21\n[\"🔥\", \"fire\"], // 22\n[\"🍌\", \"banana\"], // 23\n[\"🍎\", \"apple\"], // 24\n[\"🍓\", \"strawberry\"], // 25\n[\"🌽\", \"corn\"], // 26\n[\"🍕\", \"pizza\"], // 27\n[\"🎂\", \"cake\"], // 28\n[\"❤️\", \"heart\"], // 29\n[\"🙂\", \"smiley\"], // 30\n[\"🤖\", \"robot\"], // 31\n[\"🎩\", \"hat\"], // 32\n[\"👓\", \"glasses\"], // 33\n[\"🔧\", \"spanner\"], // 34\n[\"🎅\", \"santa\"], // 35\n[\"👍\", \"thumbs up\"], // 36\n[\"☂️\", \"umbrella\"], // 37\n[\"⌛\", \"hourglass\"], // 38\n[\"⏰\", \"clock\"], // 39\n[\"🎁\", \"gift\"], // 40\n[\"💡\", \"light bulb\"], // 41\n[\"📕\", \"book\"], // 42\n[\"✏️\", \"pencil\"], // 43\n[\"📎\", \"paperclip\"], // 44\n[\"✂️\", \"scissors\"], // 45\n[\"🔒\", \"lock\"], // 46\n[\"🔑\", \"key\"], // 47\n[\"🔨\", \"hammer\"], // 48\n[\"☎️\", \"telephone\"], // 49\n[\"🏁\", \"flag\"], // 50\n[\"🚂\", \"train\"], // 51\n[\"🚲\", \"bicycle\"], // 52\n[\"✈️\", \"aeroplane\"], // 53\n[\"🚀\", \"rocket\"], // 54\n[\"🏆\", \"trophy\"], // 55\n[\"⚽\", \"ball\"], // 56\n[\"🎸\", \"guitar\"], // 57\n[\"🎺\", \"trumpet\"], // 58\n[\"🔔\", \"bell\"], // 59\n[\"⚓️\", \"anchor\"], // 60\n[\"🎧\", \"headphones\"], // 61\n[\"📁\", \"folder\"], // 62\n[\"📌\", \"pin\"] // 63\n];\n\nfunction generateEmojiSas(sasBytes) {\n  const emojis = [// just like base64 encoding\n  sasBytes[0] >> 2, (sasBytes[0] & 0x3) << 4 | sasBytes[1] >> 4, (sasBytes[1] & 0xf) << 2 | sasBytes[2] >> 6, sasBytes[2] & 0x3f, sasBytes[3] >> 2, (sasBytes[3] & 0x3) << 4 | sasBytes[4] >> 4, (sasBytes[4] & 0xf) << 2 | sasBytes[5] >> 6];\n  return emojis.map(num => emojiMapping[num]);\n}\n\nconst sasGenerators = {\n  decimal: generateDecimalSas,\n  emoji: generateEmojiSas\n};\n\nfunction generateSas(sasBytes, methods) {\n  const sas = {};\n\n  for (const method of methods) {\n    if (method in sasGenerators) {\n      sas[method] = sasGenerators[method](sasBytes);\n    }\n  }\n\n  return sas;\n}\n\nconst macMethods = {\n  \"hkdf-hmac-sha256\": \"calculate_mac\",\n  \"hmac-sha256\": \"calculate_mac_long_kdf\"\n};\n/* lists of algorithms/methods that are supported.  The key agreement, hashes,\n * and MAC lists should be sorted in order of preference (most preferred\n * first).\n */\n\nconst KEY_AGREEMENT_LIST = [\"curve25519\"];\nconst HASHES_LIST = [\"sha256\"];\nconst MAC_LIST = [\"hkdf-hmac-sha256\", \"hmac-sha256\"];\nconst SAS_LIST = Object.keys(sasGenerators);\nconst KEY_AGREEMENT_SET = new Set(KEY_AGREEMENT_LIST);\nconst HASHES_SET = new Set(HASHES_LIST);\nconst MAC_SET = new Set(MAC_LIST);\nconst SAS_SET = new Set(SAS_LIST);\n\nfunction intersection(anArray, aSet) {\n  return anArray instanceof Array ? anArray.filter(x => aSet.has(x)) : [];\n}\n/**\n * @alias module:crypto/verification/SAS\n * @extends {module:crypto/verification/Base}\n */\n\n\nclass SAS extends _Base.VerificationBase {\n  static get NAME() {\n    return \"m.sas.v1\";\n  }\n\n  get events() {\n    return EVENTS;\n  }\n\n  async _doVerification() {\n    await global.Olm.init();\n    olmutil = olmutil || new global.Olm.Utility(); // make sure user's keys are downloaded\n\n    await this._baseApis.downloadKeys([this.userId]);\n\n    if (this.startEvent) {\n      return await this._doRespondVerification();\n    } else {\n      return await this._doSendVerification();\n    }\n  }\n\n  async _doSendVerification() {\n    const type = \"m.key.verification.start\";\n\n    const initialMessage = this._channel.completeContent(type, {\n      method: SAS.NAME,\n      from_device: this._baseApis.deviceId,\n      key_agreement_protocols: KEY_AGREEMENT_LIST,\n      hashes: HASHES_LIST,\n      message_authentication_codes: MAC_LIST,\n      // FIXME: allow app to specify what SAS methods can be used\n      short_authentication_string: SAS_LIST\n    }); // add the transaction id to the message beforehand because\n    // it needs to be included in the commitment hash later on\n\n\n    this._channel.sendCompleted(type, initialMessage);\n\n    let e = await this._waitForEvent(\"m.key.verification.accept\");\n    let content = e.getContent();\n    const sasMethods = intersection(content.short_authentication_string, SAS_SET);\n\n    if (!(KEY_AGREEMENT_SET.has(content.key_agreement_protocol) && HASHES_SET.has(content.hash) && MAC_SET.has(content.message_authentication_code) && sasMethods.length)) {\n      throw (0, _Error.newUnknownMethodError)();\n    }\n\n    if (typeof content.commitment !== \"string\") {\n      throw (0, _Error.newInvalidMessageError)();\n    }\n\n    const macMethod = content.message_authentication_code;\n    const hashCommitment = content.commitment;\n    const olmSAS = new global.Olm.SAS();\n\n    try {\n      this._send(\"m.key.verification.key\", {\n        key: olmSAS.get_pubkey()\n      });\n\n      e = await this._waitForEvent(\"m.key.verification.key\"); // FIXME: make sure event is properly formed\n\n      content = e.getContent();\n\n      const commitmentStr = content.key + _anotherJson.default.stringify(initialMessage); // TODO: use selected hash function (when we support multiple)\n\n\n      if (olmutil.sha256(commitmentStr) !== hashCommitment) {\n        throw newMismatchedCommitmentError();\n      }\n\n      olmSAS.set_their_key(content.key);\n\n      const sasInfo = \"MATRIX_KEY_VERIFICATION_SAS\" + this._baseApis.getUserId() + this._baseApis.deviceId + this.userId + this.deviceId + this._channel.transactionId;\n\n      const sasBytes = olmSAS.generate_bytes(sasInfo, 6);\n      const verifySAS = new Promise((resolve, reject) => {\n        this.emit(\"show_sas\", {\n          sas: generateSas(sasBytes, sasMethods),\n          confirm: () => {\n            this._sendMAC(olmSAS, macMethod);\n\n            resolve();\n          },\n          cancel: () => reject((0, _Error.newUserCancelledError)()),\n          mismatch: () => reject(newMismatchedSASError())\n        });\n      });\n      [e] = await Promise.all([this._waitForEvent(\"m.key.verification.mac\").then(e => {\n        // we don't expect any more messages from the other\n        // party, and they may send a m.key.verification.done\n        // when they're done on their end\n        this._expectedEvent = \"m.key.verification.done\";\n        return e;\n      }), verifySAS]);\n      content = e.getContent();\n      await this._checkMAC(olmSAS, content, macMethod);\n    } finally {\n      olmSAS.free();\n    }\n  }\n\n  async _doRespondVerification() {\n    // as m.related_to is not included in the encrypted content in e2e rooms,\n    // we need to make sure it is added\n    let content = this._channel.completedContentFromEvent(this.startEvent); // Note: we intersect using our pre-made lists, rather than the sets,\n    // so that the result will be in our order of preference.  Then\n    // fetching the first element from the array will give our preferred\n    // method out of the ones offered by the other party.\n\n\n    const keyAgreement = intersection(KEY_AGREEMENT_LIST, new Set(content.key_agreement_protocols))[0];\n    const hashMethod = intersection(HASHES_LIST, new Set(content.hashes))[0];\n    const macMethod = intersection(MAC_LIST, new Set(content.message_authentication_codes))[0]; // FIXME: allow app to specify what SAS methods can be used\n\n    const sasMethods = intersection(content.short_authentication_string, SAS_SET);\n\n    if (!(keyAgreement !== undefined && hashMethod !== undefined && macMethod !== undefined && sasMethods.length)) {\n      throw (0, _Error.newUnknownMethodError)();\n    }\n\n    const olmSAS = new global.Olm.SAS();\n\n    try {\n      const commitmentStr = olmSAS.get_pubkey() + _anotherJson.default.stringify(content);\n\n      this._send(\"m.key.verification.accept\", {\n        key_agreement_protocol: keyAgreement,\n        hash: hashMethod,\n        message_authentication_code: macMethod,\n        short_authentication_string: sasMethods,\n        // TODO: use selected hash function (when we support multiple)\n        commitment: olmutil.sha256(commitmentStr)\n      });\n\n      let e = await this._waitForEvent(\"m.key.verification.key\"); // FIXME: make sure event is properly formed\n\n      content = e.getContent();\n      olmSAS.set_their_key(content.key);\n\n      this._send(\"m.key.verification.key\", {\n        key: olmSAS.get_pubkey()\n      });\n\n      const sasInfo = \"MATRIX_KEY_VERIFICATION_SAS\" + this.userId + this.deviceId + this._baseApis.getUserId() + this._baseApis.deviceId + this._channel.transactionId;\n\n      const sasBytes = olmSAS.generate_bytes(sasInfo, 6);\n      const verifySAS = new Promise((resolve, reject) => {\n        this.emit(\"show_sas\", {\n          sas: generateSas(sasBytes, sasMethods),\n          confirm: () => {\n            this._sendMAC(olmSAS, macMethod);\n\n            resolve();\n          },\n          cancel: () => reject((0, _Error.newUserCancelledError)()),\n          mismatch: () => reject(newMismatchedSASError())\n        });\n      });\n      [e] = await Promise.all([this._waitForEvent(\"m.key.verification.mac\").then(e => {\n        // we don't expect any more messages from the other\n        // party, and they may send a m.key.verification.done\n        // when they're done on their end\n        this._expectedEvent = \"m.key.verification.done\";\n        return e;\n      }), verifySAS]);\n      content = e.getContent();\n      await this._checkMAC(olmSAS, content, macMethod);\n    } finally {\n      olmSAS.free();\n    }\n  }\n\n  _sendMAC(olmSAS, method) {\n    const mac = {};\n    const keyList = [];\n\n    const baseInfo = \"MATRIX_KEY_VERIFICATION_MAC\" + this._baseApis.getUserId() + this._baseApis.deviceId + this.userId + this.deviceId + this._channel.transactionId;\n\n    const deviceKeyId = `ed25519:${this._baseApis.deviceId}`;\n    mac[deviceKeyId] = olmSAS[macMethods[method]](this._baseApis.getDeviceEd25519Key(), baseInfo + deviceKeyId);\n    keyList.push(deviceKeyId);\n\n    const crossSigningId = this._baseApis.getCrossSigningId();\n\n    if (crossSigningId) {\n      const crossSigningKeyId = `ed25519:${crossSigningId}`;\n      mac[crossSigningKeyId] = olmSAS[macMethods[method]](crossSigningId, baseInfo + crossSigningKeyId);\n      keyList.push(crossSigningKeyId);\n    }\n\n    const keys = olmSAS[macMethods[method]](keyList.sort().join(\",\"), baseInfo + \"KEY_IDS\");\n\n    this._send(\"m.key.verification.mac\", {\n      mac,\n      keys\n    });\n  }\n\n  async _checkMAC(olmSAS, content, method) {\n    const baseInfo = \"MATRIX_KEY_VERIFICATION_MAC\" + this.userId + this.deviceId + this._baseApis.getUserId() + this._baseApis.deviceId + this._channel.transactionId;\n\n    if (content.keys !== olmSAS[macMethods[method]](Object.keys(content.mac).sort().join(\",\"), baseInfo + \"KEY_IDS\")) {\n      throw (0, _Error.newKeyMismatchError)();\n    }\n\n    await this._verifyKeys(this.userId, content.mac, (keyId, device, keyInfo) => {\n      if (keyInfo !== olmSAS[macMethods[method]](device.keys[keyId], baseInfo + keyId)) {\n        throw (0, _Error.newKeyMismatchError)();\n      }\n    });\n  }\n\n}\n\nexports.SAS = SAS;"]},"metadata":{},"sourceType":"script"}