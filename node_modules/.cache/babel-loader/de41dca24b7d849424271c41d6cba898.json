{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VerificationRequest = exports.PHASE_DONE = exports.PHASE_CANCELLED = exports.PHASE_STARTED = exports.PHASE_REQUESTED = exports.PHASE_UNSENT = exports.DONE_TYPE = exports.CANCEL_TYPE = exports.START_TYPE = exports.REQUEST_TYPE = exports.EVENT_PREFIX = void 0;\n\nvar _logger = require(\"../../../logger\");\n\nvar _RequestCallbackChannel = require(\"./RequestCallbackChannel\");\n\nvar _events = require(\"events\");\n\nvar _Error = require(\"../Error\");\n/*\nCopyright 2018 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n// the recommended amount of time before a verification request\n// should be (automatically) cancelled without user interaction\n// and ignored.\n\n\nconst VERIFICATION_REQUEST_TIMEOUT = 10 * 60 * 1000; //10m\n// to avoid almost expired verification notifications\n// from showing a notification and almost immediately\n// disappearing, also ignore verification requests that\n// are this amount of time away from expiring.\n\nconst VERIFICATION_REQUEST_MARGIN = 3 * 1000; //3s\n\nconst EVENT_PREFIX = \"m.key.verification.\";\nexports.EVENT_PREFIX = EVENT_PREFIX;\nconst REQUEST_TYPE = EVENT_PREFIX + \"request\";\nexports.REQUEST_TYPE = REQUEST_TYPE;\nconst START_TYPE = EVENT_PREFIX + \"start\";\nexports.START_TYPE = START_TYPE;\nconst CANCEL_TYPE = EVENT_PREFIX + \"cancel\";\nexports.CANCEL_TYPE = CANCEL_TYPE;\nconst DONE_TYPE = EVENT_PREFIX + \"done\"; // export const READY_TYPE = EVENT_PREFIX + \"ready\";\n\nexports.DONE_TYPE = DONE_TYPE;\nconst PHASE_UNSENT = 1;\nexports.PHASE_UNSENT = PHASE_UNSENT;\nconst PHASE_REQUESTED = 2; // const PHASE_READY = 3;\n\nexports.PHASE_REQUESTED = PHASE_REQUESTED;\nconst PHASE_STARTED = 4;\nexports.PHASE_STARTED = PHASE_STARTED;\nconst PHASE_CANCELLED = 5;\nexports.PHASE_CANCELLED = PHASE_CANCELLED;\nconst PHASE_DONE = 6;\n/**\n * State machine for verification requests.\n * Things that differ based on what channel is used to\n * send and receive verification events are put in `InRoomChannel` or `ToDeviceChannel`.\n * @event \"change\" whenever the state of the request object has changed.\n */\n\nexports.PHASE_DONE = PHASE_DONE;\n\nclass VerificationRequest extends _events.EventEmitter {\n  constructor(channel, verificationMethods, userId, client) {\n    super();\n    this.channel = channel;\n    this._verificationMethods = verificationMethods;\n    this._client = client;\n    this._commonMethods = [];\n\n    this._setPhase(PHASE_UNSENT, false);\n\n    this._requestEvent = null;\n    this._otherUserId = userId;\n    this._initiatedByMe = null;\n    this._startTimestamp = null;\n  }\n  /**\n   * Stateless validation logic not specific to the channel.\n   * Invoked by the same static method in either channel.\n   * @param {string} type the \"symbolic\" event type, as returned by the `getEventType` function on the channel.\n   * @param {MatrixEvent} event the event to validate. Don't call getType() on it but use the `type` parameter instead.\n   * @param {number} timestamp the timestamp in milliseconds when this event was sent.\n   * @param {MatrixClient} client the client to get the current user and device id from\n   * @returns {bool} whether the event is valid and should be passed to handleEvent\n   */\n\n\n  static validateEvent(type, event, timestamp, client) {\n    const content = event.getContent();\n\n    if (!type.startsWith(EVENT_PREFIX)) {\n      return false;\n    }\n\n    if (type === REQUEST_TYPE) {\n      if (!Array.isArray(content.methods)) {\n        return false;\n      }\n    }\n\n    if (type === REQUEST_TYPE || type === START_TYPE) {\n      if (typeof content.from_device !== \"string\" || content.from_device.length === 0) {\n        return false;\n      }\n    } // a timestamp is not provided on all to_device events\n\n\n    if (Number.isFinite(timestamp)) {\n      const elapsed = Date.now() - timestamp; // ignore if event is too far in the past or too far in the future\n\n      if (elapsed > VERIFICATION_REQUEST_TIMEOUT - VERIFICATION_REQUEST_MARGIN || elapsed < -(VERIFICATION_REQUEST_TIMEOUT / 2)) {\n        _logger.logger.log(\"received verification that is too old or from the future\");\n\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /** once the phase is PHASE_STARTED, common methods supported by both sides */\n\n\n  get methods() {\n    return this._commonMethods;\n  }\n  /** the timeout of the request, provided for compatibility with previous verification code */\n\n\n  get timeout() {\n    const elapsed = Date.now() - this._startTimestamp;\n\n    return Math.max(0, VERIFICATION_REQUEST_TIMEOUT - elapsed);\n  }\n  /** the m.key.verification.request event that started this request, provided for compatibility with previous verification code */\n\n\n  get event() {\n    return this._requestEvent;\n  }\n  /** current phase of the request. Some properties might only be defined in a current phase. */\n\n\n  get phase() {\n    return this._phase;\n  }\n  /** The verifier to do the actual verification, once the method has been established. Only defined when the `phase` is PHASE_STARTED. */\n\n\n  get verifier() {\n    return this._verifier;\n  }\n  /** whether this request has sent it's initial event and needs more events to complete */\n\n\n  get pending() {\n    return this._phase !== PHASE_UNSENT && this._phase !== PHASE_DONE && this._phase !== PHASE_CANCELLED;\n  }\n  /** Whether this request was initiated by the syncing user.\n   * For InRoomChannel, this is who sent the .request event.\n   * For ToDeviceChannel, this is who sent the .start event\n   */\n\n\n  get initiatedByMe() {\n    return this._initiatedByMe;\n  }\n  /** the id of the user that initiated the request */\n\n\n  get requestingUserId() {\n    if (this.initiatedByMe) {\n      return this._client.getUserId();\n    } else {\n      return this._otherUserId;\n    }\n  }\n  /** the id of the user that (will) receive(d) the request */\n\n\n  get receivingUserId() {\n    if (this.initiatedByMe) {\n      return this._otherUserId;\n    } else {\n      return this._client.getUserId();\n    }\n  }\n  /* Start the key verification, creating a verifier and sending a .start event.\n   * If no previous events have been sent, pass in `targetDevice` to set who to direct this request to.\n   * @param {string} method the name of the verification method to use.\n   * @param {string?} targetDevice.userId the id of the user to direct this request to\n   * @param {string?} targetDevice.deviceId the id of the device to direct this request to\n   * @returns {VerifierBase} the verifier of the given method\n   */\n\n\n  beginKeyVerification(method, targetDevice = null) {\n    // need to allow also when unsent in case of to_device\n    if (!this._verifier) {\n      if (this._hasValidPreStartPhase()) {\n        // when called on a request that was initiated with .request event\n        // check the method is supported by both sides\n        if (this._commonMethods.length && !this._commonMethods.includes(method)) {\n          throw (0, _Error.newUnknownMethodError)();\n        }\n\n        this._verifier = this._createVerifier(method, null, targetDevice);\n\n        if (!this._verifier) {\n          throw (0, _Error.newUnknownMethodError)();\n        }\n      }\n    }\n\n    return this._verifier;\n  }\n  /**\n   * sends the initial .request event.\n   * @returns {Promise} resolves when the event has been sent.\n   */\n\n\n  async sendRequest() {\n    if (this._phase === PHASE_UNSENT) {\n      this._initiatedByMe = true;\n\n      this._setPhase(PHASE_REQUESTED, false);\n\n      const methods = [...this._verificationMethods.keys()];\n      await this.channel.send(REQUEST_TYPE, {\n        methods\n      });\n      this.emit(\"change\");\n    }\n  }\n  /**\n   * Cancels the request, sending a cancellation to the other party\n   * @param {string?} error.reason the error reason to send the cancellation with\n   * @param {string?} error.code the error code to send the cancellation with\n   * @returns {Promise} resolves when the event has been sent.\n   */\n\n\n  async cancel({\n    reason = \"User declined\",\n    code = \"m.user\"\n  } = {}) {\n    if (this._phase !== PHASE_CANCELLED) {\n      if (this._verifier) {\n        return this._verifier.cancel((0, _Error.errorFactory)(code, reason));\n      } else {\n        this._setPhase(PHASE_CANCELLED, false);\n\n        await this.channel.send(CANCEL_TYPE, {\n          code,\n          reason\n        });\n      }\n\n      this.emit(\"change\");\n    }\n  }\n  /** @returns {Promise} with the verifier once it becomes available. Can be used after calling `sendRequest`. */\n\n\n  waitForVerifier() {\n    if (this.verifier) {\n      return Promise.resolve(this.verifier);\n    } else {\n      return new Promise(resolve => {\n        const checkVerifier = () => {\n          if (this.verifier) {\n            this.off(\"change\", checkVerifier);\n            resolve(this.verifier);\n          }\n        };\n\n        this.on(\"change\", checkVerifier);\n      });\n    }\n  }\n\n  _setPhase(phase, notify = true) {\n    this._phase = phase;\n\n    if (notify) {\n      this.emit(\"change\");\n    }\n  }\n  /**\n   * Changes the state of the request and verifier in response to a key verification event.\n   * @param {string} type the \"symbolic\" event type, as returned by the `getEventType` function on the channel.\n   * @param {MatrixEvent} event the event to handle. Don't call getType() on it but use the `type` parameter instead.\n   * @param {number} timestamp the timestamp in milliseconds when this event was sent.\n   * @returns {Promise} a promise that resolves when any requests as an anwser to the passed-in event are sent.\n   */\n\n\n  async handleEvent(type, event, timestamp) {\n    const content = event.getContent();\n\n    if (type === REQUEST_TYPE || type === START_TYPE) {\n      if (this._startTimestamp === null) {\n        this._startTimestamp = timestamp;\n      }\n    }\n\n    if (type === REQUEST_TYPE) {\n      await this._handleRequest(content, event);\n    } else if (type === START_TYPE) {\n      await this._handleStart(content, event);\n    }\n\n    if (this._verifier) {\n      if (type === CANCEL_TYPE || this._verifier.events && this._verifier.events.includes(type)) {\n        this._verifier.handleEvent(event);\n      }\n    }\n\n    if (type === CANCEL_TYPE) {\n      this._handleCancel();\n    } else if (type === DONE_TYPE) {\n      this._handleDone();\n    }\n  }\n\n  async _handleRequest(content, event) {\n    if (this._phase === PHASE_UNSENT) {\n      const otherMethods = content.methods;\n      this._commonMethods = otherMethods.filter(m => this._verificationMethods.has(m));\n      this._requestEvent = event;\n      this._initiatedByMe = this._wasSentByMe(event);\n\n      this._setPhase(PHASE_REQUESTED);\n    } else if (this._phase !== PHASE_REQUESTED) {\n      _logger.logger.warn(\"Ignoring flagged verification request from \" + event.getSender());\n\n      await this.cancel((0, _Error.errorFromEvent)((0, _Error.newUnexpectedMessageError)()));\n    }\n  }\n\n  _hasValidPreStartPhase() {\n    return this._phase === PHASE_REQUESTED || this.channel.constructor.canCreateRequest(START_TYPE) && this._phase === PHASE_UNSENT;\n  }\n\n  async _handleStart(content, event) {\n    if (this._hasValidPreStartPhase()) {\n      const {\n        method\n      } = content;\n\n      if (!this._verificationMethods.has(method)) {\n        await this.cancel((0, _Error.errorFromEvent)((0, _Error.newUnknownMethodError)()));\n      } else {\n        // if not in requested phase\n        if (this.phase === PHASE_UNSENT) {\n          this._initiatedByMe = this._wasSentByMe(event);\n        }\n\n        this._verifier = this._createVerifier(method, event);\n\n        this._setPhase(PHASE_STARTED);\n      }\n    }\n  }\n  /**\n   * Called by RequestCallbackChannel when the verifier sends an event\n   * @param {string} type the \"symbolic\" event type\n   * @param {object} content the completed or uncompleted content for the event to be sent\n   */\n\n\n  handleVerifierSend(type, content) {\n    if (type === CANCEL_TYPE) {\n      this._handleCancel();\n    } else if (type === START_TYPE) {\n      if (this._phase === PHASE_UNSENT || this._phase === PHASE_REQUESTED) {\n        // if unsent, we're sending a (first) .start event and hence requesting the verification.\n        // in any other situation, the request was initiated by the other party.\n        this._initiatedByMe = this.phase === PHASE_UNSENT;\n\n        this._setPhase(PHASE_STARTED);\n      }\n    }\n  }\n\n  _handleCancel() {\n    if (this._phase !== PHASE_CANCELLED) {\n      this._setPhase(PHASE_CANCELLED);\n    }\n  }\n\n  _handleDone() {\n    if (this._phase === PHASE_STARTED) {\n      this._setPhase(PHASE_DONE);\n    }\n  }\n\n  _createVerifier(method, startEvent = null, targetDevice = null) {\n    const startSentByMe = startEvent && this._wasSentByMe(startEvent);\n\n    const {\n      userId,\n      deviceId\n    } = this._getVerifierTarget(startEvent, targetDevice);\n\n    const VerifierCtor = this._verificationMethods.get(method);\n\n    if (!VerifierCtor) {\n      console.warn(\"could not find verifier constructor for method\", method);\n      return;\n    } // invokes handleVerifierSend when verifier sends something\n\n\n    const callbackMedium = new _RequestCallbackChannel.RequestCallbackChannel(this, this.channel);\n    return new VerifierCtor(callbackMedium, this._client, userId, deviceId, startSentByMe ? null : startEvent);\n  }\n\n  _getVerifierTarget(startEvent, targetDevice) {\n    // targetDevice should be set when creating a verifier for to_device before the .start event has been sent,\n    // so the userId and deviceId are provided\n    if (targetDevice) {\n      return targetDevice;\n    } else {\n      let targetEvent;\n\n      if (startEvent && !this._wasSentByMe(startEvent)) {\n        targetEvent = startEvent;\n      } else if (this._requestEvent && !this._wasSentByMe(this._requestEvent)) {\n        targetEvent = this._requestEvent;\n      } else {\n        throw new Error(\"can't determine who the verifier should be targeted at. \" + \"No .request or .start event and no targetDevice\");\n      }\n\n      const userId = targetEvent.getSender();\n      const content = targetEvent.getContent();\n      const deviceId = content && content.from_device;\n      return {\n        userId,\n        deviceId\n      };\n    }\n  } // only for .request and .start\n\n\n  _wasSentByMe(event) {\n    if (event.getSender() !== this._client.getUserId()) {\n      return false;\n    }\n\n    const content = event.getContent();\n\n    if (!content || content.from_device !== this._client.getDeviceId()) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n\nexports.VerificationRequest = VerificationRequest;","map":{"version":3,"sources":["/home/kimist/Developpement/React/watcha_client/node_modules/matrix-js-sdk/lib/crypto/verification/request/VerificationRequest.js"],"names":["Object","defineProperty","exports","value","VerificationRequest","PHASE_DONE","PHASE_CANCELLED","PHASE_STARTED","PHASE_REQUESTED","PHASE_UNSENT","DONE_TYPE","CANCEL_TYPE","START_TYPE","REQUEST_TYPE","EVENT_PREFIX","_logger","require","_RequestCallbackChannel","_events","_Error","VERIFICATION_REQUEST_TIMEOUT","VERIFICATION_REQUEST_MARGIN","EventEmitter","constructor","channel","verificationMethods","userId","client","_verificationMethods","_client","_commonMethods","_setPhase","_requestEvent","_otherUserId","_initiatedByMe","_startTimestamp","validateEvent","type","event","timestamp","content","getContent","startsWith","Array","isArray","methods","from_device","length","Number","isFinite","elapsed","Date","now","logger","log","timeout","Math","max","phase","_phase","verifier","_verifier","pending","initiatedByMe","requestingUserId","getUserId","receivingUserId","beginKeyVerification","method","targetDevice","_hasValidPreStartPhase","includes","newUnknownMethodError","_createVerifier","sendRequest","keys","send","emit","cancel","reason","code","errorFactory","waitForVerifier","Promise","resolve","checkVerifier","off","on","notify","handleEvent","_handleRequest","_handleStart","events","_handleCancel","_handleDone","otherMethods","filter","m","has","_wasSentByMe","warn","getSender","errorFromEvent","newUnexpectedMessageError","canCreateRequest","handleVerifierSend","startEvent","startSentByMe","deviceId","_getVerifierTarget","VerifierCtor","get","console","callbackMedium","RequestCallbackChannel","targetEvent","Error","getDeviceId"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VerificationRequest = exports.PHASE_DONE = exports.PHASE_CANCELLED = exports.PHASE_STARTED = exports.PHASE_REQUESTED = exports.PHASE_UNSENT = exports.DONE_TYPE = exports.CANCEL_TYPE = exports.START_TYPE = exports.REQUEST_TYPE = exports.EVENT_PREFIX = void 0;\n\nvar _logger = require(\"../../../logger\");\n\nvar _RequestCallbackChannel = require(\"./RequestCallbackChannel\");\n\nvar _events = require(\"events\");\n\nvar _Error = require(\"../Error\");\n\n/*\nCopyright 2018 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n// the recommended amount of time before a verification request\n// should be (automatically) cancelled without user interaction\n// and ignored.\nconst VERIFICATION_REQUEST_TIMEOUT = 10 * 60 * 1000; //10m\n// to avoid almost expired verification notifications\n// from showing a notification and almost immediately\n// disappearing, also ignore verification requests that\n// are this amount of time away from expiring.\n\nconst VERIFICATION_REQUEST_MARGIN = 3 * 1000; //3s\n\nconst EVENT_PREFIX = \"m.key.verification.\";\nexports.EVENT_PREFIX = EVENT_PREFIX;\nconst REQUEST_TYPE = EVENT_PREFIX + \"request\";\nexports.REQUEST_TYPE = REQUEST_TYPE;\nconst START_TYPE = EVENT_PREFIX + \"start\";\nexports.START_TYPE = START_TYPE;\nconst CANCEL_TYPE = EVENT_PREFIX + \"cancel\";\nexports.CANCEL_TYPE = CANCEL_TYPE;\nconst DONE_TYPE = EVENT_PREFIX + \"done\"; // export const READY_TYPE = EVENT_PREFIX + \"ready\";\n\nexports.DONE_TYPE = DONE_TYPE;\nconst PHASE_UNSENT = 1;\nexports.PHASE_UNSENT = PHASE_UNSENT;\nconst PHASE_REQUESTED = 2; // const PHASE_READY = 3;\n\nexports.PHASE_REQUESTED = PHASE_REQUESTED;\nconst PHASE_STARTED = 4;\nexports.PHASE_STARTED = PHASE_STARTED;\nconst PHASE_CANCELLED = 5;\nexports.PHASE_CANCELLED = PHASE_CANCELLED;\nconst PHASE_DONE = 6;\n/**\n * State machine for verification requests.\n * Things that differ based on what channel is used to\n * send and receive verification events are put in `InRoomChannel` or `ToDeviceChannel`.\n * @event \"change\" whenever the state of the request object has changed.\n */\n\nexports.PHASE_DONE = PHASE_DONE;\n\nclass VerificationRequest extends _events.EventEmitter {\n  constructor(channel, verificationMethods, userId, client) {\n    super();\n    this.channel = channel;\n    this._verificationMethods = verificationMethods;\n    this._client = client;\n    this._commonMethods = [];\n\n    this._setPhase(PHASE_UNSENT, false);\n\n    this._requestEvent = null;\n    this._otherUserId = userId;\n    this._initiatedByMe = null;\n    this._startTimestamp = null;\n  }\n  /**\n   * Stateless validation logic not specific to the channel.\n   * Invoked by the same static method in either channel.\n   * @param {string} type the \"symbolic\" event type, as returned by the `getEventType` function on the channel.\n   * @param {MatrixEvent} event the event to validate. Don't call getType() on it but use the `type` parameter instead.\n   * @param {number} timestamp the timestamp in milliseconds when this event was sent.\n   * @param {MatrixClient} client the client to get the current user and device id from\n   * @returns {bool} whether the event is valid and should be passed to handleEvent\n   */\n\n\n  static validateEvent(type, event, timestamp, client) {\n    const content = event.getContent();\n\n    if (!type.startsWith(EVENT_PREFIX)) {\n      return false;\n    }\n\n    if (type === REQUEST_TYPE) {\n      if (!Array.isArray(content.methods)) {\n        return false;\n      }\n    }\n\n    if (type === REQUEST_TYPE || type === START_TYPE) {\n      if (typeof content.from_device !== \"string\" || content.from_device.length === 0) {\n        return false;\n      }\n    } // a timestamp is not provided on all to_device events\n\n\n    if (Number.isFinite(timestamp)) {\n      const elapsed = Date.now() - timestamp; // ignore if event is too far in the past or too far in the future\n\n      if (elapsed > VERIFICATION_REQUEST_TIMEOUT - VERIFICATION_REQUEST_MARGIN || elapsed < -(VERIFICATION_REQUEST_TIMEOUT / 2)) {\n        _logger.logger.log(\"received verification that is too old or from the future\");\n\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /** once the phase is PHASE_STARTED, common methods supported by both sides */\n\n\n  get methods() {\n    return this._commonMethods;\n  }\n  /** the timeout of the request, provided for compatibility with previous verification code */\n\n\n  get timeout() {\n    const elapsed = Date.now() - this._startTimestamp;\n\n    return Math.max(0, VERIFICATION_REQUEST_TIMEOUT - elapsed);\n  }\n  /** the m.key.verification.request event that started this request, provided for compatibility with previous verification code */\n\n\n  get event() {\n    return this._requestEvent;\n  }\n  /** current phase of the request. Some properties might only be defined in a current phase. */\n\n\n  get phase() {\n    return this._phase;\n  }\n  /** The verifier to do the actual verification, once the method has been established. Only defined when the `phase` is PHASE_STARTED. */\n\n\n  get verifier() {\n    return this._verifier;\n  }\n  /** whether this request has sent it's initial event and needs more events to complete */\n\n\n  get pending() {\n    return this._phase !== PHASE_UNSENT && this._phase !== PHASE_DONE && this._phase !== PHASE_CANCELLED;\n  }\n  /** Whether this request was initiated by the syncing user.\n   * For InRoomChannel, this is who sent the .request event.\n   * For ToDeviceChannel, this is who sent the .start event\n   */\n\n\n  get initiatedByMe() {\n    return this._initiatedByMe;\n  }\n  /** the id of the user that initiated the request */\n\n\n  get requestingUserId() {\n    if (this.initiatedByMe) {\n      return this._client.getUserId();\n    } else {\n      return this._otherUserId;\n    }\n  }\n  /** the id of the user that (will) receive(d) the request */\n\n\n  get receivingUserId() {\n    if (this.initiatedByMe) {\n      return this._otherUserId;\n    } else {\n      return this._client.getUserId();\n    }\n  }\n  /* Start the key verification, creating a verifier and sending a .start event.\n   * If no previous events have been sent, pass in `targetDevice` to set who to direct this request to.\n   * @param {string} method the name of the verification method to use.\n   * @param {string?} targetDevice.userId the id of the user to direct this request to\n   * @param {string?} targetDevice.deviceId the id of the device to direct this request to\n   * @returns {VerifierBase} the verifier of the given method\n   */\n\n\n  beginKeyVerification(method, targetDevice = null) {\n    // need to allow also when unsent in case of to_device\n    if (!this._verifier) {\n      if (this._hasValidPreStartPhase()) {\n        // when called on a request that was initiated with .request event\n        // check the method is supported by both sides\n        if (this._commonMethods.length && !this._commonMethods.includes(method)) {\n          throw (0, _Error.newUnknownMethodError)();\n        }\n\n        this._verifier = this._createVerifier(method, null, targetDevice);\n\n        if (!this._verifier) {\n          throw (0, _Error.newUnknownMethodError)();\n        }\n      }\n    }\n\n    return this._verifier;\n  }\n  /**\n   * sends the initial .request event.\n   * @returns {Promise} resolves when the event has been sent.\n   */\n\n\n  async sendRequest() {\n    if (this._phase === PHASE_UNSENT) {\n      this._initiatedByMe = true;\n\n      this._setPhase(PHASE_REQUESTED, false);\n\n      const methods = [...this._verificationMethods.keys()];\n      await this.channel.send(REQUEST_TYPE, {\n        methods\n      });\n      this.emit(\"change\");\n    }\n  }\n  /**\n   * Cancels the request, sending a cancellation to the other party\n   * @param {string?} error.reason the error reason to send the cancellation with\n   * @param {string?} error.code the error code to send the cancellation with\n   * @returns {Promise} resolves when the event has been sent.\n   */\n\n\n  async cancel({\n    reason = \"User declined\",\n    code = \"m.user\"\n  } = {}) {\n    if (this._phase !== PHASE_CANCELLED) {\n      if (this._verifier) {\n        return this._verifier.cancel((0, _Error.errorFactory)(code, reason));\n      } else {\n        this._setPhase(PHASE_CANCELLED, false);\n\n        await this.channel.send(CANCEL_TYPE, {\n          code,\n          reason\n        });\n      }\n\n      this.emit(\"change\");\n    }\n  }\n  /** @returns {Promise} with the verifier once it becomes available. Can be used after calling `sendRequest`. */\n\n\n  waitForVerifier() {\n    if (this.verifier) {\n      return Promise.resolve(this.verifier);\n    } else {\n      return new Promise(resolve => {\n        const checkVerifier = () => {\n          if (this.verifier) {\n            this.off(\"change\", checkVerifier);\n            resolve(this.verifier);\n          }\n        };\n\n        this.on(\"change\", checkVerifier);\n      });\n    }\n  }\n\n  _setPhase(phase, notify = true) {\n    this._phase = phase;\n\n    if (notify) {\n      this.emit(\"change\");\n    }\n  }\n  /**\n   * Changes the state of the request and verifier in response to a key verification event.\n   * @param {string} type the \"symbolic\" event type, as returned by the `getEventType` function on the channel.\n   * @param {MatrixEvent} event the event to handle. Don't call getType() on it but use the `type` parameter instead.\n   * @param {number} timestamp the timestamp in milliseconds when this event was sent.\n   * @returns {Promise} a promise that resolves when any requests as an anwser to the passed-in event are sent.\n   */\n\n\n  async handleEvent(type, event, timestamp) {\n    const content = event.getContent();\n\n    if (type === REQUEST_TYPE || type === START_TYPE) {\n      if (this._startTimestamp === null) {\n        this._startTimestamp = timestamp;\n      }\n    }\n\n    if (type === REQUEST_TYPE) {\n      await this._handleRequest(content, event);\n    } else if (type === START_TYPE) {\n      await this._handleStart(content, event);\n    }\n\n    if (this._verifier) {\n      if (type === CANCEL_TYPE || this._verifier.events && this._verifier.events.includes(type)) {\n        this._verifier.handleEvent(event);\n      }\n    }\n\n    if (type === CANCEL_TYPE) {\n      this._handleCancel();\n    } else if (type === DONE_TYPE) {\n      this._handleDone();\n    }\n  }\n\n  async _handleRequest(content, event) {\n    if (this._phase === PHASE_UNSENT) {\n      const otherMethods = content.methods;\n      this._commonMethods = otherMethods.filter(m => this._verificationMethods.has(m));\n      this._requestEvent = event;\n      this._initiatedByMe = this._wasSentByMe(event);\n\n      this._setPhase(PHASE_REQUESTED);\n    } else if (this._phase !== PHASE_REQUESTED) {\n      _logger.logger.warn(\"Ignoring flagged verification request from \" + event.getSender());\n\n      await this.cancel((0, _Error.errorFromEvent)((0, _Error.newUnexpectedMessageError)()));\n    }\n  }\n\n  _hasValidPreStartPhase() {\n    return this._phase === PHASE_REQUESTED || this.channel.constructor.canCreateRequest(START_TYPE) && this._phase === PHASE_UNSENT;\n  }\n\n  async _handleStart(content, event) {\n    if (this._hasValidPreStartPhase()) {\n      const {\n        method\n      } = content;\n\n      if (!this._verificationMethods.has(method)) {\n        await this.cancel((0, _Error.errorFromEvent)((0, _Error.newUnknownMethodError)()));\n      } else {\n        // if not in requested phase\n        if (this.phase === PHASE_UNSENT) {\n          this._initiatedByMe = this._wasSentByMe(event);\n        }\n\n        this._verifier = this._createVerifier(method, event);\n\n        this._setPhase(PHASE_STARTED);\n      }\n    }\n  }\n  /**\n   * Called by RequestCallbackChannel when the verifier sends an event\n   * @param {string} type the \"symbolic\" event type\n   * @param {object} content the completed or uncompleted content for the event to be sent\n   */\n\n\n  handleVerifierSend(type, content) {\n    if (type === CANCEL_TYPE) {\n      this._handleCancel();\n    } else if (type === START_TYPE) {\n      if (this._phase === PHASE_UNSENT || this._phase === PHASE_REQUESTED) {\n        // if unsent, we're sending a (first) .start event and hence requesting the verification.\n        // in any other situation, the request was initiated by the other party.\n        this._initiatedByMe = this.phase === PHASE_UNSENT;\n\n        this._setPhase(PHASE_STARTED);\n      }\n    }\n  }\n\n  _handleCancel() {\n    if (this._phase !== PHASE_CANCELLED) {\n      this._setPhase(PHASE_CANCELLED);\n    }\n  }\n\n  _handleDone() {\n    if (this._phase === PHASE_STARTED) {\n      this._setPhase(PHASE_DONE);\n    }\n  }\n\n  _createVerifier(method, startEvent = null, targetDevice = null) {\n    const startSentByMe = startEvent && this._wasSentByMe(startEvent);\n\n    const {\n      userId,\n      deviceId\n    } = this._getVerifierTarget(startEvent, targetDevice);\n\n    const VerifierCtor = this._verificationMethods.get(method);\n\n    if (!VerifierCtor) {\n      console.warn(\"could not find verifier constructor for method\", method);\n      return;\n    } // invokes handleVerifierSend when verifier sends something\n\n\n    const callbackMedium = new _RequestCallbackChannel.RequestCallbackChannel(this, this.channel);\n    return new VerifierCtor(callbackMedium, this._client, userId, deviceId, startSentByMe ? null : startEvent);\n  }\n\n  _getVerifierTarget(startEvent, targetDevice) {\n    // targetDevice should be set when creating a verifier for to_device before the .start event has been sent,\n    // so the userId and deviceId are provided\n    if (targetDevice) {\n      return targetDevice;\n    } else {\n      let targetEvent;\n\n      if (startEvent && !this._wasSentByMe(startEvent)) {\n        targetEvent = startEvent;\n      } else if (this._requestEvent && !this._wasSentByMe(this._requestEvent)) {\n        targetEvent = this._requestEvent;\n      } else {\n        throw new Error(\"can't determine who the verifier should be targeted at. \" + \"No .request or .start event and no targetDevice\");\n      }\n\n      const userId = targetEvent.getSender();\n      const content = targetEvent.getContent();\n      const deviceId = content && content.from_device;\n      return {\n        userId,\n        deviceId\n      };\n    }\n  } // only for .request and .start\n\n\n  _wasSentByMe(event) {\n    if (event.getSender() !== this._client.getUserId()) {\n      return false;\n    }\n\n    const content = event.getContent();\n\n    if (!content || content.from_device !== this._client.getDeviceId()) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n\nexports.VerificationRequest = VerificationRequest;"]},"metadata":{},"sourceType":"script"}