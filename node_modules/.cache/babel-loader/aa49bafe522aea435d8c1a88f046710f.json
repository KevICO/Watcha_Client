{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MatrixHttpApi = MatrixHttpApi;\nexports.MatrixError = MatrixError;\nexports.PREFIX_MEDIA_R0 = exports.PREFIX_IDENTITY_V2 = exports.PREFIX_IDENTITY_V1 = exports.PREFIX_UNSTABLE = exports.PREFIX_R0 = void 0;\n\nvar _contentType = require(\"content-type\");\n\nvar utils = _interopRequireWildcard(require(\"./utils\"));\n\nvar _logger = require(\"./logger\");\n\nvar callbacks = _interopRequireWildcard(require(\"./realtime-callbacks\"));\n/*\nCopyright 2015, 2016 OpenMarket Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * This is an internal module. See {@link MatrixHttpApi} for the public class.\n * @module http-api\n */\n// we use our own implementation of setTimeout, so that if we get suspended in\n// the middle of a /sync, we cancel the sync as soon as we awake, rather than\n// waiting for the delay to elapse.\n\n/*\nTODO:\n- CS: complete register function (doing stages)\n- Identity server: linkEmail, authEmail, bindEmail, lookup3pid\n*/\n\n/**\n * A constant representing the URI path for release 0 of the Client-Server HTTP API.\n */\n\n\nconst PREFIX_R0 = \"/_matrix/client/r0\";\n/**\n * A constant representing the URI path for as-yet unspecified Client-Server HTTP APIs.\n */\n\nexports.PREFIX_R0 = PREFIX_R0;\nconst PREFIX_UNSTABLE = \"/_matrix/client/unstable\";\n/**\n * URI path for v1 of the the identity API\n */\n\nexports.PREFIX_UNSTABLE = PREFIX_UNSTABLE;\nconst PREFIX_IDENTITY_V1 = \"/_matrix/identity/api/v1\";\n/**\n * URI path for the v2 identity API\n */\n\nexports.PREFIX_IDENTITY_V1 = PREFIX_IDENTITY_V1;\nconst PREFIX_IDENTITY_V2 = \"/_matrix/identity/v2\";\n/**\n * URI path for the media repo API\n */\n\nexports.PREFIX_IDENTITY_V2 = PREFIX_IDENTITY_V2;\nconst PREFIX_MEDIA_R0 = \"/_matrix/media/r0\";\n/**\n * Construct a MatrixHttpApi.\n * @constructor\n * @param {EventEmitter} event_emitter The event emitter to use for emitting events\n * @param {Object} opts The options to use for this HTTP API.\n * @param {string} opts.baseUrl Required. The base client-server URL e.g.\n * 'http://localhost:8008'.\n * @param {Function} opts.request Required. The function to call for HTTP\n * requests. This function must look like function(opts, callback){ ... }.\n * @param {string} opts.prefix Required. The matrix client prefix to use, e.g.\n * '/_matrix/client/r0'. See PREFIX_R0 and PREFIX_UNSTABLE for constants.\n *\n * @param {boolean} opts.onlyData True to return only the 'data' component of the\n * response (e.g. the parsed HTTP body). If false, requests will return an\n * object with the properties <tt>code</tt>, <tt>headers</tt> and <tt>data</tt>.\n *\n * @param {string} opts.accessToken The access_token to send with requests. Can be\n * null to not send an access token.\n * @param {Object=} opts.extraParams Optional. Extra query parameters to send on\n * requests.\n * @param {Number=} opts.localTimeoutMs The default maximum amount of time to wait\n * before timing out the request. If not specified, there is no timeout.\n * @param {boolean} [opts.useAuthorizationHeader = false] Set to true to use\n * Authorization header instead of query param to send the access token to the server.\n */\n\nexports.PREFIX_MEDIA_R0 = PREFIX_MEDIA_R0;\n\nfunction MatrixHttpApi(event_emitter, opts) {\n  utils.checkObjectHasKeys(opts, [\"baseUrl\", \"request\", \"prefix\"]);\n  opts.onlyData = opts.onlyData || false;\n  this.event_emitter = event_emitter;\n  this.opts = opts;\n  this.useAuthorizationHeader = Boolean(opts.useAuthorizationHeader);\n  this.uploads = [];\n}\n\nMatrixHttpApi.prototype = {\n  /**\n   * Sets the baase URL for the identity server\n   * @param {string} url The new base url\n   */\n  setIdBaseUrl: function (url) {\n    this.opts.idBaseUrl = url;\n  },\n\n  /**\n   * Get the content repository url with query parameters.\n   * @return {Object} An object with a 'base', 'path' and 'params' for base URL,\n   *          path and query parameters respectively.\n   */\n  getContentUri: function () {\n    const params = {\n      access_token: this.opts.accessToken\n    };\n    return {\n      base: this.opts.baseUrl,\n      path: \"/_matrix/media/r0/upload\",\n      params: params\n    };\n  },\n\n  /**\n   * Upload content to the Home Server\n   *\n   * @param {object} file The object to upload. On a browser, something that\n   *   can be sent to XMLHttpRequest.send (typically a File).  Under node.js,\n   *   a Buffer, String or ReadStream.\n   *\n   * @param {object} opts  options object\n   *\n   * @param {string=} opts.name   Name to give the file on the server. Defaults\n   *   to <tt>file.name</tt>.\n   *\n   * @param {boolean=} opts.includeFilename if false will not send the filename,\n   *   e.g for encrypted file uploads where filename leaks are undesirable.\n   *   Defaults to true.\n   *\n   * @param {string=} opts.type   Content-type for the upload. Defaults to\n   *   <tt>file.type</tt>, or <tt>applicaton/octet-stream</tt>.\n   *\n   * @param {boolean=} opts.rawResponse Return the raw body, rather than\n   *   parsing the JSON. Defaults to false (except on node.js, where it\n   *   defaults to true for backwards compatibility).\n   *\n   * @param {boolean=} opts.onlyContentUri Just return the content URI,\n   *   rather than the whole body. Defaults to false (except on browsers,\n   *   where it defaults to true for backwards compatibility). Ignored if\n   *   opts.rawResponse is true.\n   *\n   * @param {Function=} opts.callback Deprecated. Optional. The callback to\n   *    invoke on success/failure. See the promise return values for more\n   *    information.\n   *\n   * @param {Function=} opts.progressHandler Optional. Called when a chunk of\n   *    data has been uploaded, with an object containing the fields `loaded`\n   *    (number of bytes transferred) and `total` (total size, if known).\n   *\n   * @return {module:client.Promise} Resolves to response object, as\n   *    determined by this.opts.onlyData, opts.rawResponse, and\n   *    opts.onlyContentUri.  Rejects with an error (usually a MatrixError).\n   */\n  uploadContent: function (file, opts) {\n    if (utils.isFunction(opts)) {\n      // opts used to be callback\n      opts = {\n        callback: opts\n      };\n    } else if (opts === undefined) {\n      opts = {};\n    } // default opts.includeFilename to true (ignoring falsey values)\n\n\n    const includeFilename = opts.includeFilename !== false; // if the file doesn't have a mime type, use a default since\n    // the HS errors if we don't supply one.\n\n    const contentType = opts.type || file.type || 'application/octet-stream';\n    const fileName = opts.name || file.name; // We used to recommend setting file.stream to the thing to upload on\n    // Node.js. As of 2019-06-11, this is still in widespread use in various\n    // clients, so we should preserve this for simple objects used in\n    // Node.js. File API objects (via either the File or Blob interfaces) in\n    // the browser now define a `stream` method, which leads to trouble\n    // here, so we also check the type of `stream`.\n\n    let body = file;\n\n    if (body.stream && typeof body.stream !== \"function\") {\n      _logger.logger.warn(\"Using `file.stream` as the content to upload. Future \" + \"versions of the js-sdk will change this to expect `file` to \" + \"be the content directly.\");\n\n      body = body.stream;\n    } // backwards-compatibility hacks where we used to do different things\n    // between browser and node.\n\n\n    let rawResponse = opts.rawResponse;\n\n    if (rawResponse === undefined) {\n      if (global.XMLHttpRequest) {\n        rawResponse = false;\n      } else {\n        _logger.logger.warn(\"Returning the raw JSON from uploadContent(). Future \" + \"versions of the js-sdk will change this default, to \" + \"return the parsed object. Set opts.rawResponse=false \" + \"to change this behaviour now.\");\n\n        rawResponse = true;\n      }\n    }\n\n    let onlyContentUri = opts.onlyContentUri;\n\n    if (!rawResponse && onlyContentUri === undefined) {\n      if (global.XMLHttpRequest) {\n        _logger.logger.warn(\"Returning only the content-uri from uploadContent(). \" + \"Future versions of the js-sdk will change this \" + \"default, to return the whole response object. Set \" + \"opts.onlyContentUri=false to change this behaviour now.\");\n\n        onlyContentUri = true;\n      } else {\n        onlyContentUri = false;\n      }\n    } // browser-request doesn't support File objects because it deep-copies\n    // the options using JSON.parse(JSON.stringify(options)). Instead of\n    // loading the whole file into memory as a string and letting\n    // browser-request base64 encode and then decode it again, we just\n    // use XMLHttpRequest directly.\n    // (browser-request doesn't support progress either, which is also kind\n    // of important here)\n\n\n    const upload = {\n      loaded: 0,\n      total: 0\n    };\n    let promise; // XMLHttpRequest doesn't parse JSON for us. request normally does, but\n    // we're setting opts.json=false so that it doesn't JSON-encode the\n    // request, which also means it doesn't JSON-decode the response. Either\n    // way, we have to JSON-parse the response ourselves.\n\n    let bodyParser = null;\n\n    if (!rawResponse) {\n      bodyParser = function (rawBody) {\n        let body = JSON.parse(rawBody);\n\n        if (onlyContentUri) {\n          body = body.content_uri;\n\n          if (body === undefined) {\n            throw Error('Bad response');\n          }\n        }\n\n        return body;\n      };\n    }\n\n    if (global.XMLHttpRequest) {\n      const defer = utils.defer();\n      const xhr = new global.XMLHttpRequest();\n      upload.xhr = xhr;\n      const cb = requestCallback(defer, opts.callback, this.opts.onlyData);\n\n      const timeout_fn = function () {\n        xhr.abort();\n        cb(new Error('Timeout'));\n      }; // set an initial timeout of 30s; we'll advance it each time we get\n      // a progress notification\n\n\n      xhr.timeout_timer = callbacks.setTimeout(timeout_fn, 30000);\n\n      xhr.onreadystatechange = function () {\n        switch (xhr.readyState) {\n          case global.XMLHttpRequest.DONE:\n            callbacks.clearTimeout(xhr.timeout_timer);\n            var resp;\n\n            try {\n              if (!xhr.responseText) {\n                throw new Error('No response body.');\n              }\n\n              resp = xhr.responseText;\n\n              if (bodyParser) {\n                resp = bodyParser(resp);\n              }\n            } catch (err) {\n              err.http_status = xhr.status;\n              cb(err);\n              return;\n            }\n\n            cb(undefined, xhr, resp);\n            break;\n        }\n      };\n\n      xhr.upload.addEventListener(\"progress\", function (ev) {\n        callbacks.clearTimeout(xhr.timeout_timer);\n        upload.loaded = ev.loaded;\n        upload.total = ev.total;\n        xhr.timeout_timer = callbacks.setTimeout(timeout_fn, 30000);\n\n        if (opts.progressHandler) {\n          opts.progressHandler({\n            loaded: ev.loaded,\n            total: ev.total\n          });\n        }\n      });\n      let url = this.opts.baseUrl + \"/_matrix/media/r0/upload\";\n      const queryArgs = [];\n\n      if (includeFilename && fileName) {\n        queryArgs.push(\"filename=\" + encodeURIComponent(fileName));\n      }\n\n      if (!this.useAuthorizationHeader) {\n        queryArgs.push(\"access_token=\" + encodeURIComponent(this.opts.accessToken));\n      }\n\n      if (queryArgs.length > 0) {\n        url += \"?\" + queryArgs.join(\"&\");\n      }\n\n      xhr.open(\"POST\", url);\n\n      if (this.useAuthorizationHeader) {\n        xhr.setRequestHeader(\"Authorization\", \"Bearer \" + this.opts.accessToken);\n      }\n\n      xhr.setRequestHeader(\"Content-Type\", contentType);\n      xhr.send(body);\n      promise = defer.promise; // dirty hack (as per _request) to allow the upload to be cancelled.\n\n      promise.abort = xhr.abort.bind(xhr);\n    } else {\n      const queryParams = {};\n\n      if (includeFilename && fileName) {\n        queryParams.filename = fileName;\n      }\n\n      promise = this.authedRequest(opts.callback, \"POST\", \"/upload\", queryParams, body, {\n        prefix: \"/_matrix/media/r0\",\n        headers: {\n          \"Content-Type\": contentType\n        },\n        json: false,\n        bodyParser: bodyParser\n      });\n    }\n\n    const self = this; // remove the upload from the list on completion\n\n    const promise0 = promise.finally(function () {\n      for (let i = 0; i < self.uploads.length; ++i) {\n        if (self.uploads[i] === upload) {\n          self.uploads.splice(i, 1);\n          return;\n        }\n      }\n    }); // copy our dirty abort() method to the new promise\n\n    promise0.abort = promise.abort;\n    upload.promise = promise0;\n    this.uploads.push(upload);\n    return promise0;\n  },\n  cancelUpload: function (promise) {\n    if (promise.abort) {\n      promise.abort();\n      return true;\n    }\n\n    return false;\n  },\n  getCurrentUploads: function () {\n    return this.uploads;\n  },\n  idServerRequest: function (callback, method, path, params, prefix, accessToken) {\n    if (!this.opts.idBaseUrl) {\n      throw new Error(\"No Identity Server base URL set\");\n    }\n\n    const fullUri = this.opts.idBaseUrl + prefix + path;\n\n    if (callback !== undefined && !utils.isFunction(callback)) {\n      throw Error(\"Expected callback to be a function but got \" + typeof callback);\n    }\n\n    const opts = {\n      uri: fullUri,\n      method: method,\n      withCredentials: false,\n      json: true,\n      // we want a JSON response if we can\n      _matrix_opts: this.opts,\n      headers: {}\n    };\n\n    if (method === 'GET') {\n      opts.qs = params;\n    } else if (typeof params === \"object\") {\n      opts.json = params;\n    }\n\n    if (accessToken) {\n      opts.headers['Authorization'] = `Bearer ${accessToken}`;\n    }\n\n    const defer = utils.defer();\n    this.opts.request(opts, requestCallback(defer, callback, this.opts.onlyData));\n    return defer.promise;\n  },\n\n  /**\n   * Perform an authorised request to the homeserver.\n   * @param {Function} callback Optional. The callback to invoke on\n   * success/failure. See the promise return values for more information.\n   * @param {string} method The HTTP method e.g. \"GET\".\n   * @param {string} path The HTTP path <b>after</b> the supplied prefix e.g.\n   * \"/createRoom\".\n   *\n   * @param {Object=} queryParams A dict of query params (these will NOT be\n   * urlencoded). If unspecified, there will be no query params.\n   *\n   * @param {Object} data The HTTP JSON body.\n   *\n   * @param {Object|Number=} opts additional options. If a number is specified,\n   * this is treated as `opts.localTimeoutMs`.\n   *\n   * @param {Number=} opts.localTimeoutMs The maximum amount of time to wait before\n   * timing out the request. If not specified, there is no timeout.\n   *\n   * @param {sting=} opts.prefix The full prefix to use e.g.\n   * \"/_matrix/client/v2_alpha\". If not specified, uses this.opts.prefix.\n   *\n   * @param {Object=} opts.headers map of additional request headers\n   *\n   * @return {module:client.Promise} Resolves to <code>{data: {Object},\n   * headers: {Object}, code: {Number}}</code>.\n   * If <code>onlyData</code> is set, this will resolve to the <code>data</code>\n   * object only.\n   * @return {module:http-api.MatrixError} Rejects with an error if a problem\n   * occurred. This includes network problems and Matrix-specific error JSON.\n   */\n  authedRequest: function (callback, method, path, queryParams, data, opts) {\n    if (!queryParams) {\n      queryParams = {};\n    }\n\n    if (this.useAuthorizationHeader) {\n      if (isFinite(opts)) {\n        // opts used to be localTimeoutMs\n        opts = {\n          localTimeoutMs: opts\n        };\n      }\n\n      if (!opts) {\n        opts = {};\n      }\n\n      if (!opts.headers) {\n        opts.headers = {};\n      }\n\n      if (!opts.headers.Authorization) {\n        opts.headers.Authorization = \"Bearer \" + this.opts.accessToken;\n      }\n\n      if (queryParams.access_token) {\n        delete queryParams.access_token;\n      }\n    } else {\n      if (!queryParams.access_token) {\n        queryParams.access_token = this.opts.accessToken;\n      }\n    }\n\n    const requestPromise = this.request(callback, method, path, queryParams, data, opts);\n    const self = this;\n    requestPromise.catch(function (err) {\n      if (err.errcode == 'M_UNKNOWN_TOKEN') {\n        self.event_emitter.emit(\"Session.logged_out\", err);\n      } else if (err.errcode == 'M_CONSENT_NOT_GIVEN') {\n        self.event_emitter.emit(\"no_consent\", err.message, err.data.consent_uri);\n      }\n    }); // return the original promise, otherwise tests break due to it having to\n    // go around the event loop one more time to process the result of the request\n\n    return requestPromise;\n  },\n\n  /**\n   * Perform a request to the homeserver without any credentials.\n   * @param {Function} callback Optional. The callback to invoke on\n   * success/failure. See the promise return values for more information.\n   * @param {string} method The HTTP method e.g. \"GET\".\n   * @param {string} path The HTTP path <b>after</b> the supplied prefix e.g.\n   * \"/createRoom\".\n   *\n   * @param {Object=} queryParams A dict of query params (these will NOT be\n   * urlencoded). If unspecified, there will be no query params.\n   *\n   * @param {Object} data The HTTP JSON body.\n   *\n   * @param {Object=} opts additional options\n   *\n   * @param {Number=} opts.localTimeoutMs The maximum amount of time to wait before\n   * timing out the request. If not specified, there is no timeout.\n   *\n   * @param {sting=} opts.prefix The full prefix to use e.g.\n   * \"/_matrix/client/v2_alpha\". If not specified, uses this.opts.prefix.\n   *\n   * @param {Object=} opts.headers map of additional request headers\n   *\n   * @return {module:client.Promise} Resolves to <code>{data: {Object},\n   * headers: {Object}, code: {Number}}</code>.\n   * If <code>onlyData</code> is set, this will resolve to the <code>data</code>\n   * object only.\n   * @return {module:http-api.MatrixError} Rejects with an error if a problem\n   * occurred. This includes network problems and Matrix-specific error JSON.\n   */\n  request: function (callback, method, path, queryParams, data, opts) {\n    opts = opts || {};\n    const prefix = opts.prefix !== undefined ? opts.prefix : this.opts.prefix;\n    const fullUri = this.opts.baseUrl + prefix + path;\n    return this.requestOtherUrl(callback, method, fullUri, queryParams, data, opts);\n  },\n\n  /**\n   * Perform a request to an arbitrary URL.\n   * @param {Function} callback Optional. The callback to invoke on\n   * success/failure. See the promise return values for more information.\n   * @param {string} method The HTTP method e.g. \"GET\".\n   * @param {string} uri The HTTP URI\n   *\n   * @param {Object=} queryParams A dict of query params (these will NOT be\n   * urlencoded). If unspecified, there will be no query params.\n   *\n   * @param {Object} data The HTTP JSON body.\n   *\n   * @param {Object=} opts additional options\n   *\n   * @param {Number=} opts.localTimeoutMs The maximum amount of time to wait before\n   * timing out the request. If not specified, there is no timeout.\n   *\n   * @param {sting=} opts.prefix The full prefix to use e.g.\n   * \"/_matrix/client/v2_alpha\". If not specified, uses this.opts.prefix.\n   *\n   * @param {Object=} opts.headers map of additional request headers\n   *\n   * @return {module:client.Promise} Resolves to <code>{data: {Object},\n   * headers: {Object}, code: {Number}}</code>.\n   * If <code>onlyData</code> is set, this will resolve to the <code>data</code>\n   * object only.\n   * @return {module:http-api.MatrixError} Rejects with an error if a problem\n   * occurred. This includes network problems and Matrix-specific error JSON.\n   */\n  requestOtherUrl: function (callback, method, uri, queryParams, data, opts) {\n    if (opts === undefined || opts === null) {\n      opts = {};\n    } else if (isFinite(opts)) {\n      // opts used to be localTimeoutMs\n      opts = {\n        localTimeoutMs: opts\n      };\n    }\n\n    return this._request(callback, method, uri, queryParams, data, opts);\n  },\n\n  /**\n   * Form and return a homeserver request URL based on the given path\n   * params and prefix.\n   * @param {string} path The HTTP path <b>after</b> the supplied prefix e.g.\n   * \"/createRoom\".\n   * @param {Object} queryParams A dict of query params (these will NOT be\n   * urlencoded).\n   * @param {string} prefix The full prefix to use e.g.\n   * \"/_matrix/client/v2_alpha\".\n   * @return {string} URL\n   */\n  getUrl: function (path, queryParams, prefix) {\n    let queryString = \"\";\n\n    if (queryParams) {\n      queryString = \"?\" + utils.encodeParams(queryParams);\n    }\n\n    return this.opts.baseUrl + prefix + path + queryString;\n  },\n\n  /**\n   * @private\n   *\n   * @param {function} callback\n   * @param {string} method\n   * @param {string} uri\n   * @param {object} queryParams\n   * @param {object|string} data\n   * @param {object=} opts\n   *\n   * @param {boolean} [opts.json =true] Json-encode data before sending, and\n   *   decode response on receipt. (We will still json-decode error\n   *   responses, even if this is false.)\n   *\n   * @param {object=} opts.headers  extra request headers\n   *\n   * @param {number=} opts.localTimeoutMs client-side timeout for the\n   *    request. Default timeout if falsy.\n   *\n   * @param {function=} opts.bodyParser function to parse the body of the\n   *    response before passing it to the promise and callback.\n   *\n   * @return {module:client.Promise} a promise which resolves to either the\n   * response object (if this.opts.onlyData is truthy), or the parsed\n   * body. Rejects\n   */\n  _request: function (callback, method, uri, queryParams, data, opts) {\n    if (callback !== undefined && !utils.isFunction(callback)) {\n      throw Error(\"Expected callback to be a function but got \" + typeof callback);\n    }\n\n    opts = opts || {};\n    const self = this;\n\n    if (this.opts.extraParams) {\n      for (const key in this.opts.extraParams) {\n        if (!this.opts.extraParams.hasOwnProperty(key)) {\n          continue;\n        }\n\n        queryParams[key] = this.opts.extraParams[key];\n      }\n    }\n\n    const headers = utils.extend({}, opts.headers || {});\n    const json = opts.json === undefined ? true : opts.json;\n    let bodyParser = opts.bodyParser; // we handle the json encoding/decoding here, because request and\n    // browser-request make a mess of it. Specifically, they attempt to\n    // json-decode plain-text error responses, which in turn means that the\n    // actual error gets swallowed by a SyntaxError.\n\n    if (json) {\n      if (data) {\n        data = JSON.stringify(data);\n        headers['content-type'] = 'application/json';\n      }\n\n      if (!headers['accept']) {\n        headers['accept'] = 'application/json';\n      }\n\n      if (bodyParser === undefined) {\n        bodyParser = function (rawBody) {\n          return JSON.parse(rawBody);\n        };\n      }\n    }\n\n    const defer = utils.defer();\n    let timeoutId;\n    let timedOut = false;\n    let req;\n    const localTimeoutMs = opts.localTimeoutMs || this.opts.localTimeoutMs;\n\n    const resetTimeout = () => {\n      if (localTimeoutMs) {\n        if (timeoutId) {\n          callbacks.clearTimeout(timeoutId);\n        }\n\n        timeoutId = callbacks.setTimeout(function () {\n          timedOut = true;\n\n          if (req && req.abort) {\n            req.abort();\n          }\n\n          defer.reject(new MatrixError({\n            error: \"Locally timed out waiting for a response\",\n            errcode: \"ORG.MATRIX.JSSDK_TIMEOUT\",\n            timeout: localTimeoutMs\n          }));\n        }, localTimeoutMs);\n      }\n    };\n\n    resetTimeout();\n    const reqPromise = defer.promise;\n\n    try {\n      req = this.opts.request({\n        uri: uri,\n        method: method,\n        withCredentials: false,\n        qs: queryParams,\n        qsStringifyOptions: opts.qsStringifyOptions,\n        useQuerystring: true,\n        body: data,\n        json: false,\n        timeout: localTimeoutMs,\n        headers: headers || {},\n        _matrix_opts: this.opts\n      }, function (err, response, body) {\n        if (localTimeoutMs) {\n          callbacks.clearTimeout(timeoutId);\n\n          if (timedOut) {\n            return; // already rejected promise\n          }\n        }\n\n        const handlerFn = requestCallback(defer, callback, self.opts.onlyData, bodyParser);\n        handlerFn(err, response, body);\n      });\n\n      if (req) {\n        // This will only work in a browser, where opts.request is the\n        // `browser-request` import. Currently `request` does not support progress\n        // updates - see https://github.com/request/request/pull/2346.\n        // `browser-request` returns an XHRHttpRequest which exposes `onprogress`\n        if ('onprogress' in req) {\n          req.onprogress = e => {\n            // Prevent the timeout from rejecting the deferred promise if progress is\n            // seen with the request\n            resetTimeout();\n          };\n        } // FIXME: This is EVIL, but I can't think of a better way to expose\n        // abort() operations on underlying HTTP requests :(\n\n\n        if (req.abort) reqPromise.abort = req.abort.bind(req);\n      }\n    } catch (ex) {\n      defer.reject(ex);\n\n      if (callback) {\n        callback(ex);\n      }\n    }\n\n    return reqPromise;\n  }\n};\n/*\n * Returns a callback that can be invoked by an HTTP request on completion,\n * that will either resolve or reject the given defer as well as invoke the\n * given userDefinedCallback (if any).\n *\n * HTTP errors are transformed into javascript errors and the deferred is rejected.\n *\n * If bodyParser is given, it is used to transform the body of the successful\n * responses before passing to the defer/callback.\n *\n * If onlyData is true, the defer/callback is invoked with the body of the\n * response, otherwise the result object (with `code` and `data` fields)\n *\n */\n\nconst requestCallback = function (defer, userDefinedCallback, onlyData, bodyParser) {\n  userDefinedCallback = userDefinedCallback || function () {};\n\n  return function (err, response, body) {\n    if (!err) {\n      try {\n        if (response.statusCode >= 400) {\n          err = parseErrorResponse(response, body);\n        } else if (bodyParser) {\n          body = bodyParser(body);\n        }\n      } catch (e) {\n        err = new Error(`Error parsing server response: ${e}`);\n      }\n    }\n\n    if (err) {\n      defer.reject(err);\n      userDefinedCallback(err);\n    } else {\n      const res = {\n        code: response.statusCode,\n        // XXX: why do we bother with this? it doesn't work for\n        // XMLHttpRequest, so clearly we don't use it.\n        headers: response.headers,\n        data: body\n      };\n      defer.resolve(onlyData ? body : res);\n      userDefinedCallback(null, onlyData ? body : res);\n    }\n  };\n};\n/**\n * Attempt to turn an HTTP error response into a Javascript Error.\n *\n * If it is a JSON response, we will parse it into a MatrixError. Otherwise\n * we return a generic Error.\n *\n * @param {XMLHttpRequest|http.IncomingMessage} response response object\n * @param {String} body raw body of the response\n * @returns {Error}\n */\n\n\nfunction parseErrorResponse(response, body) {\n  const httpStatus = response.statusCode;\n  const contentType = getResponseContentType(response);\n  let err;\n\n  if (contentType) {\n    if (contentType.type === 'application/json') {\n      const jsonBody = typeof body === 'object' ? body : JSON.parse(body);\n      err = new MatrixError(jsonBody);\n    } else if (contentType.type === 'text/plain') {\n      err = new Error(`Server returned ${httpStatus} error: ${body}`);\n    }\n  }\n\n  if (!err) {\n    err = new Error(`Server returned ${httpStatus} error`);\n  }\n\n  err.httpStatus = httpStatus;\n  return err;\n}\n/**\n * extract the Content-Type header from the response object, and\n * parse it to a `{type, parameters}` object.\n *\n * returns null if no content-type header could be found.\n *\n * @param {XMLHttpRequest|http.IncomingMessage} response response object\n * @returns {{type: String, parameters: Object}?} parsed content-type header, or null if not found\n */\n\n\nfunction getResponseContentType(response) {\n  let contentType;\n\n  if (response.getResponseHeader) {\n    // XMLHttpRequest provides getResponseHeader\n    contentType = response.getResponseHeader(\"Content-Type\");\n  } else if (response.headers) {\n    // request provides http.IncomingMessage which has a message.headers map\n    contentType = response.headers['content-type'] || null;\n  }\n\n  if (!contentType) {\n    return null;\n  }\n\n  try {\n    return (0, _contentType.parse)(contentType);\n  } catch (e) {\n    throw new Error(`Error parsing Content-Type '${contentType}': ${e}`);\n  }\n}\n/**\n * Construct a Matrix error. This is a JavaScript Error with additional\n * information specific to the standard Matrix error response.\n * @constructor\n * @param {Object} errorJson The Matrix error JSON returned from the homeserver.\n * @prop {string} errcode The Matrix 'errcode' value, e.g. \"M_FORBIDDEN\".\n * @prop {string} name Same as MatrixError.errcode but with a default unknown string.\n * @prop {string} message The Matrix 'error' value, e.g. \"Missing token.\"\n * @prop {Object} data The raw Matrix error JSON used to construct this object.\n * @prop {integer} httpStatus The numeric HTTP status code given\n */\n\n\nfunction MatrixError(errorJson) {\n  errorJson = errorJson || {};\n  this.errcode = errorJson.errcode;\n  this.name = errorJson.errcode || \"Unknown error code\";\n  this.message = errorJson.error || \"Unknown message\";\n  this.data = errorJson;\n}\n\nMatrixError.prototype = Object.create(Error.prototype);\nMatrixError.prototype.constructor = MatrixError;","map":{"version":3,"sources":["/home/kimist/Developpement/React/watcha_client/node_modules/matrix-js-sdk/lib/http-api.js"],"names":["_interopRequireWildcard","require","Object","defineProperty","exports","value","MatrixHttpApi","MatrixError","PREFIX_MEDIA_R0","PREFIX_IDENTITY_V2","PREFIX_IDENTITY_V1","PREFIX_UNSTABLE","PREFIX_R0","_contentType","utils","_logger","callbacks","event_emitter","opts","checkObjectHasKeys","onlyData","useAuthorizationHeader","Boolean","uploads","prototype","setIdBaseUrl","url","idBaseUrl","getContentUri","params","access_token","accessToken","base","baseUrl","path","uploadContent","file","isFunction","callback","undefined","includeFilename","contentType","type","fileName","name","body","stream","logger","warn","rawResponse","global","XMLHttpRequest","onlyContentUri","upload","loaded","total","promise","bodyParser","rawBody","JSON","parse","content_uri","Error","defer","xhr","cb","requestCallback","timeout_fn","abort","timeout_timer","setTimeout","onreadystatechange","readyState","DONE","clearTimeout","resp","responseText","err","http_status","status","addEventListener","ev","progressHandler","queryArgs","push","encodeURIComponent","length","join","open","setRequestHeader","send","bind","queryParams","filename","authedRequest","prefix","headers","json","self","promise0","finally","i","splice","cancelUpload","getCurrentUploads","idServerRequest","method","fullUri","uri","withCredentials","_matrix_opts","qs","request","data","isFinite","localTimeoutMs","Authorization","requestPromise","catch","errcode","emit","message","consent_uri","requestOtherUrl","_request","getUrl","queryString","encodeParams","extraParams","key","hasOwnProperty","extend","stringify","timeoutId","timedOut","req","resetTimeout","reject","error","timeout","reqPromise","qsStringifyOptions","useQuerystring","response","handlerFn","onprogress","e","ex","userDefinedCallback","statusCode","parseErrorResponse","res","code","resolve","httpStatus","getResponseContentType","jsonBody","getResponseHeader","errorJson","create","constructor"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MatrixHttpApi = MatrixHttpApi;\nexports.MatrixError = MatrixError;\nexports.PREFIX_MEDIA_R0 = exports.PREFIX_IDENTITY_V2 = exports.PREFIX_IDENTITY_V1 = exports.PREFIX_UNSTABLE = exports.PREFIX_R0 = void 0;\n\nvar _contentType = require(\"content-type\");\n\nvar utils = _interopRequireWildcard(require(\"./utils\"));\n\nvar _logger = require(\"./logger\");\n\nvar callbacks = _interopRequireWildcard(require(\"./realtime-callbacks\"));\n\n/*\nCopyright 2015, 2016 OpenMarket Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * This is an internal module. See {@link MatrixHttpApi} for the public class.\n * @module http-api\n */\n// we use our own implementation of setTimeout, so that if we get suspended in\n// the middle of a /sync, we cancel the sync as soon as we awake, rather than\n// waiting for the delay to elapse.\n\n/*\nTODO:\n- CS: complete register function (doing stages)\n- Identity server: linkEmail, authEmail, bindEmail, lookup3pid\n*/\n\n/**\n * A constant representing the URI path for release 0 of the Client-Server HTTP API.\n */\nconst PREFIX_R0 = \"/_matrix/client/r0\";\n/**\n * A constant representing the URI path for as-yet unspecified Client-Server HTTP APIs.\n */\n\nexports.PREFIX_R0 = PREFIX_R0;\nconst PREFIX_UNSTABLE = \"/_matrix/client/unstable\";\n/**\n * URI path for v1 of the the identity API\n */\n\nexports.PREFIX_UNSTABLE = PREFIX_UNSTABLE;\nconst PREFIX_IDENTITY_V1 = \"/_matrix/identity/api/v1\";\n/**\n * URI path for the v2 identity API\n */\n\nexports.PREFIX_IDENTITY_V1 = PREFIX_IDENTITY_V1;\nconst PREFIX_IDENTITY_V2 = \"/_matrix/identity/v2\";\n/**\n * URI path for the media repo API\n */\n\nexports.PREFIX_IDENTITY_V2 = PREFIX_IDENTITY_V2;\nconst PREFIX_MEDIA_R0 = \"/_matrix/media/r0\";\n/**\n * Construct a MatrixHttpApi.\n * @constructor\n * @param {EventEmitter} event_emitter The event emitter to use for emitting events\n * @param {Object} opts The options to use for this HTTP API.\n * @param {string} opts.baseUrl Required. The base client-server URL e.g.\n * 'http://localhost:8008'.\n * @param {Function} opts.request Required. The function to call for HTTP\n * requests. This function must look like function(opts, callback){ ... }.\n * @param {string} opts.prefix Required. The matrix client prefix to use, e.g.\n * '/_matrix/client/r0'. See PREFIX_R0 and PREFIX_UNSTABLE for constants.\n *\n * @param {boolean} opts.onlyData True to return only the 'data' component of the\n * response (e.g. the parsed HTTP body). If false, requests will return an\n * object with the properties <tt>code</tt>, <tt>headers</tt> and <tt>data</tt>.\n *\n * @param {string} opts.accessToken The access_token to send with requests. Can be\n * null to not send an access token.\n * @param {Object=} opts.extraParams Optional. Extra query parameters to send on\n * requests.\n * @param {Number=} opts.localTimeoutMs The default maximum amount of time to wait\n * before timing out the request. If not specified, there is no timeout.\n * @param {boolean} [opts.useAuthorizationHeader = false] Set to true to use\n * Authorization header instead of query param to send the access token to the server.\n */\n\nexports.PREFIX_MEDIA_R0 = PREFIX_MEDIA_R0;\n\nfunction MatrixHttpApi(event_emitter, opts) {\n  utils.checkObjectHasKeys(opts, [\"baseUrl\", \"request\", \"prefix\"]);\n  opts.onlyData = opts.onlyData || false;\n  this.event_emitter = event_emitter;\n  this.opts = opts;\n  this.useAuthorizationHeader = Boolean(opts.useAuthorizationHeader);\n  this.uploads = [];\n}\n\nMatrixHttpApi.prototype = {\n  /**\n   * Sets the baase URL for the identity server\n   * @param {string} url The new base url\n   */\n  setIdBaseUrl: function (url) {\n    this.opts.idBaseUrl = url;\n  },\n\n  /**\n   * Get the content repository url with query parameters.\n   * @return {Object} An object with a 'base', 'path' and 'params' for base URL,\n   *          path and query parameters respectively.\n   */\n  getContentUri: function () {\n    const params = {\n      access_token: this.opts.accessToken\n    };\n    return {\n      base: this.opts.baseUrl,\n      path: \"/_matrix/media/r0/upload\",\n      params: params\n    };\n  },\n\n  /**\n   * Upload content to the Home Server\n   *\n   * @param {object} file The object to upload. On a browser, something that\n   *   can be sent to XMLHttpRequest.send (typically a File).  Under node.js,\n   *   a Buffer, String or ReadStream.\n   *\n   * @param {object} opts  options object\n   *\n   * @param {string=} opts.name   Name to give the file on the server. Defaults\n   *   to <tt>file.name</tt>.\n   *\n   * @param {boolean=} opts.includeFilename if false will not send the filename,\n   *   e.g for encrypted file uploads where filename leaks are undesirable.\n   *   Defaults to true.\n   *\n   * @param {string=} opts.type   Content-type for the upload. Defaults to\n   *   <tt>file.type</tt>, or <tt>applicaton/octet-stream</tt>.\n   *\n   * @param {boolean=} opts.rawResponse Return the raw body, rather than\n   *   parsing the JSON. Defaults to false (except on node.js, where it\n   *   defaults to true for backwards compatibility).\n   *\n   * @param {boolean=} opts.onlyContentUri Just return the content URI,\n   *   rather than the whole body. Defaults to false (except on browsers,\n   *   where it defaults to true for backwards compatibility). Ignored if\n   *   opts.rawResponse is true.\n   *\n   * @param {Function=} opts.callback Deprecated. Optional. The callback to\n   *    invoke on success/failure. See the promise return values for more\n   *    information.\n   *\n   * @param {Function=} opts.progressHandler Optional. Called when a chunk of\n   *    data has been uploaded, with an object containing the fields `loaded`\n   *    (number of bytes transferred) and `total` (total size, if known).\n   *\n   * @return {module:client.Promise} Resolves to response object, as\n   *    determined by this.opts.onlyData, opts.rawResponse, and\n   *    opts.onlyContentUri.  Rejects with an error (usually a MatrixError).\n   */\n  uploadContent: function (file, opts) {\n    if (utils.isFunction(opts)) {\n      // opts used to be callback\n      opts = {\n        callback: opts\n      };\n    } else if (opts === undefined) {\n      opts = {};\n    } // default opts.includeFilename to true (ignoring falsey values)\n\n\n    const includeFilename = opts.includeFilename !== false; // if the file doesn't have a mime type, use a default since\n    // the HS errors if we don't supply one.\n\n    const contentType = opts.type || file.type || 'application/octet-stream';\n    const fileName = opts.name || file.name; // We used to recommend setting file.stream to the thing to upload on\n    // Node.js. As of 2019-06-11, this is still in widespread use in various\n    // clients, so we should preserve this for simple objects used in\n    // Node.js. File API objects (via either the File or Blob interfaces) in\n    // the browser now define a `stream` method, which leads to trouble\n    // here, so we also check the type of `stream`.\n\n    let body = file;\n\n    if (body.stream && typeof body.stream !== \"function\") {\n      _logger.logger.warn(\"Using `file.stream` as the content to upload. Future \" + \"versions of the js-sdk will change this to expect `file` to \" + \"be the content directly.\");\n\n      body = body.stream;\n    } // backwards-compatibility hacks where we used to do different things\n    // between browser and node.\n\n\n    let rawResponse = opts.rawResponse;\n\n    if (rawResponse === undefined) {\n      if (global.XMLHttpRequest) {\n        rawResponse = false;\n      } else {\n        _logger.logger.warn(\"Returning the raw JSON from uploadContent(). Future \" + \"versions of the js-sdk will change this default, to \" + \"return the parsed object. Set opts.rawResponse=false \" + \"to change this behaviour now.\");\n\n        rawResponse = true;\n      }\n    }\n\n    let onlyContentUri = opts.onlyContentUri;\n\n    if (!rawResponse && onlyContentUri === undefined) {\n      if (global.XMLHttpRequest) {\n        _logger.logger.warn(\"Returning only the content-uri from uploadContent(). \" + \"Future versions of the js-sdk will change this \" + \"default, to return the whole response object. Set \" + \"opts.onlyContentUri=false to change this behaviour now.\");\n\n        onlyContentUri = true;\n      } else {\n        onlyContentUri = false;\n      }\n    } // browser-request doesn't support File objects because it deep-copies\n    // the options using JSON.parse(JSON.stringify(options)). Instead of\n    // loading the whole file into memory as a string and letting\n    // browser-request base64 encode and then decode it again, we just\n    // use XMLHttpRequest directly.\n    // (browser-request doesn't support progress either, which is also kind\n    // of important here)\n\n\n    const upload = {\n      loaded: 0,\n      total: 0\n    };\n    let promise; // XMLHttpRequest doesn't parse JSON for us. request normally does, but\n    // we're setting opts.json=false so that it doesn't JSON-encode the\n    // request, which also means it doesn't JSON-decode the response. Either\n    // way, we have to JSON-parse the response ourselves.\n\n    let bodyParser = null;\n\n    if (!rawResponse) {\n      bodyParser = function (rawBody) {\n        let body = JSON.parse(rawBody);\n\n        if (onlyContentUri) {\n          body = body.content_uri;\n\n          if (body === undefined) {\n            throw Error('Bad response');\n          }\n        }\n\n        return body;\n      };\n    }\n\n    if (global.XMLHttpRequest) {\n      const defer = utils.defer();\n      const xhr = new global.XMLHttpRequest();\n      upload.xhr = xhr;\n      const cb = requestCallback(defer, opts.callback, this.opts.onlyData);\n\n      const timeout_fn = function () {\n        xhr.abort();\n        cb(new Error('Timeout'));\n      }; // set an initial timeout of 30s; we'll advance it each time we get\n      // a progress notification\n\n\n      xhr.timeout_timer = callbacks.setTimeout(timeout_fn, 30000);\n\n      xhr.onreadystatechange = function () {\n        switch (xhr.readyState) {\n          case global.XMLHttpRequest.DONE:\n            callbacks.clearTimeout(xhr.timeout_timer);\n            var resp;\n\n            try {\n              if (!xhr.responseText) {\n                throw new Error('No response body.');\n              }\n\n              resp = xhr.responseText;\n\n              if (bodyParser) {\n                resp = bodyParser(resp);\n              }\n            } catch (err) {\n              err.http_status = xhr.status;\n              cb(err);\n              return;\n            }\n\n            cb(undefined, xhr, resp);\n            break;\n        }\n      };\n\n      xhr.upload.addEventListener(\"progress\", function (ev) {\n        callbacks.clearTimeout(xhr.timeout_timer);\n        upload.loaded = ev.loaded;\n        upload.total = ev.total;\n        xhr.timeout_timer = callbacks.setTimeout(timeout_fn, 30000);\n\n        if (opts.progressHandler) {\n          opts.progressHandler({\n            loaded: ev.loaded,\n            total: ev.total\n          });\n        }\n      });\n      let url = this.opts.baseUrl + \"/_matrix/media/r0/upload\";\n      const queryArgs = [];\n\n      if (includeFilename && fileName) {\n        queryArgs.push(\"filename=\" + encodeURIComponent(fileName));\n      }\n\n      if (!this.useAuthorizationHeader) {\n        queryArgs.push(\"access_token=\" + encodeURIComponent(this.opts.accessToken));\n      }\n\n      if (queryArgs.length > 0) {\n        url += \"?\" + queryArgs.join(\"&\");\n      }\n\n      xhr.open(\"POST\", url);\n\n      if (this.useAuthorizationHeader) {\n        xhr.setRequestHeader(\"Authorization\", \"Bearer \" + this.opts.accessToken);\n      }\n\n      xhr.setRequestHeader(\"Content-Type\", contentType);\n      xhr.send(body);\n      promise = defer.promise; // dirty hack (as per _request) to allow the upload to be cancelled.\n\n      promise.abort = xhr.abort.bind(xhr);\n    } else {\n      const queryParams = {};\n\n      if (includeFilename && fileName) {\n        queryParams.filename = fileName;\n      }\n\n      promise = this.authedRequest(opts.callback, \"POST\", \"/upload\", queryParams, body, {\n        prefix: \"/_matrix/media/r0\",\n        headers: {\n          \"Content-Type\": contentType\n        },\n        json: false,\n        bodyParser: bodyParser\n      });\n    }\n\n    const self = this; // remove the upload from the list on completion\n\n    const promise0 = promise.finally(function () {\n      for (let i = 0; i < self.uploads.length; ++i) {\n        if (self.uploads[i] === upload) {\n          self.uploads.splice(i, 1);\n          return;\n        }\n      }\n    }); // copy our dirty abort() method to the new promise\n\n    promise0.abort = promise.abort;\n    upload.promise = promise0;\n    this.uploads.push(upload);\n    return promise0;\n  },\n  cancelUpload: function (promise) {\n    if (promise.abort) {\n      promise.abort();\n      return true;\n    }\n\n    return false;\n  },\n  getCurrentUploads: function () {\n    return this.uploads;\n  },\n  idServerRequest: function (callback, method, path, params, prefix, accessToken) {\n    if (!this.opts.idBaseUrl) {\n      throw new Error(\"No Identity Server base URL set\");\n    }\n\n    const fullUri = this.opts.idBaseUrl + prefix + path;\n\n    if (callback !== undefined && !utils.isFunction(callback)) {\n      throw Error(\"Expected callback to be a function but got \" + typeof callback);\n    }\n\n    const opts = {\n      uri: fullUri,\n      method: method,\n      withCredentials: false,\n      json: true,\n      // we want a JSON response if we can\n      _matrix_opts: this.opts,\n      headers: {}\n    };\n\n    if (method === 'GET') {\n      opts.qs = params;\n    } else if (typeof params === \"object\") {\n      opts.json = params;\n    }\n\n    if (accessToken) {\n      opts.headers['Authorization'] = `Bearer ${accessToken}`;\n    }\n\n    const defer = utils.defer();\n    this.opts.request(opts, requestCallback(defer, callback, this.opts.onlyData));\n    return defer.promise;\n  },\n\n  /**\n   * Perform an authorised request to the homeserver.\n   * @param {Function} callback Optional. The callback to invoke on\n   * success/failure. See the promise return values for more information.\n   * @param {string} method The HTTP method e.g. \"GET\".\n   * @param {string} path The HTTP path <b>after</b> the supplied prefix e.g.\n   * \"/createRoom\".\n   *\n   * @param {Object=} queryParams A dict of query params (these will NOT be\n   * urlencoded). If unspecified, there will be no query params.\n   *\n   * @param {Object} data The HTTP JSON body.\n   *\n   * @param {Object|Number=} opts additional options. If a number is specified,\n   * this is treated as `opts.localTimeoutMs`.\n   *\n   * @param {Number=} opts.localTimeoutMs The maximum amount of time to wait before\n   * timing out the request. If not specified, there is no timeout.\n   *\n   * @param {sting=} opts.prefix The full prefix to use e.g.\n   * \"/_matrix/client/v2_alpha\". If not specified, uses this.opts.prefix.\n   *\n   * @param {Object=} opts.headers map of additional request headers\n   *\n   * @return {module:client.Promise} Resolves to <code>{data: {Object},\n   * headers: {Object}, code: {Number}}</code>.\n   * If <code>onlyData</code> is set, this will resolve to the <code>data</code>\n   * object only.\n   * @return {module:http-api.MatrixError} Rejects with an error if a problem\n   * occurred. This includes network problems and Matrix-specific error JSON.\n   */\n  authedRequest: function (callback, method, path, queryParams, data, opts) {\n    if (!queryParams) {\n      queryParams = {};\n    }\n\n    if (this.useAuthorizationHeader) {\n      if (isFinite(opts)) {\n        // opts used to be localTimeoutMs\n        opts = {\n          localTimeoutMs: opts\n        };\n      }\n\n      if (!opts) {\n        opts = {};\n      }\n\n      if (!opts.headers) {\n        opts.headers = {};\n      }\n\n      if (!opts.headers.Authorization) {\n        opts.headers.Authorization = \"Bearer \" + this.opts.accessToken;\n      }\n\n      if (queryParams.access_token) {\n        delete queryParams.access_token;\n      }\n    } else {\n      if (!queryParams.access_token) {\n        queryParams.access_token = this.opts.accessToken;\n      }\n    }\n\n    const requestPromise = this.request(callback, method, path, queryParams, data, opts);\n    const self = this;\n    requestPromise.catch(function (err) {\n      if (err.errcode == 'M_UNKNOWN_TOKEN') {\n        self.event_emitter.emit(\"Session.logged_out\", err);\n      } else if (err.errcode == 'M_CONSENT_NOT_GIVEN') {\n        self.event_emitter.emit(\"no_consent\", err.message, err.data.consent_uri);\n      }\n    }); // return the original promise, otherwise tests break due to it having to\n    // go around the event loop one more time to process the result of the request\n\n    return requestPromise;\n  },\n\n  /**\n   * Perform a request to the homeserver without any credentials.\n   * @param {Function} callback Optional. The callback to invoke on\n   * success/failure. See the promise return values for more information.\n   * @param {string} method The HTTP method e.g. \"GET\".\n   * @param {string} path The HTTP path <b>after</b> the supplied prefix e.g.\n   * \"/createRoom\".\n   *\n   * @param {Object=} queryParams A dict of query params (these will NOT be\n   * urlencoded). If unspecified, there will be no query params.\n   *\n   * @param {Object} data The HTTP JSON body.\n   *\n   * @param {Object=} opts additional options\n   *\n   * @param {Number=} opts.localTimeoutMs The maximum amount of time to wait before\n   * timing out the request. If not specified, there is no timeout.\n   *\n   * @param {sting=} opts.prefix The full prefix to use e.g.\n   * \"/_matrix/client/v2_alpha\". If not specified, uses this.opts.prefix.\n   *\n   * @param {Object=} opts.headers map of additional request headers\n   *\n   * @return {module:client.Promise} Resolves to <code>{data: {Object},\n   * headers: {Object}, code: {Number}}</code>.\n   * If <code>onlyData</code> is set, this will resolve to the <code>data</code>\n   * object only.\n   * @return {module:http-api.MatrixError} Rejects with an error if a problem\n   * occurred. This includes network problems and Matrix-specific error JSON.\n   */\n  request: function (callback, method, path, queryParams, data, opts) {\n    opts = opts || {};\n    const prefix = opts.prefix !== undefined ? opts.prefix : this.opts.prefix;\n    const fullUri = this.opts.baseUrl + prefix + path;\n    return this.requestOtherUrl(callback, method, fullUri, queryParams, data, opts);\n  },\n\n  /**\n   * Perform a request to an arbitrary URL.\n   * @param {Function} callback Optional. The callback to invoke on\n   * success/failure. See the promise return values for more information.\n   * @param {string} method The HTTP method e.g. \"GET\".\n   * @param {string} uri The HTTP URI\n   *\n   * @param {Object=} queryParams A dict of query params (these will NOT be\n   * urlencoded). If unspecified, there will be no query params.\n   *\n   * @param {Object} data The HTTP JSON body.\n   *\n   * @param {Object=} opts additional options\n   *\n   * @param {Number=} opts.localTimeoutMs The maximum amount of time to wait before\n   * timing out the request. If not specified, there is no timeout.\n   *\n   * @param {sting=} opts.prefix The full prefix to use e.g.\n   * \"/_matrix/client/v2_alpha\". If not specified, uses this.opts.prefix.\n   *\n   * @param {Object=} opts.headers map of additional request headers\n   *\n   * @return {module:client.Promise} Resolves to <code>{data: {Object},\n   * headers: {Object}, code: {Number}}</code>.\n   * If <code>onlyData</code> is set, this will resolve to the <code>data</code>\n   * object only.\n   * @return {module:http-api.MatrixError} Rejects with an error if a problem\n   * occurred. This includes network problems and Matrix-specific error JSON.\n   */\n  requestOtherUrl: function (callback, method, uri, queryParams, data, opts) {\n    if (opts === undefined || opts === null) {\n      opts = {};\n    } else if (isFinite(opts)) {\n      // opts used to be localTimeoutMs\n      opts = {\n        localTimeoutMs: opts\n      };\n    }\n\n    return this._request(callback, method, uri, queryParams, data, opts);\n  },\n\n  /**\n   * Form and return a homeserver request URL based on the given path\n   * params and prefix.\n   * @param {string} path The HTTP path <b>after</b> the supplied prefix e.g.\n   * \"/createRoom\".\n   * @param {Object} queryParams A dict of query params (these will NOT be\n   * urlencoded).\n   * @param {string} prefix The full prefix to use e.g.\n   * \"/_matrix/client/v2_alpha\".\n   * @return {string} URL\n   */\n  getUrl: function (path, queryParams, prefix) {\n    let queryString = \"\";\n\n    if (queryParams) {\n      queryString = \"?\" + utils.encodeParams(queryParams);\n    }\n\n    return this.opts.baseUrl + prefix + path + queryString;\n  },\n\n  /**\n   * @private\n   *\n   * @param {function} callback\n   * @param {string} method\n   * @param {string} uri\n   * @param {object} queryParams\n   * @param {object|string} data\n   * @param {object=} opts\n   *\n   * @param {boolean} [opts.json =true] Json-encode data before sending, and\n   *   decode response on receipt. (We will still json-decode error\n   *   responses, even if this is false.)\n   *\n   * @param {object=} opts.headers  extra request headers\n   *\n   * @param {number=} opts.localTimeoutMs client-side timeout for the\n   *    request. Default timeout if falsy.\n   *\n   * @param {function=} opts.bodyParser function to parse the body of the\n   *    response before passing it to the promise and callback.\n   *\n   * @return {module:client.Promise} a promise which resolves to either the\n   * response object (if this.opts.onlyData is truthy), or the parsed\n   * body. Rejects\n   */\n  _request: function (callback, method, uri, queryParams, data, opts) {\n    if (callback !== undefined && !utils.isFunction(callback)) {\n      throw Error(\"Expected callback to be a function but got \" + typeof callback);\n    }\n\n    opts = opts || {};\n    const self = this;\n\n    if (this.opts.extraParams) {\n      for (const key in this.opts.extraParams) {\n        if (!this.opts.extraParams.hasOwnProperty(key)) {\n          continue;\n        }\n\n        queryParams[key] = this.opts.extraParams[key];\n      }\n    }\n\n    const headers = utils.extend({}, opts.headers || {});\n    const json = opts.json === undefined ? true : opts.json;\n    let bodyParser = opts.bodyParser; // we handle the json encoding/decoding here, because request and\n    // browser-request make a mess of it. Specifically, they attempt to\n    // json-decode plain-text error responses, which in turn means that the\n    // actual error gets swallowed by a SyntaxError.\n\n    if (json) {\n      if (data) {\n        data = JSON.stringify(data);\n        headers['content-type'] = 'application/json';\n      }\n\n      if (!headers['accept']) {\n        headers['accept'] = 'application/json';\n      }\n\n      if (bodyParser === undefined) {\n        bodyParser = function (rawBody) {\n          return JSON.parse(rawBody);\n        };\n      }\n    }\n\n    const defer = utils.defer();\n    let timeoutId;\n    let timedOut = false;\n    let req;\n    const localTimeoutMs = opts.localTimeoutMs || this.opts.localTimeoutMs;\n\n    const resetTimeout = () => {\n      if (localTimeoutMs) {\n        if (timeoutId) {\n          callbacks.clearTimeout(timeoutId);\n        }\n\n        timeoutId = callbacks.setTimeout(function () {\n          timedOut = true;\n\n          if (req && req.abort) {\n            req.abort();\n          }\n\n          defer.reject(new MatrixError({\n            error: \"Locally timed out waiting for a response\",\n            errcode: \"ORG.MATRIX.JSSDK_TIMEOUT\",\n            timeout: localTimeoutMs\n          }));\n        }, localTimeoutMs);\n      }\n    };\n\n    resetTimeout();\n    const reqPromise = defer.promise;\n\n    try {\n      req = this.opts.request({\n        uri: uri,\n        method: method,\n        withCredentials: false,\n        qs: queryParams,\n        qsStringifyOptions: opts.qsStringifyOptions,\n        useQuerystring: true,\n        body: data,\n        json: false,\n        timeout: localTimeoutMs,\n        headers: headers || {},\n        _matrix_opts: this.opts\n      }, function (err, response, body) {\n        if (localTimeoutMs) {\n          callbacks.clearTimeout(timeoutId);\n\n          if (timedOut) {\n            return; // already rejected promise\n          }\n        }\n\n        const handlerFn = requestCallback(defer, callback, self.opts.onlyData, bodyParser);\n        handlerFn(err, response, body);\n      });\n\n      if (req) {\n        // This will only work in a browser, where opts.request is the\n        // `browser-request` import. Currently `request` does not support progress\n        // updates - see https://github.com/request/request/pull/2346.\n        // `browser-request` returns an XHRHttpRequest which exposes `onprogress`\n        if ('onprogress' in req) {\n          req.onprogress = e => {\n            // Prevent the timeout from rejecting the deferred promise if progress is\n            // seen with the request\n            resetTimeout();\n          };\n        } // FIXME: This is EVIL, but I can't think of a better way to expose\n        // abort() operations on underlying HTTP requests :(\n\n\n        if (req.abort) reqPromise.abort = req.abort.bind(req);\n      }\n    } catch (ex) {\n      defer.reject(ex);\n\n      if (callback) {\n        callback(ex);\n      }\n    }\n\n    return reqPromise;\n  }\n};\n/*\n * Returns a callback that can be invoked by an HTTP request on completion,\n * that will either resolve or reject the given defer as well as invoke the\n * given userDefinedCallback (if any).\n *\n * HTTP errors are transformed into javascript errors and the deferred is rejected.\n *\n * If bodyParser is given, it is used to transform the body of the successful\n * responses before passing to the defer/callback.\n *\n * If onlyData is true, the defer/callback is invoked with the body of the\n * response, otherwise the result object (with `code` and `data` fields)\n *\n */\n\nconst requestCallback = function (defer, userDefinedCallback, onlyData, bodyParser) {\n  userDefinedCallback = userDefinedCallback || function () {};\n\n  return function (err, response, body) {\n    if (!err) {\n      try {\n        if (response.statusCode >= 400) {\n          err = parseErrorResponse(response, body);\n        } else if (bodyParser) {\n          body = bodyParser(body);\n        }\n      } catch (e) {\n        err = new Error(`Error parsing server response: ${e}`);\n      }\n    }\n\n    if (err) {\n      defer.reject(err);\n      userDefinedCallback(err);\n    } else {\n      const res = {\n        code: response.statusCode,\n        // XXX: why do we bother with this? it doesn't work for\n        // XMLHttpRequest, so clearly we don't use it.\n        headers: response.headers,\n        data: body\n      };\n      defer.resolve(onlyData ? body : res);\n      userDefinedCallback(null, onlyData ? body : res);\n    }\n  };\n};\n/**\n * Attempt to turn an HTTP error response into a Javascript Error.\n *\n * If it is a JSON response, we will parse it into a MatrixError. Otherwise\n * we return a generic Error.\n *\n * @param {XMLHttpRequest|http.IncomingMessage} response response object\n * @param {String} body raw body of the response\n * @returns {Error}\n */\n\n\nfunction parseErrorResponse(response, body) {\n  const httpStatus = response.statusCode;\n  const contentType = getResponseContentType(response);\n  let err;\n\n  if (contentType) {\n    if (contentType.type === 'application/json') {\n      const jsonBody = typeof body === 'object' ? body : JSON.parse(body);\n      err = new MatrixError(jsonBody);\n    } else if (contentType.type === 'text/plain') {\n      err = new Error(`Server returned ${httpStatus} error: ${body}`);\n    }\n  }\n\n  if (!err) {\n    err = new Error(`Server returned ${httpStatus} error`);\n  }\n\n  err.httpStatus = httpStatus;\n  return err;\n}\n/**\n * extract the Content-Type header from the response object, and\n * parse it to a `{type, parameters}` object.\n *\n * returns null if no content-type header could be found.\n *\n * @param {XMLHttpRequest|http.IncomingMessage} response response object\n * @returns {{type: String, parameters: Object}?} parsed content-type header, or null if not found\n */\n\n\nfunction getResponseContentType(response) {\n  let contentType;\n\n  if (response.getResponseHeader) {\n    // XMLHttpRequest provides getResponseHeader\n    contentType = response.getResponseHeader(\"Content-Type\");\n  } else if (response.headers) {\n    // request provides http.IncomingMessage which has a message.headers map\n    contentType = response.headers['content-type'] || null;\n  }\n\n  if (!contentType) {\n    return null;\n  }\n\n  try {\n    return (0, _contentType.parse)(contentType);\n  } catch (e) {\n    throw new Error(`Error parsing Content-Type '${contentType}': ${e}`);\n  }\n}\n/**\n * Construct a Matrix error. This is a JavaScript Error with additional\n * information specific to the standard Matrix error response.\n * @constructor\n * @param {Object} errorJson The Matrix error JSON returned from the homeserver.\n * @prop {string} errcode The Matrix 'errcode' value, e.g. \"M_FORBIDDEN\".\n * @prop {string} name Same as MatrixError.errcode but with a default unknown string.\n * @prop {string} message The Matrix 'error' value, e.g. \"Missing token.\"\n * @prop {Object} data The raw Matrix error JSON used to construct this object.\n * @prop {integer} httpStatus The numeric HTTP status code given\n */\n\n\nfunction MatrixError(errorJson) {\n  errorJson = errorJson || {};\n  this.errcode = errorJson.errcode;\n  this.name = errorJson.errcode || \"Unknown error code\";\n  this.message = errorJson.error || \"Unknown message\";\n  this.data = errorJson;\n}\n\nMatrixError.prototype = Object.create(Error.prototype);\nMatrixError.prototype.constructor = MatrixError;"]},"metadata":{},"sourceType":"script"}