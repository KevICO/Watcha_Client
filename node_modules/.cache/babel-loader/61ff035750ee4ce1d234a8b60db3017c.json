{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SecretStorage = exports.SECRET_STORAGE_ALGORITHM_V1 = void 0;\n\nvar _events = require(\"events\");\n\nvar _logger = require(\"../logger\");\n\nvar olmlib = _interopRequireWildcard(require(\"./olmlib\"));\n\nvar _randomstring = require(\"../randomstring\");\n/*\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\nconst SECRET_STORAGE_ALGORITHM_V1 = \"m.secret_storage.v1.curve25519-aes-sha2\";\n/**\n * Implements Secure Secret Storage and Sharing (MSC1946)\n * @module crypto/SecretStorage\n */\n\nexports.SECRET_STORAGE_ALGORITHM_V1 = SECRET_STORAGE_ALGORITHM_V1;\n\nclass SecretStorage extends _events.EventEmitter {\n  constructor(baseApis, cryptoCallbacks, crossSigningInfo) {\n    super();\n    this._baseApis = baseApis;\n    this._cryptoCallbacks = cryptoCallbacks;\n    this._crossSigningInfo = crossSigningInfo;\n    this._requests = {};\n    this._incomingRequests = {};\n  }\n\n  async getDefaultKeyId() {\n    const defaultKey = await this._baseApis.getAccountDataFromServer('m.secret_storage.default_key');\n    if (!defaultKey) return null;\n    return defaultKey.key;\n  }\n\n  setDefaultKeyId(keyId) {\n    return new Promise(resolve => {\n      const listener = ev => {\n        if (ev.getType() === 'm.secret_storage.default_key' && ev.getContent().key === keyId) {\n          this._baseApis.removeListener('accountData', listener);\n\n          resolve();\n        }\n      };\n\n      this._baseApis.on('accountData', listener);\n\n      this._baseApis.setAccountData('m.secret_storage.default_key', {\n        key: keyId\n      });\n    });\n  }\n  /**\n   * Add a key for encrypting secrets.\n   *\n   * @param {string} algorithm the algorithm used by the key.\n   * @param {object} opts the options for the algorithm.  The properties used\n   *     depend on the algorithm given.\n   * @param {string} [keyId] the ID of the key.  If not given, a random\n   *     ID will be generated.\n   *\n   * @return {string} the ID of the key\n   */\n\n\n  async addKey(algorithm, opts, keyId) {\n    const keyData = {\n      algorithm\n    };\n    if (!opts) opts = {};\n\n    if (opts.name) {\n      keyData.name = opts.name;\n    }\n\n    switch (algorithm) {\n      case SECRET_STORAGE_ALGORITHM_V1:\n        {\n          const decryption = new global.Olm.PkDecryption();\n\n          try {\n            const {\n              passphrase,\n              pubkey\n            } = opts; // Copies in public key details of the form generated by\n            // the Crypto module's `createRecoveryKeyFromPassphrase`.\n\n            if (passphrase && pubkey) {\n              keyData.passphrase = passphrase;\n              keyData.pubkey = pubkey;\n            } else if (pubkey) {\n              keyData.pubkey = pubkey;\n            } else {\n              keyData.pubkey = decryption.generate_key();\n            }\n          } finally {\n            decryption.free();\n          }\n\n          break;\n        }\n\n      default:\n        throw new Error(`Unknown key algorithm ${opts.algorithm}`);\n    }\n\n    if (!keyId) {\n      do {\n        keyId = (0, _randomstring.randomString)(32);\n      } while (await this._baseApis.getAccountDataFromServer(`m.secret_storage.key.${keyId}`));\n    }\n\n    await this._crossSigningInfo.signObject(keyData, 'master');\n    await this._baseApis.setAccountData(`m.secret_storage.key.${keyId}`, keyData);\n    return keyId;\n  }\n  /**\n   * Signs a given secret storage key with the cross-signing master key.\n   *\n   * @param {string} [keyId = default key's ID] The ID of the key to sign.\n   *     Defaults to the default key ID if not provided.\n   */\n\n\n  async signKey(keyId) {\n    if (!keyId) {\n      keyId = await this.getDefaultKeyId();\n    }\n\n    if (!keyId) {\n      throw new Error(\"signKey requires a key ID\");\n    }\n\n    const keyInfo = await this._baseApis.getAccountDataFromServer(`m.secret_storage.key.${keyId}`);\n\n    if (!keyInfo) {\n      throw new Error(`Key ${keyId} does not exist in account data`);\n    }\n\n    await this._crossSigningInfo.signObject(keyInfo, 'master');\n    await this._baseApis.setAccountData(`m.secret_storage.key.${keyId}`, keyInfo);\n  }\n  /**\n   * Check whether we have a key with a given ID.\n   *\n   * @param {string} [keyId = default key's ID] The ID of the key to check\n   *     for. Defaults to the default key ID if not provided.\n   * @return {boolean} Whether we have the key.\n   */\n\n\n  async hasKey(keyId) {\n    if (!keyId) {\n      keyId = await this.getDefaultKeyId();\n    }\n\n    if (!keyId) {\n      return false;\n    }\n\n    return !!this._baseApis.getAccountDataFromServer(\"m.secret_storage.key.\" + keyId);\n  }\n  /**\n   * Store an encrypted secret on the server\n   *\n   * @param {string} name The name of the secret\n   * @param {string} secret The secret contents.\n   * @param {Array} keys The IDs of the keys to use to encrypt the secret\n   *     or null/undefined to use the default key.\n   */\n\n\n  async store(name, secret, keys) {\n    const encrypted = {};\n\n    if (!keys) {\n      const defaultKeyId = await this.getDefaultKeyId();\n\n      if (!defaultKeyId) {\n        throw new Error(\"No keys specified and no default key present\");\n      }\n\n      keys = [defaultKeyId];\n    }\n\n    if (keys.length === 0) {\n      throw new Error(\"Zero keys given to encrypt with!\");\n    }\n\n    for (const keyId of keys) {\n      // get key information from key storage\n      const keyInfo = await this._baseApis.getAccountDataFromServer(\"m.secret_storage.key.\" + keyId);\n\n      if (!keyInfo) {\n        throw new Error(\"Unknown key: \" + keyId);\n      } // check signature of key info\n\n\n      (0, olmlib.pkVerify)(keyInfo, this._crossSigningInfo.getId('master'), this._crossSigningInfo.userId); // encrypt secret, based on the algorithm\n\n      switch (keyInfo.algorithm) {\n        case SECRET_STORAGE_ALGORITHM_V1:\n          {\n            const encryption = new global.Olm.PkEncryption();\n\n            try {\n              encryption.set_recipient_key(keyInfo.pubkey);\n              encrypted[keyId] = encryption.encrypt(secret);\n            } finally {\n              encryption.free();\n            }\n\n            break;\n          }\n\n        default:\n          _logger.logger.warn(\"unknown algorithm for secret storage key \" + keyId + \": \" + keyInfo.algorithm);\n\n        // do nothing if we don't understand the encryption algorithm\n      }\n    } // save encrypted secret\n\n\n    await this._baseApis.setAccountData(name, {\n      encrypted\n    });\n  }\n  /**\n   * Store a secret defined to be the same as the given key.\n   * No secret information will be stored, instead the secret will\n   * be stored with a marker to say that the contents of the secret is\n   * the value of the given key.\n   * This is useful for migration from systems that predate SSSS such as\n   * key backup.\n   *\n   * @param {string} name The name of the secret\n   * @param {string} keyId The ID of the key whose value will be the\n   *     value of the secret\n   * @returns {Promise} resolved when account data is saved\n   */\n\n\n  storePassthrough(name, keyId) {\n    return this._baseApis.setAccountData(name, {\n      [keyId]: {\n        passthrough: true\n      }\n    });\n  }\n  /**\n   * Get a secret from storage.\n   *\n   * @param {string} name the name of the secret\n   *\n   * @return {string} the contents of the secret\n   */\n\n\n  async get(name) {\n    const secretInfo = await this._baseApis.getAccountDataFromServer(name);\n\n    if (!secretInfo) {\n      return;\n    }\n\n    if (!secretInfo.encrypted) {\n      throw new Error(\"Content is not encrypted!\");\n    } // get possible keys to decrypt\n\n\n    const keys = {};\n\n    for (const keyId of Object.keys(secretInfo.encrypted)) {\n      // get key information from key storage\n      const keyInfo = await this._baseApis.getAccountDataFromServer(\"m.secret_storage.key.\" + keyId);\n      const encInfo = secretInfo.encrypted[keyId];\n\n      switch (keyInfo.algorithm) {\n        case SECRET_STORAGE_ALGORITHM_V1:\n          if (keyInfo.pubkey && encInfo.ciphertext && encInfo.mac && encInfo.ephemeral) {\n            keys[keyId] = keyInfo;\n          }\n\n          break;\n\n        default: // do nothing if we don't understand the encryption algorithm\n\n      }\n    }\n\n    let keyId;\n    let decryption;\n\n    try {\n      // fetch private key from app\n      [keyId, decryption] = await this._getSecretStorageKey(keys);\n      const encInfo = secretInfo.encrypted[keyId]; // We don't actually need the decryption object if it's a passthrough\n      // since we just want to return the key itself.\n\n      if (encInfo.passthrough) return decryption.get_private_key(); // decrypt secret\n\n      switch (keys[keyId].algorithm) {\n        case SECRET_STORAGE_ALGORITHM_V1:\n          return decryption.decrypt(encInfo.ephemeral, encInfo.mac, encInfo.ciphertext);\n      }\n    } finally {\n      if (decryption) decryption.free();\n    }\n  }\n  /**\n   * Check if a secret is stored on the server.\n   *\n   * @param {string} name the name of the secret\n   * @param {boolean} checkKey check if the secret is encrypted by a trusted key\n   *\n   * @return {boolean} whether or not the secret is stored\n   */\n\n\n  async isStored(name, checkKey) {\n    // check if secret exists\n    const secretInfo = await this._baseApis.getAccountDataFromServer(name);\n\n    if (!secretInfo || !secretInfo.encrypted) {\n      return false;\n    }\n\n    if (checkKey === undefined) checkKey = true; // check if secret is encrypted by a known/trusted secret and\n    // encryption looks sane\n\n    for (const keyId of Object.keys(secretInfo.encrypted)) {\n      // get key information from key storage\n      const keyInfo = await this._baseApis.getAccountDataFromServer(\"m.secret_storage.key.\" + keyId);\n      if (!keyInfo) return false;\n      const encInfo = secretInfo.encrypted[keyId];\n\n      if (checkKey) {\n        (0, olmlib.pkVerify)(keyInfo, this._crossSigningInfo.getId('master'), this._crossSigningInfo.userId);\n      }\n\n      switch (keyInfo.algorithm) {\n        case SECRET_STORAGE_ALGORITHM_V1:\n          if (keyInfo.pubkey && encInfo.ciphertext && encInfo.mac && encInfo.ephemeral) {\n            return true;\n          }\n\n          break;\n\n        default: // do nothing if we don't understand the encryption algorithm\n\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Request a secret from another device\n   *\n   * @param {string} name the name of the secret to request\n   * @param {string[]} devices the devices to request the secret from\n   *\n   * @return {string} the contents of the secret\n   */\n\n\n  request(name, devices) {\n    const requestId = this._baseApis.makeTxnId();\n\n    const requestControl = this._requests[requestId] = {\n      devices\n    };\n    const promise = new Promise((resolve, reject) => {\n      requestControl.resolve = resolve;\n      requestControl.reject = reject;\n    });\n\n    const cancel = reason => {\n      // send cancellation event\n      const cancelData = {\n        action: \"request_cancellation\",\n        requesting_device_id: this._baseApis.deviceId,\n        request_id: requestId\n      };\n      const toDevice = {};\n\n      for (const device of devices) {\n        toDevice[device] = cancelData;\n      }\n\n      this._baseApis.sendToDevice(\"m.secret.request\", {\n        [this._baseApis.getUserId()]: toDevice\n      }); // and reject the promise so that anyone waiting on it will be\n      // notified\n\n\n      requestControl.reject(new Error(reason || \"Cancelled\"));\n    }; // send request to devices\n\n\n    const requestData = {\n      name,\n      action: \"request\",\n      requesting_device_id: this._baseApis.deviceId,\n      request_id: requestId\n    };\n    const toDevice = {};\n\n    for (const device of devices) {\n      toDevice[device] = requestData;\n    }\n\n    this._baseApis.sendToDevice(\"m.secret.request\", {\n      [this._baseApis.getUserId()]: toDevice\n    });\n\n    return {\n      request_id: requestId,\n      promise,\n      cancel\n    };\n  }\n\n  async _onRequestReceived(event) {\n    const sender = event.getSender();\n    const content = event.getContent();\n\n    if (sender !== this._baseApis.getUserId() || !(content.name && content.action && content.requesting_device_id && content.request_id)) {\n      // ignore requests from anyone else, for now\n      return;\n    }\n\n    const deviceId = content.requesting_device_id; // check if it's a cancel\n\n    if (content.action === \"request_cancellation\") {\n      if (this._incomingRequests[deviceId] && this._incomingRequests[deviceId][content.request_id]) {\n        _logger.logger.info(\"received request cancellation for secret (\" + sender + \", \" + deviceId + \", \" + content.request_id + \")\");\n\n        this.baseApis.emit(\"crypto.secrets.requestCancelled\", {\n          user_id: sender,\n          device_id: deviceId,\n          request_id: content.request_id\n        });\n      }\n    } else if (content.action === \"request\") {\n      if (deviceId === this._baseApis.deviceId) {\n        // no point in trying to send ourself the secret\n        return;\n      } // check if we have the secret\n\n\n      _logger.logger.info(\"received request for secret (\" + sender + \", \" + deviceId + \", \" + content.request_id + \")\");\n\n      if (!this._cryptoCallbacks.onSecretRequested) {\n        return;\n      }\n\n      const secret = await this._cryptoCallbacks.onSecretRequested({\n        user_id: sender,\n        device_id: deviceId,\n        request_id: content.request_id,\n        name: content.name,\n        device_trust: this._baseApis.checkDeviceTrust(sender, deviceId)\n      });\n\n      if (secret) {\n        const payload = {\n          type: \"m.secret.send\",\n          content: {\n            request_id: content.request_id,\n            secret: secret\n          }\n        };\n        const encryptedContent = {\n          algorithm: olmlib.OLM_ALGORITHM,\n          sender_key: this._baseApis._crypto._olmDevice.deviceCurve25519Key,\n          ciphertext: {}\n        };\n        await olmlib.ensureOlmSessionsForDevices(this._baseApis._crypto._olmDevice, this._baseApis, {\n          [sender]: [await this._baseApis.getStoredDevice(sender, deviceId)]\n        });\n        await olmlib.encryptMessageForDevice(encryptedContent.ciphertext, this._baseApis.getUserId(), this._baseApis.deviceId, this._baseApis._crypto._olmDevice, sender, this._baseApis._crypto.getStoredDevice(sender, deviceId), payload);\n        const contentMap = {\n          [sender]: {\n            [deviceId]: encryptedContent\n          }\n        };\n\n        this._baseApis.sendToDevice(\"m.room.encrypted\", contentMap);\n      }\n    }\n  }\n\n  _onSecretReceived(event) {\n    if (event.getSender() !== this._baseApis.getUserId()) {\n      // we shouldn't be receiving secrets from anyone else, so ignore\n      // because someone could be trying to send us bogus data\n      return;\n    }\n\n    const content = event.getContent();\n\n    _logger.logger.log(\"got secret share for request \", content.request_id);\n\n    const requestControl = this._requests[content.request_id];\n\n    if (requestControl) {\n      // make sure that the device that sent it is one of the devices that\n      // we requested from\n      const deviceInfo = this._baseApis._crypto._deviceList.getDeviceByIdentityKey(olmlib.OLM_ALGORITHM, event.getSenderKey());\n\n      if (!deviceInfo) {\n        _logger.logger.log(\"secret share from unknown device with key\", event.getSenderKey());\n\n        return;\n      }\n\n      if (!requestControl.devices.includes(deviceInfo.deviceId)) {\n        _logger.logger.log(\"unsolicited secret share from device\", deviceInfo.deviceId);\n\n        return;\n      }\n\n      requestControl.resolve(content.secret);\n    }\n  }\n\n  async _getSecretStorageKey(keys) {\n    if (!this._cryptoCallbacks.getSecretStorageKey) {\n      throw new Error(\"No getSecretStorageKey callback supplied\");\n    }\n\n    const returned = await this._cryptoCallbacks.getSecretStorageKey({\n      keys\n    });\n\n    if (!returned) {\n      throw new Error(\"getSecretStorageKey callback returned falsey\");\n    }\n\n    if (returned.length < 2) {\n      throw new Error(\"getSecretStorageKey callback returned invalid data\");\n    }\n\n    const [keyId, privateKey] = returned;\n\n    if (!keys[keyId]) {\n      throw new Error(\"App returned unknown key from getSecretStorageKey!\");\n    }\n\n    switch (keys[keyId].algorithm) {\n      case SECRET_STORAGE_ALGORITHM_V1:\n        {\n          const decryption = new global.Olm.PkDecryption();\n          let pubkey;\n\n          try {\n            pubkey = decryption.init_with_private_key(privateKey);\n          } catch (e) {\n            decryption.free();\n            throw new Error(\"getSecretStorageKey callback returned invalid key\");\n          }\n\n          if (pubkey !== keys[keyId].pubkey) {\n            decryption.free();\n            throw new Error(\"getSecretStorageKey callback returned incorrect key\");\n          }\n\n          return [keyId, decryption];\n        }\n\n      default:\n        throw new Error(\"Unknown key type: \" + keys[keyId].algorithm);\n    }\n  }\n\n}\n\nexports.SecretStorage = SecretStorage;","map":{"version":3,"sources":["/home/kimist/Developpement/React/watcha_client/node_modules/matrix-js-sdk/lib/crypto/SecretStorage.js"],"names":["_interopRequireWildcard","require","Object","defineProperty","exports","value","SecretStorage","SECRET_STORAGE_ALGORITHM_V1","_events","_logger","olmlib","_randomstring","EventEmitter","constructor","baseApis","cryptoCallbacks","crossSigningInfo","_baseApis","_cryptoCallbacks","_crossSigningInfo","_requests","_incomingRequests","getDefaultKeyId","defaultKey","getAccountDataFromServer","key","setDefaultKeyId","keyId","Promise","resolve","listener","ev","getType","getContent","removeListener","on","setAccountData","addKey","algorithm","opts","keyData","name","decryption","global","Olm","PkDecryption","passphrase","pubkey","generate_key","free","Error","randomString","signObject","signKey","keyInfo","hasKey","store","secret","keys","encrypted","defaultKeyId","length","pkVerify","getId","userId","encryption","PkEncryption","set_recipient_key","encrypt","logger","warn","storePassthrough","passthrough","get","secretInfo","encInfo","ciphertext","mac","ephemeral","_getSecretStorageKey","get_private_key","decrypt","isStored","checkKey","undefined","request","devices","requestId","makeTxnId","requestControl","promise","reject","cancel","reason","cancelData","action","requesting_device_id","deviceId","request_id","toDevice","device","sendToDevice","getUserId","requestData","_onRequestReceived","event","sender","getSender","content","info","emit","user_id","device_id","onSecretRequested","device_trust","checkDeviceTrust","payload","type","encryptedContent","OLM_ALGORITHM","sender_key","_crypto","_olmDevice","deviceCurve25519Key","ensureOlmSessionsForDevices","getStoredDevice","encryptMessageForDevice","contentMap","_onSecretReceived","log","deviceInfo","_deviceList","getDeviceByIdentityKey","getSenderKey","includes","getSecretStorageKey","returned","privateKey","init_with_private_key","e"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SecretStorage = exports.SECRET_STORAGE_ALGORITHM_V1 = void 0;\n\nvar _events = require(\"events\");\n\nvar _logger = require(\"../logger\");\n\nvar olmlib = _interopRequireWildcard(require(\"./olmlib\"));\n\nvar _randomstring = require(\"../randomstring\");\n\n/*\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nconst SECRET_STORAGE_ALGORITHM_V1 = \"m.secret_storage.v1.curve25519-aes-sha2\";\n/**\n * Implements Secure Secret Storage and Sharing (MSC1946)\n * @module crypto/SecretStorage\n */\n\nexports.SECRET_STORAGE_ALGORITHM_V1 = SECRET_STORAGE_ALGORITHM_V1;\n\nclass SecretStorage extends _events.EventEmitter {\n  constructor(baseApis, cryptoCallbacks, crossSigningInfo) {\n    super();\n    this._baseApis = baseApis;\n    this._cryptoCallbacks = cryptoCallbacks;\n    this._crossSigningInfo = crossSigningInfo;\n    this._requests = {};\n    this._incomingRequests = {};\n  }\n\n  async getDefaultKeyId() {\n    const defaultKey = await this._baseApis.getAccountDataFromServer('m.secret_storage.default_key');\n    if (!defaultKey) return null;\n    return defaultKey.key;\n  }\n\n  setDefaultKeyId(keyId) {\n    return new Promise(resolve => {\n      const listener = ev => {\n        if (ev.getType() === 'm.secret_storage.default_key' && ev.getContent().key === keyId) {\n          this._baseApis.removeListener('accountData', listener);\n\n          resolve();\n        }\n      };\n\n      this._baseApis.on('accountData', listener);\n\n      this._baseApis.setAccountData('m.secret_storage.default_key', {\n        key: keyId\n      });\n    });\n  }\n  /**\n   * Add a key for encrypting secrets.\n   *\n   * @param {string} algorithm the algorithm used by the key.\n   * @param {object} opts the options for the algorithm.  The properties used\n   *     depend on the algorithm given.\n   * @param {string} [keyId] the ID of the key.  If not given, a random\n   *     ID will be generated.\n   *\n   * @return {string} the ID of the key\n   */\n\n\n  async addKey(algorithm, opts, keyId) {\n    const keyData = {\n      algorithm\n    };\n    if (!opts) opts = {};\n\n    if (opts.name) {\n      keyData.name = opts.name;\n    }\n\n    switch (algorithm) {\n      case SECRET_STORAGE_ALGORITHM_V1:\n        {\n          const decryption = new global.Olm.PkDecryption();\n\n          try {\n            const {\n              passphrase,\n              pubkey\n            } = opts; // Copies in public key details of the form generated by\n            // the Crypto module's `createRecoveryKeyFromPassphrase`.\n\n            if (passphrase && pubkey) {\n              keyData.passphrase = passphrase;\n              keyData.pubkey = pubkey;\n            } else if (pubkey) {\n              keyData.pubkey = pubkey;\n            } else {\n              keyData.pubkey = decryption.generate_key();\n            }\n          } finally {\n            decryption.free();\n          }\n\n          break;\n        }\n\n      default:\n        throw new Error(`Unknown key algorithm ${opts.algorithm}`);\n    }\n\n    if (!keyId) {\n      do {\n        keyId = (0, _randomstring.randomString)(32);\n      } while (await this._baseApis.getAccountDataFromServer(`m.secret_storage.key.${keyId}`));\n    }\n\n    await this._crossSigningInfo.signObject(keyData, 'master');\n    await this._baseApis.setAccountData(`m.secret_storage.key.${keyId}`, keyData);\n    return keyId;\n  }\n  /**\n   * Signs a given secret storage key with the cross-signing master key.\n   *\n   * @param {string} [keyId = default key's ID] The ID of the key to sign.\n   *     Defaults to the default key ID if not provided.\n   */\n\n\n  async signKey(keyId) {\n    if (!keyId) {\n      keyId = await this.getDefaultKeyId();\n    }\n\n    if (!keyId) {\n      throw new Error(\"signKey requires a key ID\");\n    }\n\n    const keyInfo = await this._baseApis.getAccountDataFromServer(`m.secret_storage.key.${keyId}`);\n\n    if (!keyInfo) {\n      throw new Error(`Key ${keyId} does not exist in account data`);\n    }\n\n    await this._crossSigningInfo.signObject(keyInfo, 'master');\n    await this._baseApis.setAccountData(`m.secret_storage.key.${keyId}`, keyInfo);\n  }\n  /**\n   * Check whether we have a key with a given ID.\n   *\n   * @param {string} [keyId = default key's ID] The ID of the key to check\n   *     for. Defaults to the default key ID if not provided.\n   * @return {boolean} Whether we have the key.\n   */\n\n\n  async hasKey(keyId) {\n    if (!keyId) {\n      keyId = await this.getDefaultKeyId();\n    }\n\n    if (!keyId) {\n      return false;\n    }\n\n    return !!this._baseApis.getAccountDataFromServer(\"m.secret_storage.key.\" + keyId);\n  }\n  /**\n   * Store an encrypted secret on the server\n   *\n   * @param {string} name The name of the secret\n   * @param {string} secret The secret contents.\n   * @param {Array} keys The IDs of the keys to use to encrypt the secret\n   *     or null/undefined to use the default key.\n   */\n\n\n  async store(name, secret, keys) {\n    const encrypted = {};\n\n    if (!keys) {\n      const defaultKeyId = await this.getDefaultKeyId();\n\n      if (!defaultKeyId) {\n        throw new Error(\"No keys specified and no default key present\");\n      }\n\n      keys = [defaultKeyId];\n    }\n\n    if (keys.length === 0) {\n      throw new Error(\"Zero keys given to encrypt with!\");\n    }\n\n    for (const keyId of keys) {\n      // get key information from key storage\n      const keyInfo = await this._baseApis.getAccountDataFromServer(\"m.secret_storage.key.\" + keyId);\n\n      if (!keyInfo) {\n        throw new Error(\"Unknown key: \" + keyId);\n      } // check signature of key info\n\n\n      (0, olmlib.pkVerify)(keyInfo, this._crossSigningInfo.getId('master'), this._crossSigningInfo.userId); // encrypt secret, based on the algorithm\n\n      switch (keyInfo.algorithm) {\n        case SECRET_STORAGE_ALGORITHM_V1:\n          {\n            const encryption = new global.Olm.PkEncryption();\n\n            try {\n              encryption.set_recipient_key(keyInfo.pubkey);\n              encrypted[keyId] = encryption.encrypt(secret);\n            } finally {\n              encryption.free();\n            }\n\n            break;\n          }\n\n        default:\n          _logger.logger.warn(\"unknown algorithm for secret storage key \" + keyId + \": \" + keyInfo.algorithm);\n\n        // do nothing if we don't understand the encryption algorithm\n      }\n    } // save encrypted secret\n\n\n    await this._baseApis.setAccountData(name, {\n      encrypted\n    });\n  }\n  /**\n   * Store a secret defined to be the same as the given key.\n   * No secret information will be stored, instead the secret will\n   * be stored with a marker to say that the contents of the secret is\n   * the value of the given key.\n   * This is useful for migration from systems that predate SSSS such as\n   * key backup.\n   *\n   * @param {string} name The name of the secret\n   * @param {string} keyId The ID of the key whose value will be the\n   *     value of the secret\n   * @returns {Promise} resolved when account data is saved\n   */\n\n\n  storePassthrough(name, keyId) {\n    return this._baseApis.setAccountData(name, {\n      [keyId]: {\n        passthrough: true\n      }\n    });\n  }\n  /**\n   * Get a secret from storage.\n   *\n   * @param {string} name the name of the secret\n   *\n   * @return {string} the contents of the secret\n   */\n\n\n  async get(name) {\n    const secretInfo = await this._baseApis.getAccountDataFromServer(name);\n\n    if (!secretInfo) {\n      return;\n    }\n\n    if (!secretInfo.encrypted) {\n      throw new Error(\"Content is not encrypted!\");\n    } // get possible keys to decrypt\n\n\n    const keys = {};\n\n    for (const keyId of Object.keys(secretInfo.encrypted)) {\n      // get key information from key storage\n      const keyInfo = await this._baseApis.getAccountDataFromServer(\"m.secret_storage.key.\" + keyId);\n      const encInfo = secretInfo.encrypted[keyId];\n\n      switch (keyInfo.algorithm) {\n        case SECRET_STORAGE_ALGORITHM_V1:\n          if (keyInfo.pubkey && encInfo.ciphertext && encInfo.mac && encInfo.ephemeral) {\n            keys[keyId] = keyInfo;\n          }\n\n          break;\n\n        default: // do nothing if we don't understand the encryption algorithm\n\n      }\n    }\n\n    let keyId;\n    let decryption;\n\n    try {\n      // fetch private key from app\n      [keyId, decryption] = await this._getSecretStorageKey(keys);\n      const encInfo = secretInfo.encrypted[keyId]; // We don't actually need the decryption object if it's a passthrough\n      // since we just want to return the key itself.\n\n      if (encInfo.passthrough) return decryption.get_private_key(); // decrypt secret\n\n      switch (keys[keyId].algorithm) {\n        case SECRET_STORAGE_ALGORITHM_V1:\n          return decryption.decrypt(encInfo.ephemeral, encInfo.mac, encInfo.ciphertext);\n      }\n    } finally {\n      if (decryption) decryption.free();\n    }\n  }\n  /**\n   * Check if a secret is stored on the server.\n   *\n   * @param {string} name the name of the secret\n   * @param {boolean} checkKey check if the secret is encrypted by a trusted key\n   *\n   * @return {boolean} whether or not the secret is stored\n   */\n\n\n  async isStored(name, checkKey) {\n    // check if secret exists\n    const secretInfo = await this._baseApis.getAccountDataFromServer(name);\n\n    if (!secretInfo || !secretInfo.encrypted) {\n      return false;\n    }\n\n    if (checkKey === undefined) checkKey = true; // check if secret is encrypted by a known/trusted secret and\n    // encryption looks sane\n\n    for (const keyId of Object.keys(secretInfo.encrypted)) {\n      // get key information from key storage\n      const keyInfo = await this._baseApis.getAccountDataFromServer(\"m.secret_storage.key.\" + keyId);\n      if (!keyInfo) return false;\n      const encInfo = secretInfo.encrypted[keyId];\n\n      if (checkKey) {\n        (0, olmlib.pkVerify)(keyInfo, this._crossSigningInfo.getId('master'), this._crossSigningInfo.userId);\n      }\n\n      switch (keyInfo.algorithm) {\n        case SECRET_STORAGE_ALGORITHM_V1:\n          if (keyInfo.pubkey && encInfo.ciphertext && encInfo.mac && encInfo.ephemeral) {\n            return true;\n          }\n\n          break;\n\n        default: // do nothing if we don't understand the encryption algorithm\n\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Request a secret from another device\n   *\n   * @param {string} name the name of the secret to request\n   * @param {string[]} devices the devices to request the secret from\n   *\n   * @return {string} the contents of the secret\n   */\n\n\n  request(name, devices) {\n    const requestId = this._baseApis.makeTxnId();\n\n    const requestControl = this._requests[requestId] = {\n      devices\n    };\n    const promise = new Promise((resolve, reject) => {\n      requestControl.resolve = resolve;\n      requestControl.reject = reject;\n    });\n\n    const cancel = reason => {\n      // send cancellation event\n      const cancelData = {\n        action: \"request_cancellation\",\n        requesting_device_id: this._baseApis.deviceId,\n        request_id: requestId\n      };\n      const toDevice = {};\n\n      for (const device of devices) {\n        toDevice[device] = cancelData;\n      }\n\n      this._baseApis.sendToDevice(\"m.secret.request\", {\n        [this._baseApis.getUserId()]: toDevice\n      }); // and reject the promise so that anyone waiting on it will be\n      // notified\n\n\n      requestControl.reject(new Error(reason || \"Cancelled\"));\n    }; // send request to devices\n\n\n    const requestData = {\n      name,\n      action: \"request\",\n      requesting_device_id: this._baseApis.deviceId,\n      request_id: requestId\n    };\n    const toDevice = {};\n\n    for (const device of devices) {\n      toDevice[device] = requestData;\n    }\n\n    this._baseApis.sendToDevice(\"m.secret.request\", {\n      [this._baseApis.getUserId()]: toDevice\n    });\n\n    return {\n      request_id: requestId,\n      promise,\n      cancel\n    };\n  }\n\n  async _onRequestReceived(event) {\n    const sender = event.getSender();\n    const content = event.getContent();\n\n    if (sender !== this._baseApis.getUserId() || !(content.name && content.action && content.requesting_device_id && content.request_id)) {\n      // ignore requests from anyone else, for now\n      return;\n    }\n\n    const deviceId = content.requesting_device_id; // check if it's a cancel\n\n    if (content.action === \"request_cancellation\") {\n      if (this._incomingRequests[deviceId] && this._incomingRequests[deviceId][content.request_id]) {\n        _logger.logger.info(\"received request cancellation for secret (\" + sender + \", \" + deviceId + \", \" + content.request_id + \")\");\n\n        this.baseApis.emit(\"crypto.secrets.requestCancelled\", {\n          user_id: sender,\n          device_id: deviceId,\n          request_id: content.request_id\n        });\n      }\n    } else if (content.action === \"request\") {\n      if (deviceId === this._baseApis.deviceId) {\n        // no point in trying to send ourself the secret\n        return;\n      } // check if we have the secret\n\n\n      _logger.logger.info(\"received request for secret (\" + sender + \", \" + deviceId + \", \" + content.request_id + \")\");\n\n      if (!this._cryptoCallbacks.onSecretRequested) {\n        return;\n      }\n\n      const secret = await this._cryptoCallbacks.onSecretRequested({\n        user_id: sender,\n        device_id: deviceId,\n        request_id: content.request_id,\n        name: content.name,\n        device_trust: this._baseApis.checkDeviceTrust(sender, deviceId)\n      });\n\n      if (secret) {\n        const payload = {\n          type: \"m.secret.send\",\n          content: {\n            request_id: content.request_id,\n            secret: secret\n          }\n        };\n        const encryptedContent = {\n          algorithm: olmlib.OLM_ALGORITHM,\n          sender_key: this._baseApis._crypto._olmDevice.deviceCurve25519Key,\n          ciphertext: {}\n        };\n        await olmlib.ensureOlmSessionsForDevices(this._baseApis._crypto._olmDevice, this._baseApis, {\n          [sender]: [await this._baseApis.getStoredDevice(sender, deviceId)]\n        });\n        await olmlib.encryptMessageForDevice(encryptedContent.ciphertext, this._baseApis.getUserId(), this._baseApis.deviceId, this._baseApis._crypto._olmDevice, sender, this._baseApis._crypto.getStoredDevice(sender, deviceId), payload);\n        const contentMap = {\n          [sender]: {\n            [deviceId]: encryptedContent\n          }\n        };\n\n        this._baseApis.sendToDevice(\"m.room.encrypted\", contentMap);\n      }\n    }\n  }\n\n  _onSecretReceived(event) {\n    if (event.getSender() !== this._baseApis.getUserId()) {\n      // we shouldn't be receiving secrets from anyone else, so ignore\n      // because someone could be trying to send us bogus data\n      return;\n    }\n\n    const content = event.getContent();\n\n    _logger.logger.log(\"got secret share for request \", content.request_id);\n\n    const requestControl = this._requests[content.request_id];\n\n    if (requestControl) {\n      // make sure that the device that sent it is one of the devices that\n      // we requested from\n      const deviceInfo = this._baseApis._crypto._deviceList.getDeviceByIdentityKey(olmlib.OLM_ALGORITHM, event.getSenderKey());\n\n      if (!deviceInfo) {\n        _logger.logger.log(\"secret share from unknown device with key\", event.getSenderKey());\n\n        return;\n      }\n\n      if (!requestControl.devices.includes(deviceInfo.deviceId)) {\n        _logger.logger.log(\"unsolicited secret share from device\", deviceInfo.deviceId);\n\n        return;\n      }\n\n      requestControl.resolve(content.secret);\n    }\n  }\n\n  async _getSecretStorageKey(keys) {\n    if (!this._cryptoCallbacks.getSecretStorageKey) {\n      throw new Error(\"No getSecretStorageKey callback supplied\");\n    }\n\n    const returned = await this._cryptoCallbacks.getSecretStorageKey({\n      keys\n    });\n\n    if (!returned) {\n      throw new Error(\"getSecretStorageKey callback returned falsey\");\n    }\n\n    if (returned.length < 2) {\n      throw new Error(\"getSecretStorageKey callback returned invalid data\");\n    }\n\n    const [keyId, privateKey] = returned;\n\n    if (!keys[keyId]) {\n      throw new Error(\"App returned unknown key from getSecretStorageKey!\");\n    }\n\n    switch (keys[keyId].algorithm) {\n      case SECRET_STORAGE_ALGORITHM_V1:\n        {\n          const decryption = new global.Olm.PkDecryption();\n          let pubkey;\n\n          try {\n            pubkey = decryption.init_with_private_key(privateKey);\n          } catch (e) {\n            decryption.free();\n            throw new Error(\"getSecretStorageKey callback returned invalid key\");\n          }\n\n          if (pubkey !== keys[keyId].pubkey) {\n            decryption.free();\n            throw new Error(\"getSecretStorageKey callback returned incorrect key\");\n          }\n\n          return [keyId, decryption];\n        }\n\n      default:\n        throw new Error(\"Unknown key type: \" + keys[keyId].algorithm);\n    }\n  }\n\n}\n\nexports.SecretStorage = SecretStorage;"]},"metadata":{},"sourceType":"script"}