{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DeviceTrustLevel = exports.UserTrustLevel = exports.CrossSigningLevel = exports.CrossSigningInfo = void 0;\n\nvar _olmlib = require(\"./olmlib\");\n\nvar _events = require(\"events\");\n\nvar _logger = require(\"../logger\");\n/*\nCopyright 2019 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Cross signing methods\n * @module crypto/CrossSigning\n */\n\n\nfunction publicKeyFromKeyInfo(keyInfo) {\n  // `keys` is an object with { [`ed25519:${pubKey}`]: pubKey }\n  // We assume only a single key, and we want the bare form without type\n  // prefix, so we select the values.\n  return Object.values(keyInfo.keys)[0];\n}\n\nclass CrossSigningInfo extends _events.EventEmitter {\n  /**\n   * Information about a user's cross-signing keys\n   *\n   * @class\n   *\n   * @param {string} userId the user that the information is about\n   * @param {object} callbacks Callbacks used to interact with the app\n   *     Requires getCrossSigningKey and saveCrossSigningKeys\n   */\n  constructor(userId, callbacks) {\n    super(); // you can't change the userId\n\n    Object.defineProperty(this, 'userId', {\n      enumerable: true,\n      value: userId\n    });\n    this._callbacks = callbacks || {};\n    this.keys = {};\n    this.firstUse = true;\n  }\n  /**\n   * Calls the app callback to ask for a private key\n   * @param {string} type The key type (\"master\", \"self_signing\", or \"user_signing\")\n   * @param {string} expectedPubkey The matching public key or undefined to use\n   *     the stored public key for the given key type.\n   * @returns {Array} An array with [ public key, Olm.PkSigning ]\n   */\n\n\n  async getCrossSigningKey(type, expectedPubkey) {\n    if (!this._callbacks.getCrossSigningKey) {\n      throw new Error(\"No getCrossSigningKey callback supplied\");\n    }\n\n    if (expectedPubkey === undefined) {\n      expectedPubkey = this.getId(type);\n    }\n\n    const privkey = await this._callbacks.getCrossSigningKey(type, expectedPubkey);\n\n    if (!privkey) {\n      throw new Error(\"getCrossSigningKey callback for \" + type + \" returned falsey\");\n    }\n\n    const signing = new global.Olm.PkSigning();\n    const gotPubkey = signing.init_with_seed(privkey);\n\n    if (gotPubkey !== expectedPubkey) {\n      signing.free();\n      throw new Error(\"Key type \" + type + \" from getCrossSigningKey callback did not match\");\n    } else {\n      return [gotPubkey, signing];\n    }\n  }\n\n  static fromStorage(obj, userId) {\n    const res = new CrossSigningInfo(userId);\n\n    for (const prop in obj) {\n      if (obj.hasOwnProperty(prop)) {\n        res[prop] = obj[prop];\n      }\n    }\n\n    return res;\n  }\n\n  toStorage() {\n    return {\n      keys: this.keys,\n      firstUse: this.firstUse\n    };\n  }\n  /**\n   * Check whether the private keys exist in secret storage.\n   * XXX: This could be static, be we often seem to have an instance when we\n   * want to know this anyway...\n   *\n   * @param {SecretStorage} secretStorage The secret store using account data\n   * @returns {boolean} Whether all private keys were found in storage\n   */\n\n\n  async isStoredInSecretStorage(secretStorage) {\n    let stored = true;\n\n    for (const type of [\"master\", \"self_signing\", \"user_signing\"]) {\n      stored &= await secretStorage.isStored(`m.cross_signing.${type}`, false);\n    }\n\n    return stored;\n  }\n  /**\n   * Store private keys in secret storage for use by other devices. This is\n   * typically called in conjunction with the creation of new cross-signing\n   * keys.\n   *\n   * @param {object} keys The keys to store\n   * @param {SecretStorage} secretStorage The secret store using account data\n   */\n\n\n  static async storeInSecretStorage(keys, secretStorage) {\n    for (const type of Object.keys(keys)) {\n      const encodedKey = (0, _olmlib.encodeBase64)(keys[type]);\n      await secretStorage.store(`m.cross_signing.${type}`, encodedKey);\n    }\n  }\n  /**\n   * Get private keys from secret storage created by some other device. This\n   * also passes the private keys to the app-specific callback.\n   *\n   * @param {string} type The type of key to get.  One of \"master\",\n   * \"self_signing\", or \"user_signing\".\n   * @param {SecretStorage} secretStorage The secret store using account data\n   * @return {Uint8Array} The private key\n   */\n\n\n  static async getFromSecretStorage(type, secretStorage) {\n    const encodedKey = await secretStorage.get(`m.cross_signing.${type}`);\n    return (0, _olmlib.decodeBase64)(encodedKey);\n  }\n  /**\n   * Get the ID used to identify the user. This can also be used to test for\n   * the existence of a given key type.\n   *\n   * @param {string} type The type of key to get the ID of.  One of \"master\",\n   * \"self_signing\", or \"user_signing\".  Defaults to \"master\".\n   *\n   * @return {string} the ID\n   */\n\n\n  getId(type) {\n    type = type || \"master\";\n    if (!this.keys[type]) return null;\n    const keyInfo = this.keys[type];\n    return publicKeyFromKeyInfo(keyInfo);\n  }\n  /**\n   * Create new cross-signing keys for the given key types. The public keys\n   * will be held in this class, while the private keys are passed off to the\n   * `saveCrossSigningKeys` application callback.\n   *\n   * @param {CrossSigningLevel} level The key types to reset\n   */\n\n\n  async resetKeys(level) {\n    if (!this._callbacks.saveCrossSigningKeys) {\n      throw new Error(\"No saveCrossSigningKeys callback supplied\");\n    } // If we're resetting the master key, we reset all keys\n\n\n    if (level === undefined || level & CrossSigningLevel.MASTER || !this.keys.master) {\n      level = CrossSigningLevel.MASTER | CrossSigningLevel.USER_SIGNING | CrossSigningLevel.SELF_SIGNING;\n    } else if (level === 0) {\n      return;\n    }\n\n    const privateKeys = {};\n    const keys = {};\n    let masterSigning;\n    let masterPub;\n\n    try {\n      if (level & CrossSigningLevel.MASTER) {\n        masterSigning = new global.Olm.PkSigning();\n        privateKeys.master = masterSigning.generate_seed();\n        masterPub = masterSigning.init_with_seed(privateKeys.master);\n        keys.master = {\n          user_id: this.userId,\n          usage: ['master'],\n          keys: {\n            ['ed25519:' + masterPub]: masterPub\n          }\n        };\n      } else {\n        [masterPub, masterSigning] = await this.getCrossSigningKey(\"master\");\n      }\n\n      if (level & CrossSigningLevel.SELF_SIGNING) {\n        const sskSigning = new global.Olm.PkSigning();\n\n        try {\n          privateKeys.self_signing = sskSigning.generate_seed();\n          const sskPub = sskSigning.init_with_seed(privateKeys.self_signing);\n          keys.self_signing = {\n            user_id: this.userId,\n            usage: ['self_signing'],\n            keys: {\n              ['ed25519:' + sskPub]: sskPub\n            }\n          };\n          (0, _olmlib.pkSign)(keys.self_signing, masterSigning, this.userId, masterPub);\n        } finally {\n          sskSigning.free();\n        }\n      }\n\n      if (level & CrossSigningLevel.USER_SIGNING) {\n        const uskSigning = new global.Olm.PkSigning();\n\n        try {\n          privateKeys.user_signing = uskSigning.generate_seed();\n          const uskPub = uskSigning.init_with_seed(privateKeys.user_signing);\n          keys.user_signing = {\n            user_id: this.userId,\n            usage: ['user_signing'],\n            keys: {\n              ['ed25519:' + uskPub]: uskPub\n            }\n          };\n          (0, _olmlib.pkSign)(keys.user_signing, masterSigning, this.userId, masterPub);\n        } finally {\n          uskSigning.free();\n        }\n      }\n\n      Object.assign(this.keys, keys);\n\n      this._callbacks.saveCrossSigningKeys(privateKeys);\n    } finally {\n      if (masterSigning) {\n        masterSigning.free();\n      }\n    }\n  }\n\n  setKeys(keys) {\n    const signingKeys = {};\n\n    if (keys.master) {\n      if (keys.master.user_id !== this.userId) {\n        const error = \"Mismatched user ID \" + keys.master.user_id + \" in master key from \" + this.userId;\n\n        _logger.logger.error(error);\n\n        throw new Error(error);\n      }\n\n      if (!this.keys.master) {\n        // this is the first key we've seen, so first-use is true\n        this.firstUse = true;\n      } else if (publicKeyFromKeyInfo(keys.master) !== this.getId()) {\n        // this is a different key, so first-use is false\n        this.firstUse = false;\n      } // otherwise, same key, so no change\n\n\n      signingKeys.master = keys.master;\n    } else if (this.keys.master) {\n      signingKeys.master = this.keys.master;\n    } else {\n      throw new Error(\"Tried to set cross-signing keys without a master key\");\n    }\n\n    const masterKey = publicKeyFromKeyInfo(signingKeys.master); // verify signatures\n\n    if (keys.user_signing) {\n      if (keys.user_signing.user_id !== this.userId) {\n        const error = \"Mismatched user ID \" + keys.master.user_id + \" in user_signing key from \" + this.userId;\n\n        _logger.logger.error(error);\n\n        throw new Error(error);\n      }\n\n      try {\n        (0, _olmlib.pkVerify)(keys.user_signing, masterKey, this.userId);\n      } catch (e) {\n        _logger.logger.error(\"invalid signature on user-signing key\"); // FIXME: what do we want to do here?\n\n\n        throw e;\n      }\n    }\n\n    if (keys.self_signing) {\n      if (keys.self_signing.user_id !== this.userId) {\n        const error = \"Mismatched user ID \" + keys.master.user_id + \" in self_signing key from \" + this.userId;\n\n        _logger.logger.error(error);\n\n        throw new Error(error);\n      }\n\n      try {\n        (0, _olmlib.pkVerify)(keys.self_signing, masterKey, this.userId);\n      } catch (e) {\n        _logger.logger.error(\"invalid signature on self-signing key\"); // FIXME: what do we want to do here?\n\n\n        throw e;\n      }\n    } // if everything checks out, then save the keys\n\n\n    if (keys.master) {\n      this.keys.master = keys.master; // if the master key is set, then the old self-signing and\n      // user-signing keys are obsolete\n\n      this.keys.self_signing = null;\n      this.keys.user_signing = null;\n    }\n\n    if (keys.self_signing) {\n      this.keys.self_signing = keys.self_signing;\n    }\n\n    if (keys.user_signing) {\n      this.keys.user_signing = keys.user_signing;\n    }\n  }\n\n  async signObject(data, type) {\n    if (!this.keys[type]) {\n      throw new Error(\"Attempted to sign with \" + type + \" key but no such key present\");\n    }\n\n    const [pubkey, signing] = await this.getCrossSigningKey(type);\n\n    try {\n      (0, _olmlib.pkSign)(data, signing, this.userId, pubkey);\n      return data;\n    } finally {\n      signing.free();\n    }\n  }\n\n  async signUser(key) {\n    if (!this.keys.user_signing) {\n      return;\n    }\n\n    return this.signObject(key.keys.master, \"user_signing\");\n  }\n\n  async signDevice(userId, device) {\n    if (userId !== this.userId) {\n      throw new Error(`Trying to sign ${userId}'s device; can only sign our own device`);\n    }\n\n    if (!this.keys.self_signing) {\n      return;\n    }\n\n    return this.signObject({\n      algorithms: device.algorithms,\n      keys: device.keys,\n      device_id: device.deviceId,\n      user_id: userId\n    }, \"self_signing\");\n  }\n  /**\n   * Check whether a given user is trusted.\n   *\n   * @param {CrossSigningInfo} userCrossSigning Cross signing info for user\n   *\n   * @returns {UserTrustLevel}\n   */\n\n\n  checkUserTrust(userCrossSigning) {\n    // if we're checking our own key, then it's trusted if the master key\n    // and self-signing key match\n    if (this.userId === userCrossSigning.userId && this.getId() && this.getId() === userCrossSigning.getId() && this.getId(\"self_signing\") && this.getId(\"self_signing\") === userCrossSigning.getId(\"self_signing\")) {\n      return new UserTrustLevel(true, this.firstUse);\n    }\n\n    if (!this.keys.user_signing) {\n      // If there's no user signing key, they can't possibly be verified.\n      // They may be TOFU trusted though.\n      return new UserTrustLevel(false, userCrossSigning.firstUse);\n    }\n\n    let userTrusted;\n    const userMaster = userCrossSigning.keys.master;\n    const uskId = this.getId('user_signing');\n\n    try {\n      (0, _olmlib.pkVerify)(userMaster, uskId, this.userId);\n      userTrusted = true;\n    } catch (e) {\n      userTrusted = false;\n    }\n\n    return new UserTrustLevel(userTrusted, userCrossSigning.firstUse);\n  }\n  /**\n   * Check whether a given device is trusted.\n   *\n   * @param {CrossSigningInfo} userCrossSigning Cross signing info for user\n   * @param {module:crypto/deviceinfo} device The device to check\n   * @param {bool} localTrust Whether the device is trusted locally\n   *\n   * @returns {DeviceTrustLevel}\n   */\n\n\n  checkDeviceTrust(userCrossSigning, device, localTrust) {\n    const userTrust = this.checkUserTrust(userCrossSigning);\n    const userSSK = userCrossSigning.keys.self_signing;\n\n    if (!userSSK) {\n      // if the user has no self-signing key then we cannot make any\n      // trust assertions about this device from cross-signing\n      return new DeviceTrustLevel(false, false, localTrust);\n    }\n\n    const deviceObj = deviceToObject(device, userCrossSigning.userId);\n\n    try {\n      // if we can verify the user's SSK from their master key...\n      (0, _olmlib.pkVerify)(userSSK, userCrossSigning.getId(), userCrossSigning.userId); // ...and this device's key from their SSK...\n\n      (0, _olmlib.pkVerify)(deviceObj, publicKeyFromKeyInfo(userSSK), userCrossSigning.userId); // ...then we trust this device as much as far as we trust the user\n\n      return DeviceTrustLevel.fromUserTrustLevel(userTrust, localTrust);\n    } catch (e) {\n      return new DeviceTrustLevel(false, false, localTrust);\n    }\n  }\n\n}\n\nexports.CrossSigningInfo = CrossSigningInfo;\n\nfunction deviceToObject(device, userId) {\n  return {\n    algorithms: device.algorithms,\n    keys: device.keys,\n    device_id: device.deviceId,\n    user_id: userId,\n    signatures: device.signatures\n  };\n}\n\nconst CrossSigningLevel = {\n  MASTER: 4,\n  USER_SIGNING: 2,\n  SELF_SIGNING: 1\n};\n/**\n * Represents the ways in which we trust a user\n */\n\nexports.CrossSigningLevel = CrossSigningLevel;\n\nclass UserTrustLevel {\n  constructor(crossSigningVerified, tofu) {\n    this._crossSigningVerified = crossSigningVerified;\n    this._tofu = tofu;\n  }\n  /**\n   * @returns {bool} true if this user is verified via any means\n   */\n\n\n  isVerified() {\n    return this.isCrossSigningVerified();\n  }\n  /**\n   * @returns {bool} true if this user is verified via cross signing\n   */\n\n\n  isCrossSigningVerified() {\n    return this._crossSigningVerified;\n  }\n  /**\n   * @returns {bool} true if this user's key is trusted on first use\n   */\n\n\n  isTofu() {\n    return this._tofu;\n  }\n\n}\n/**\n * Represents the ways in which we trust a device\n */\n\n\nexports.UserTrustLevel = UserTrustLevel;\n\nclass DeviceTrustLevel {\n  constructor(crossSigningVerified, tofu, localVerified) {\n    this._crossSigningVerified = crossSigningVerified;\n    this._tofu = tofu;\n    this._localVerified = localVerified;\n  }\n\n  static fromUserTrustLevel(userTrustLevel, localVerified) {\n    return new DeviceTrustLevel(userTrustLevel._crossSigningVerified, userTrustLevel._tofu, localVerified);\n  }\n  /**\n   * @returns {bool} true if this device is verified via any means\n   */\n\n\n  isVerified() {\n    return this.isCrossSigningVerified() || this.isLocallyVerified();\n  }\n  /**\n   * @returns {bool} true if this device is verified via cross signing\n   */\n\n\n  isCrossSigningVerified() {\n    return this._crossSigningVerified;\n  }\n  /**\n   * @returns {bool} true if this device is verified locally\n   */\n\n\n  isLocallyVerified() {\n    return this._localVerified;\n  }\n  /**\n   * @returns {bool} true if this device is trusted from a user's key\n   * that is trusted on first use\n   */\n\n\n  isTofu() {\n    return this._tofu;\n  }\n\n}\n\nexports.DeviceTrustLevel = DeviceTrustLevel;","map":{"version":3,"sources":["/home/kimist/Developpement/React/watcha_client/node_modules/matrix-js-sdk/lib/crypto/CrossSigning.js"],"names":["Object","defineProperty","exports","value","DeviceTrustLevel","UserTrustLevel","CrossSigningLevel","CrossSigningInfo","_olmlib","require","_events","_logger","publicKeyFromKeyInfo","keyInfo","values","keys","EventEmitter","constructor","userId","callbacks","enumerable","_callbacks","firstUse","getCrossSigningKey","type","expectedPubkey","Error","undefined","getId","privkey","signing","global","Olm","PkSigning","gotPubkey","init_with_seed","free","fromStorage","obj","res","prop","hasOwnProperty","toStorage","isStoredInSecretStorage","secretStorage","stored","isStored","storeInSecretStorage","encodedKey","encodeBase64","store","getFromSecretStorage","get","decodeBase64","resetKeys","level","saveCrossSigningKeys","MASTER","master","USER_SIGNING","SELF_SIGNING","privateKeys","masterSigning","masterPub","generate_seed","user_id","usage","sskSigning","self_signing","sskPub","pkSign","uskSigning","user_signing","uskPub","assign","setKeys","signingKeys","error","logger","masterKey","pkVerify","e","signObject","data","pubkey","signUser","key","signDevice","device","algorithms","device_id","deviceId","checkUserTrust","userCrossSigning","userTrusted","userMaster","uskId","checkDeviceTrust","localTrust","userTrust","userSSK","deviceObj","deviceToObject","fromUserTrustLevel","signatures","crossSigningVerified","tofu","_crossSigningVerified","_tofu","isVerified","isCrossSigningVerified","isTofu","localVerified","_localVerified","userTrustLevel","isLocallyVerified"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DeviceTrustLevel = exports.UserTrustLevel = exports.CrossSigningLevel = exports.CrossSigningInfo = void 0;\n\nvar _olmlib = require(\"./olmlib\");\n\nvar _events = require(\"events\");\n\nvar _logger = require(\"../logger\");\n\n/*\nCopyright 2019 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Cross signing methods\n * @module crypto/CrossSigning\n */\nfunction publicKeyFromKeyInfo(keyInfo) {\n  // `keys` is an object with { [`ed25519:${pubKey}`]: pubKey }\n  // We assume only a single key, and we want the bare form without type\n  // prefix, so we select the values.\n  return Object.values(keyInfo.keys)[0];\n}\n\nclass CrossSigningInfo extends _events.EventEmitter {\n  /**\n   * Information about a user's cross-signing keys\n   *\n   * @class\n   *\n   * @param {string} userId the user that the information is about\n   * @param {object} callbacks Callbacks used to interact with the app\n   *     Requires getCrossSigningKey and saveCrossSigningKeys\n   */\n  constructor(userId, callbacks) {\n    super(); // you can't change the userId\n\n    Object.defineProperty(this, 'userId', {\n      enumerable: true,\n      value: userId\n    });\n    this._callbacks = callbacks || {};\n    this.keys = {};\n    this.firstUse = true;\n  }\n  /**\n   * Calls the app callback to ask for a private key\n   * @param {string} type The key type (\"master\", \"self_signing\", or \"user_signing\")\n   * @param {string} expectedPubkey The matching public key or undefined to use\n   *     the stored public key for the given key type.\n   * @returns {Array} An array with [ public key, Olm.PkSigning ]\n   */\n\n\n  async getCrossSigningKey(type, expectedPubkey) {\n    if (!this._callbacks.getCrossSigningKey) {\n      throw new Error(\"No getCrossSigningKey callback supplied\");\n    }\n\n    if (expectedPubkey === undefined) {\n      expectedPubkey = this.getId(type);\n    }\n\n    const privkey = await this._callbacks.getCrossSigningKey(type, expectedPubkey);\n\n    if (!privkey) {\n      throw new Error(\"getCrossSigningKey callback for \" + type + \" returned falsey\");\n    }\n\n    const signing = new global.Olm.PkSigning();\n    const gotPubkey = signing.init_with_seed(privkey);\n\n    if (gotPubkey !== expectedPubkey) {\n      signing.free();\n      throw new Error(\"Key type \" + type + \" from getCrossSigningKey callback did not match\");\n    } else {\n      return [gotPubkey, signing];\n    }\n  }\n\n  static fromStorage(obj, userId) {\n    const res = new CrossSigningInfo(userId);\n\n    for (const prop in obj) {\n      if (obj.hasOwnProperty(prop)) {\n        res[prop] = obj[prop];\n      }\n    }\n\n    return res;\n  }\n\n  toStorage() {\n    return {\n      keys: this.keys,\n      firstUse: this.firstUse\n    };\n  }\n  /**\n   * Check whether the private keys exist in secret storage.\n   * XXX: This could be static, be we often seem to have an instance when we\n   * want to know this anyway...\n   *\n   * @param {SecretStorage} secretStorage The secret store using account data\n   * @returns {boolean} Whether all private keys were found in storage\n   */\n\n\n  async isStoredInSecretStorage(secretStorage) {\n    let stored = true;\n\n    for (const type of [\"master\", \"self_signing\", \"user_signing\"]) {\n      stored &= await secretStorage.isStored(`m.cross_signing.${type}`, false);\n    }\n\n    return stored;\n  }\n  /**\n   * Store private keys in secret storage for use by other devices. This is\n   * typically called in conjunction with the creation of new cross-signing\n   * keys.\n   *\n   * @param {object} keys The keys to store\n   * @param {SecretStorage} secretStorage The secret store using account data\n   */\n\n\n  static async storeInSecretStorage(keys, secretStorage) {\n    for (const type of Object.keys(keys)) {\n      const encodedKey = (0, _olmlib.encodeBase64)(keys[type]);\n      await secretStorage.store(`m.cross_signing.${type}`, encodedKey);\n    }\n  }\n  /**\n   * Get private keys from secret storage created by some other device. This\n   * also passes the private keys to the app-specific callback.\n   *\n   * @param {string} type The type of key to get.  One of \"master\",\n   * \"self_signing\", or \"user_signing\".\n   * @param {SecretStorage} secretStorage The secret store using account data\n   * @return {Uint8Array} The private key\n   */\n\n\n  static async getFromSecretStorage(type, secretStorage) {\n    const encodedKey = await secretStorage.get(`m.cross_signing.${type}`);\n    return (0, _olmlib.decodeBase64)(encodedKey);\n  }\n  /**\n   * Get the ID used to identify the user. This can also be used to test for\n   * the existence of a given key type.\n   *\n   * @param {string} type The type of key to get the ID of.  One of \"master\",\n   * \"self_signing\", or \"user_signing\".  Defaults to \"master\".\n   *\n   * @return {string} the ID\n   */\n\n\n  getId(type) {\n    type = type || \"master\";\n    if (!this.keys[type]) return null;\n    const keyInfo = this.keys[type];\n    return publicKeyFromKeyInfo(keyInfo);\n  }\n  /**\n   * Create new cross-signing keys for the given key types. The public keys\n   * will be held in this class, while the private keys are passed off to the\n   * `saveCrossSigningKeys` application callback.\n   *\n   * @param {CrossSigningLevel} level The key types to reset\n   */\n\n\n  async resetKeys(level) {\n    if (!this._callbacks.saveCrossSigningKeys) {\n      throw new Error(\"No saveCrossSigningKeys callback supplied\");\n    } // If we're resetting the master key, we reset all keys\n\n\n    if (level === undefined || level & CrossSigningLevel.MASTER || !this.keys.master) {\n      level = CrossSigningLevel.MASTER | CrossSigningLevel.USER_SIGNING | CrossSigningLevel.SELF_SIGNING;\n    } else if (level === 0) {\n      return;\n    }\n\n    const privateKeys = {};\n    const keys = {};\n    let masterSigning;\n    let masterPub;\n\n    try {\n      if (level & CrossSigningLevel.MASTER) {\n        masterSigning = new global.Olm.PkSigning();\n        privateKeys.master = masterSigning.generate_seed();\n        masterPub = masterSigning.init_with_seed(privateKeys.master);\n        keys.master = {\n          user_id: this.userId,\n          usage: ['master'],\n          keys: {\n            ['ed25519:' + masterPub]: masterPub\n          }\n        };\n      } else {\n        [masterPub, masterSigning] = await this.getCrossSigningKey(\"master\");\n      }\n\n      if (level & CrossSigningLevel.SELF_SIGNING) {\n        const sskSigning = new global.Olm.PkSigning();\n\n        try {\n          privateKeys.self_signing = sskSigning.generate_seed();\n          const sskPub = sskSigning.init_with_seed(privateKeys.self_signing);\n          keys.self_signing = {\n            user_id: this.userId,\n            usage: ['self_signing'],\n            keys: {\n              ['ed25519:' + sskPub]: sskPub\n            }\n          };\n          (0, _olmlib.pkSign)(keys.self_signing, masterSigning, this.userId, masterPub);\n        } finally {\n          sskSigning.free();\n        }\n      }\n\n      if (level & CrossSigningLevel.USER_SIGNING) {\n        const uskSigning = new global.Olm.PkSigning();\n\n        try {\n          privateKeys.user_signing = uskSigning.generate_seed();\n          const uskPub = uskSigning.init_with_seed(privateKeys.user_signing);\n          keys.user_signing = {\n            user_id: this.userId,\n            usage: ['user_signing'],\n            keys: {\n              ['ed25519:' + uskPub]: uskPub\n            }\n          };\n          (0, _olmlib.pkSign)(keys.user_signing, masterSigning, this.userId, masterPub);\n        } finally {\n          uskSigning.free();\n        }\n      }\n\n      Object.assign(this.keys, keys);\n\n      this._callbacks.saveCrossSigningKeys(privateKeys);\n    } finally {\n      if (masterSigning) {\n        masterSigning.free();\n      }\n    }\n  }\n\n  setKeys(keys) {\n    const signingKeys = {};\n\n    if (keys.master) {\n      if (keys.master.user_id !== this.userId) {\n        const error = \"Mismatched user ID \" + keys.master.user_id + \" in master key from \" + this.userId;\n\n        _logger.logger.error(error);\n\n        throw new Error(error);\n      }\n\n      if (!this.keys.master) {\n        // this is the first key we've seen, so first-use is true\n        this.firstUse = true;\n      } else if (publicKeyFromKeyInfo(keys.master) !== this.getId()) {\n        // this is a different key, so first-use is false\n        this.firstUse = false;\n      } // otherwise, same key, so no change\n\n\n      signingKeys.master = keys.master;\n    } else if (this.keys.master) {\n      signingKeys.master = this.keys.master;\n    } else {\n      throw new Error(\"Tried to set cross-signing keys without a master key\");\n    }\n\n    const masterKey = publicKeyFromKeyInfo(signingKeys.master); // verify signatures\n\n    if (keys.user_signing) {\n      if (keys.user_signing.user_id !== this.userId) {\n        const error = \"Mismatched user ID \" + keys.master.user_id + \" in user_signing key from \" + this.userId;\n\n        _logger.logger.error(error);\n\n        throw new Error(error);\n      }\n\n      try {\n        (0, _olmlib.pkVerify)(keys.user_signing, masterKey, this.userId);\n      } catch (e) {\n        _logger.logger.error(\"invalid signature on user-signing key\"); // FIXME: what do we want to do here?\n\n\n        throw e;\n      }\n    }\n\n    if (keys.self_signing) {\n      if (keys.self_signing.user_id !== this.userId) {\n        const error = \"Mismatched user ID \" + keys.master.user_id + \" in self_signing key from \" + this.userId;\n\n        _logger.logger.error(error);\n\n        throw new Error(error);\n      }\n\n      try {\n        (0, _olmlib.pkVerify)(keys.self_signing, masterKey, this.userId);\n      } catch (e) {\n        _logger.logger.error(\"invalid signature on self-signing key\"); // FIXME: what do we want to do here?\n\n\n        throw e;\n      }\n    } // if everything checks out, then save the keys\n\n\n    if (keys.master) {\n      this.keys.master = keys.master; // if the master key is set, then the old self-signing and\n      // user-signing keys are obsolete\n\n      this.keys.self_signing = null;\n      this.keys.user_signing = null;\n    }\n\n    if (keys.self_signing) {\n      this.keys.self_signing = keys.self_signing;\n    }\n\n    if (keys.user_signing) {\n      this.keys.user_signing = keys.user_signing;\n    }\n  }\n\n  async signObject(data, type) {\n    if (!this.keys[type]) {\n      throw new Error(\"Attempted to sign with \" + type + \" key but no such key present\");\n    }\n\n    const [pubkey, signing] = await this.getCrossSigningKey(type);\n\n    try {\n      (0, _olmlib.pkSign)(data, signing, this.userId, pubkey);\n      return data;\n    } finally {\n      signing.free();\n    }\n  }\n\n  async signUser(key) {\n    if (!this.keys.user_signing) {\n      return;\n    }\n\n    return this.signObject(key.keys.master, \"user_signing\");\n  }\n\n  async signDevice(userId, device) {\n    if (userId !== this.userId) {\n      throw new Error(`Trying to sign ${userId}'s device; can only sign our own device`);\n    }\n\n    if (!this.keys.self_signing) {\n      return;\n    }\n\n    return this.signObject({\n      algorithms: device.algorithms,\n      keys: device.keys,\n      device_id: device.deviceId,\n      user_id: userId\n    }, \"self_signing\");\n  }\n  /**\n   * Check whether a given user is trusted.\n   *\n   * @param {CrossSigningInfo} userCrossSigning Cross signing info for user\n   *\n   * @returns {UserTrustLevel}\n   */\n\n\n  checkUserTrust(userCrossSigning) {\n    // if we're checking our own key, then it's trusted if the master key\n    // and self-signing key match\n    if (this.userId === userCrossSigning.userId && this.getId() && this.getId() === userCrossSigning.getId() && this.getId(\"self_signing\") && this.getId(\"self_signing\") === userCrossSigning.getId(\"self_signing\")) {\n      return new UserTrustLevel(true, this.firstUse);\n    }\n\n    if (!this.keys.user_signing) {\n      // If there's no user signing key, they can't possibly be verified.\n      // They may be TOFU trusted though.\n      return new UserTrustLevel(false, userCrossSigning.firstUse);\n    }\n\n    let userTrusted;\n    const userMaster = userCrossSigning.keys.master;\n    const uskId = this.getId('user_signing');\n\n    try {\n      (0, _olmlib.pkVerify)(userMaster, uskId, this.userId);\n      userTrusted = true;\n    } catch (e) {\n      userTrusted = false;\n    }\n\n    return new UserTrustLevel(userTrusted, userCrossSigning.firstUse);\n  }\n  /**\n   * Check whether a given device is trusted.\n   *\n   * @param {CrossSigningInfo} userCrossSigning Cross signing info for user\n   * @param {module:crypto/deviceinfo} device The device to check\n   * @param {bool} localTrust Whether the device is trusted locally\n   *\n   * @returns {DeviceTrustLevel}\n   */\n\n\n  checkDeviceTrust(userCrossSigning, device, localTrust) {\n    const userTrust = this.checkUserTrust(userCrossSigning);\n    const userSSK = userCrossSigning.keys.self_signing;\n\n    if (!userSSK) {\n      // if the user has no self-signing key then we cannot make any\n      // trust assertions about this device from cross-signing\n      return new DeviceTrustLevel(false, false, localTrust);\n    }\n\n    const deviceObj = deviceToObject(device, userCrossSigning.userId);\n\n    try {\n      // if we can verify the user's SSK from their master key...\n      (0, _olmlib.pkVerify)(userSSK, userCrossSigning.getId(), userCrossSigning.userId); // ...and this device's key from their SSK...\n\n      (0, _olmlib.pkVerify)(deviceObj, publicKeyFromKeyInfo(userSSK), userCrossSigning.userId); // ...then we trust this device as much as far as we trust the user\n\n      return DeviceTrustLevel.fromUserTrustLevel(userTrust, localTrust);\n    } catch (e) {\n      return new DeviceTrustLevel(false, false, localTrust);\n    }\n  }\n\n}\n\nexports.CrossSigningInfo = CrossSigningInfo;\n\nfunction deviceToObject(device, userId) {\n  return {\n    algorithms: device.algorithms,\n    keys: device.keys,\n    device_id: device.deviceId,\n    user_id: userId,\n    signatures: device.signatures\n  };\n}\n\nconst CrossSigningLevel = {\n  MASTER: 4,\n  USER_SIGNING: 2,\n  SELF_SIGNING: 1\n};\n/**\n * Represents the ways in which we trust a user\n */\n\nexports.CrossSigningLevel = CrossSigningLevel;\n\nclass UserTrustLevel {\n  constructor(crossSigningVerified, tofu) {\n    this._crossSigningVerified = crossSigningVerified;\n    this._tofu = tofu;\n  }\n  /**\n   * @returns {bool} true if this user is verified via any means\n   */\n\n\n  isVerified() {\n    return this.isCrossSigningVerified();\n  }\n  /**\n   * @returns {bool} true if this user is verified via cross signing\n   */\n\n\n  isCrossSigningVerified() {\n    return this._crossSigningVerified;\n  }\n  /**\n   * @returns {bool} true if this user's key is trusted on first use\n   */\n\n\n  isTofu() {\n    return this._tofu;\n  }\n\n}\n/**\n * Represents the ways in which we trust a device\n */\n\n\nexports.UserTrustLevel = UserTrustLevel;\n\nclass DeviceTrustLevel {\n  constructor(crossSigningVerified, tofu, localVerified) {\n    this._crossSigningVerified = crossSigningVerified;\n    this._tofu = tofu;\n    this._localVerified = localVerified;\n  }\n\n  static fromUserTrustLevel(userTrustLevel, localVerified) {\n    return new DeviceTrustLevel(userTrustLevel._crossSigningVerified, userTrustLevel._tofu, localVerified);\n  }\n  /**\n   * @returns {bool} true if this device is verified via any means\n   */\n\n\n  isVerified() {\n    return this.isCrossSigningVerified() || this.isLocallyVerified();\n  }\n  /**\n   * @returns {bool} true if this device is verified via cross signing\n   */\n\n\n  isCrossSigningVerified() {\n    return this._crossSigningVerified;\n  }\n  /**\n   * @returns {bool} true if this device is verified locally\n   */\n\n\n  isLocallyVerified() {\n    return this._localVerified;\n  }\n  /**\n   * @returns {bool} true if this device is trusted from a user's key\n   * that is trusted on first use\n   */\n\n\n  isTofu() {\n    return this._tofu;\n  }\n\n}\n\nexports.DeviceTrustLevel = DeviceTrustLevel;"]},"metadata":{},"sourceType":"script"}