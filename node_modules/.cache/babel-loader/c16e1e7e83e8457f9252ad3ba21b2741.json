{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LocalStorageCryptoStore = void 0;\n\nvar _logger = require(\"../../logger\");\n\nvar _memoryCryptoStore = require(\"./memory-crypto-store\");\n/*\nCopyright 2017, 2018 New Vector Ltd\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Internal module. Partial localStorage backed storage for e2e.\n * This is not a full crypto store, just the in-memory store with\n * some things backed by localStorage. It exists because indexedDB\n * is broken in Firefox private mode or set to, \"will not remember\n * history\".\n *\n * @module\n */\n\n\nconst E2E_PREFIX = \"crypto.\";\nconst KEY_END_TO_END_ACCOUNT = E2E_PREFIX + \"account\";\nconst KEY_CROSS_SIGNING_KEYS = E2E_PREFIX + \"cross_signing_keys\";\nconst KEY_NOTIFIED_ERROR_DEVICES = E2E_PREFIX + \"notified_error_devices\";\nconst KEY_DEVICE_DATA = E2E_PREFIX + \"device_data\";\nconst KEY_INBOUND_SESSION_PREFIX = E2E_PREFIX + \"inboundgroupsessions/\";\nconst KEY_INBOUND_SESSION_WITHHELD_PREFIX = E2E_PREFIX + \"inboundgroupsessions.withheld/\";\nconst KEY_ROOMS_PREFIX = E2E_PREFIX + \"rooms/\";\nconst KEY_SESSIONS_NEEDING_BACKUP = E2E_PREFIX + \"sessionsneedingbackup\";\n\nfunction keyEndToEndSessions(deviceKey) {\n  return E2E_PREFIX + \"sessions/\" + deviceKey;\n}\n\nfunction keyEndToEndSessionProblems(deviceKey) {\n  return E2E_PREFIX + \"session.problems/\" + deviceKey;\n}\n\nfunction keyEndToEndInboundGroupSession(senderKey, sessionId) {\n  return KEY_INBOUND_SESSION_PREFIX + senderKey + \"/\" + sessionId;\n}\n\nfunction keyEndToEndInboundGroupSessionWithheld(senderKey, sessionId) {\n  return KEY_INBOUND_SESSION_WITHHELD_PREFIX + senderKey + \"/\" + sessionId;\n}\n\nfunction keyEndToEndRoomsPrefix(roomId) {\n  return KEY_ROOMS_PREFIX + roomId;\n}\n/**\n * @implements {module:crypto/store/base~CryptoStore}\n */\n\n\nclass LocalStorageCryptoStore extends _memoryCryptoStore.MemoryCryptoStore {\n  constructor(webStore) {\n    super();\n    this.store = webStore;\n  }\n\n  static exists(webStore) {\n    const length = webStore.length;\n\n    for (let i = 0; i < length; i++) {\n      if (webStore.key(i).startsWith(E2E_PREFIX)) {\n        return true;\n      }\n    }\n\n    return false;\n  } // Olm Sessions\n\n\n  countEndToEndSessions(txn, func) {\n    let count = 0;\n\n    for (let i = 0; i < this.store.length; ++i) {\n      if (this.store.key(i).startsWith(keyEndToEndSessions(''))) ++count;\n    }\n\n    func(count);\n  }\n\n  _getEndToEndSessions(deviceKey, txn, func) {\n    const sessions = getJsonItem(this.store, keyEndToEndSessions(deviceKey));\n    const fixedSessions = {}; // fix up any old sessions to be objects rather than just the base64 pickle\n\n    for (const [sid, val] of Object.entries(sessions || {})) {\n      if (typeof val === 'string') {\n        fixedSessions[sid] = {\n          session: val\n        };\n      } else {\n        fixedSessions[sid] = val;\n      }\n    }\n\n    return fixedSessions;\n  }\n\n  getEndToEndSession(deviceKey, sessionId, txn, func) {\n    const sessions = this._getEndToEndSessions(deviceKey);\n\n    func(sessions[sessionId] || {});\n  }\n\n  getEndToEndSessions(deviceKey, txn, func) {\n    func(this._getEndToEndSessions(deviceKey) || {});\n  }\n\n  getAllEndToEndSessions(txn, func) {\n    for (let i = 0; i < this.store.length; ++i) {\n      if (this.store.key(i).startsWith(keyEndToEndSessions(''))) {\n        const deviceKey = this.store.key(i).split('/')[1];\n\n        for (const sess of Object.values(this._getEndToEndSessions(deviceKey))) {\n          func(sess);\n        }\n      }\n    }\n  }\n\n  storeEndToEndSession(deviceKey, sessionId, sessionInfo, txn) {\n    const sessions = this._getEndToEndSessions(deviceKey) || {};\n    sessions[sessionId] = sessionInfo;\n    setJsonItem(this.store, keyEndToEndSessions(deviceKey), sessions);\n  }\n\n  async storeEndToEndSessionProblem(deviceKey, type, fixed) {\n    const key = keyEndToEndSessionProblems(deviceKey);\n    const problems = getJsonItem(this.store, key) || [];\n    problems.push({\n      type,\n      fixed,\n      time: Date.now()\n    });\n    problems.sort((a, b) => {\n      return a.time - b.time;\n    });\n    setJsonItem(this.store, key, problems);\n  }\n\n  async getEndToEndSessionProblem(deviceKey, timestamp) {\n    const key = keyEndToEndSessionProblems(deviceKey);\n    const problems = getJsonItem(this.store, key) || [];\n\n    if (!problems.length) {\n      return null;\n    }\n\n    const lastProblem = problems[problems.length - 1];\n\n    for (const problem of problems) {\n      if (problem.time > timestamp) {\n        return Object.assign({}, problem, {\n          fixed: lastProblem.fixed\n        });\n      }\n    }\n\n    if (lastProblem.fixed) {\n      return null;\n    } else {\n      return lastProblem;\n    }\n  }\n\n  async filterOutNotifiedErrorDevices(devices) {\n    const notifiedErrorDevices = getJsonItem(this.store, KEY_NOTIFIED_ERROR_DEVICES) || {};\n    const ret = [];\n\n    for (const device of devices) {\n      const {\n        userId,\n        deviceInfo\n      } = device;\n\n      if (userId in notifiedErrorDevices) {\n        if (!(deviceInfo.deviceId in notifiedErrorDevices[userId])) {\n          ret.push(device);\n          notifiedErrorDevices[userId][deviceInfo.deviceId] = true;\n        }\n      } else {\n        ret.push(device);\n        notifiedErrorDevices[userId] = {\n          [deviceInfo.deviceId]: true\n        };\n      }\n    }\n\n    setJsonItem(this.store, KEY_NOTIFIED_ERROR_DEVICES, notifiedErrorDevices);\n    return ret;\n  } // Inbound Group Sessions\n\n\n  getEndToEndInboundGroupSession(senderCurve25519Key, sessionId, txn, func) {\n    func(getJsonItem(this.store, keyEndToEndInboundGroupSession(senderCurve25519Key, sessionId)), getJsonItem(this.store, keyEndToEndInboundGroupSessionWithheld(senderCurve25519Key, sessionId)));\n  }\n\n  getAllEndToEndInboundGroupSessions(txn, func) {\n    for (let i = 0; i < this.store.length; ++i) {\n      const key = this.store.key(i);\n\n      if (key.startsWith(KEY_INBOUND_SESSION_PREFIX)) {\n        // we can't use split, as the components we are trying to split out\n        // might themselves contain '/' characters. We rely on the\n        // senderKey being a (32-byte) curve25519 key, base64-encoded\n        // (hence 43 characters long).\n        func({\n          senderKey: key.substr(KEY_INBOUND_SESSION_PREFIX.length, 43),\n          sessionId: key.substr(KEY_INBOUND_SESSION_PREFIX.length + 44),\n          sessionData: getJsonItem(this.store, key)\n        });\n      }\n    }\n\n    func(null);\n  }\n\n  addEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {\n    const existing = getJsonItem(this.store, keyEndToEndInboundGroupSession(senderCurve25519Key, sessionId));\n\n    if (!existing) {\n      this.storeEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn);\n    }\n  }\n\n  storeEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {\n    setJsonItem(this.store, keyEndToEndInboundGroupSession(senderCurve25519Key, sessionId), sessionData);\n  }\n\n  storeEndToEndInboundGroupSessionWithheld(senderCurve25519Key, sessionId, sessionData, txn) {\n    setJsonItem(this.store, keyEndToEndInboundGroupSessionWithheld(senderCurve25519Key, sessionId), sessionData);\n  }\n\n  getEndToEndDeviceData(txn, func) {\n    func(getJsonItem(this.store, KEY_DEVICE_DATA));\n  }\n\n  storeEndToEndDeviceData(deviceData, txn) {\n    setJsonItem(this.store, KEY_DEVICE_DATA, deviceData);\n  }\n\n  storeEndToEndRoom(roomId, roomInfo, txn) {\n    setJsonItem(this.store, keyEndToEndRoomsPrefix(roomId), roomInfo);\n  }\n\n  getEndToEndRooms(txn, func) {\n    const result = {};\n    const prefix = keyEndToEndRoomsPrefix('');\n\n    for (let i = 0; i < this.store.length; ++i) {\n      const key = this.store.key(i);\n\n      if (key.startsWith(prefix)) {\n        const roomId = key.substr(prefix.length);\n        result[roomId] = getJsonItem(this.store, key);\n      }\n    }\n\n    func(result);\n  }\n\n  getSessionsNeedingBackup(limit) {\n    const sessionsNeedingBackup = getJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP) || {};\n    const sessions = [];\n\n    for (const session in sessionsNeedingBackup) {\n      if (Object.prototype.hasOwnProperty.call(sessionsNeedingBackup, session)) {\n        // see getAllEndToEndInboundGroupSessions for the magic number explanations\n        const senderKey = session.substr(0, 43);\n        const sessionId = session.substr(44);\n        this.getEndToEndInboundGroupSession(senderKey, sessionId, null, sessionData => {\n          sessions.push({\n            senderKey: senderKey,\n            sessionId: sessionId,\n            sessionData: sessionData\n          });\n        });\n\n        if (limit && session.length >= limit) {\n          break;\n        }\n      }\n    }\n\n    return Promise.resolve(sessions);\n  }\n\n  countSessionsNeedingBackup() {\n    const sessionsNeedingBackup = getJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP) || {};\n    return Promise.resolve(Object.keys(sessionsNeedingBackup).length);\n  }\n\n  unmarkSessionsNeedingBackup(sessions) {\n    const sessionsNeedingBackup = getJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP) || {};\n\n    for (const session of sessions) {\n      delete sessionsNeedingBackup[session.senderKey + '/' + session.sessionId];\n    }\n\n    setJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP, sessionsNeedingBackup);\n    return Promise.resolve();\n  }\n\n  markSessionsNeedingBackup(sessions) {\n    const sessionsNeedingBackup = getJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP) || {};\n\n    for (const session of sessions) {\n      sessionsNeedingBackup[session.senderKey + '/' + session.sessionId] = true;\n    }\n\n    setJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP, sessionsNeedingBackup);\n    return Promise.resolve();\n  }\n  /**\n   * Delete all data from this store.\n   *\n   * @returns {Promise} Promise which resolves when the store has been cleared.\n   */\n\n\n  deleteAllData() {\n    this.store.removeItem(KEY_END_TO_END_ACCOUNT);\n    return Promise.resolve();\n  } // Olm account\n\n\n  getAccount(txn, func) {\n    const account = getJsonItem(this.store, KEY_END_TO_END_ACCOUNT);\n    func(account);\n  }\n\n  storeAccount(txn, newData) {\n    setJsonItem(this.store, KEY_END_TO_END_ACCOUNT, newData);\n  }\n\n  getCrossSigningKeys(txn, func) {\n    const keys = getJsonItem(this.store, KEY_CROSS_SIGNING_KEYS);\n    func(keys);\n  }\n\n  storeCrossSigningKeys(txn, keys) {\n    setJsonItem(this.store, KEY_CROSS_SIGNING_KEYS, keys);\n  }\n\n  doTxn(mode, stores, func) {\n    return Promise.resolve(func(null));\n  }\n\n}\n\nexports.LocalStorageCryptoStore = LocalStorageCryptoStore;\n\nfunction getJsonItem(store, key) {\n  try {\n    // if the key is absent, store.getItem() returns null, and\n    // JSON.parse(null) === null, so this returns null.\n    return JSON.parse(store.getItem(key));\n  } catch (e) {\n    _logger.logger.log(\"Error: Failed to get key %s: %s\", key, e.stack || e);\n\n    _logger.logger.log(e.stack);\n  }\n\n  return null;\n}\n\nfunction setJsonItem(store, key, val) {\n  store.setItem(key, JSON.stringify(val));\n}","map":{"version":3,"sources":["/home/kimist/Developpement/React/watcha_client/node_modules/matrix-js-sdk/lib/crypto/store/localStorage-crypto-store.js"],"names":["Object","defineProperty","exports","value","LocalStorageCryptoStore","_logger","require","_memoryCryptoStore","E2E_PREFIX","KEY_END_TO_END_ACCOUNT","KEY_CROSS_SIGNING_KEYS","KEY_NOTIFIED_ERROR_DEVICES","KEY_DEVICE_DATA","KEY_INBOUND_SESSION_PREFIX","KEY_INBOUND_SESSION_WITHHELD_PREFIX","KEY_ROOMS_PREFIX","KEY_SESSIONS_NEEDING_BACKUP","keyEndToEndSessions","deviceKey","keyEndToEndSessionProblems","keyEndToEndInboundGroupSession","senderKey","sessionId","keyEndToEndInboundGroupSessionWithheld","keyEndToEndRoomsPrefix","roomId","MemoryCryptoStore","constructor","webStore","store","exists","length","i","key","startsWith","countEndToEndSessions","txn","func","count","_getEndToEndSessions","sessions","getJsonItem","fixedSessions","sid","val","entries","session","getEndToEndSession","getEndToEndSessions","getAllEndToEndSessions","split","sess","values","storeEndToEndSession","sessionInfo","setJsonItem","storeEndToEndSessionProblem","type","fixed","problems","push","time","Date","now","sort","a","b","getEndToEndSessionProblem","timestamp","lastProblem","problem","assign","filterOutNotifiedErrorDevices","devices","notifiedErrorDevices","ret","device","userId","deviceInfo","deviceId","getEndToEndInboundGroupSession","senderCurve25519Key","getAllEndToEndInboundGroupSessions","substr","sessionData","addEndToEndInboundGroupSession","existing","storeEndToEndInboundGroupSession","storeEndToEndInboundGroupSessionWithheld","getEndToEndDeviceData","storeEndToEndDeviceData","deviceData","storeEndToEndRoom","roomInfo","getEndToEndRooms","result","prefix","getSessionsNeedingBackup","limit","sessionsNeedingBackup","prototype","hasOwnProperty","call","Promise","resolve","countSessionsNeedingBackup","keys","unmarkSessionsNeedingBackup","markSessionsNeedingBackup","deleteAllData","removeItem","getAccount","account","storeAccount","newData","getCrossSigningKeys","storeCrossSigningKeys","doTxn","mode","stores","JSON","parse","getItem","e","logger","log","stack","setItem","stringify"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LocalStorageCryptoStore = void 0;\n\nvar _logger = require(\"../../logger\");\n\nvar _memoryCryptoStore = require(\"./memory-crypto-store\");\n\n/*\nCopyright 2017, 2018 New Vector Ltd\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Internal module. Partial localStorage backed storage for e2e.\n * This is not a full crypto store, just the in-memory store with\n * some things backed by localStorage. It exists because indexedDB\n * is broken in Firefox private mode or set to, \"will not remember\n * history\".\n *\n * @module\n */\nconst E2E_PREFIX = \"crypto.\";\nconst KEY_END_TO_END_ACCOUNT = E2E_PREFIX + \"account\";\nconst KEY_CROSS_SIGNING_KEYS = E2E_PREFIX + \"cross_signing_keys\";\nconst KEY_NOTIFIED_ERROR_DEVICES = E2E_PREFIX + \"notified_error_devices\";\nconst KEY_DEVICE_DATA = E2E_PREFIX + \"device_data\";\nconst KEY_INBOUND_SESSION_PREFIX = E2E_PREFIX + \"inboundgroupsessions/\";\nconst KEY_INBOUND_SESSION_WITHHELD_PREFIX = E2E_PREFIX + \"inboundgroupsessions.withheld/\";\nconst KEY_ROOMS_PREFIX = E2E_PREFIX + \"rooms/\";\nconst KEY_SESSIONS_NEEDING_BACKUP = E2E_PREFIX + \"sessionsneedingbackup\";\n\nfunction keyEndToEndSessions(deviceKey) {\n  return E2E_PREFIX + \"sessions/\" + deviceKey;\n}\n\nfunction keyEndToEndSessionProblems(deviceKey) {\n  return E2E_PREFIX + \"session.problems/\" + deviceKey;\n}\n\nfunction keyEndToEndInboundGroupSession(senderKey, sessionId) {\n  return KEY_INBOUND_SESSION_PREFIX + senderKey + \"/\" + sessionId;\n}\n\nfunction keyEndToEndInboundGroupSessionWithheld(senderKey, sessionId) {\n  return KEY_INBOUND_SESSION_WITHHELD_PREFIX + senderKey + \"/\" + sessionId;\n}\n\nfunction keyEndToEndRoomsPrefix(roomId) {\n  return KEY_ROOMS_PREFIX + roomId;\n}\n/**\n * @implements {module:crypto/store/base~CryptoStore}\n */\n\n\nclass LocalStorageCryptoStore extends _memoryCryptoStore.MemoryCryptoStore {\n  constructor(webStore) {\n    super();\n    this.store = webStore;\n  }\n\n  static exists(webStore) {\n    const length = webStore.length;\n\n    for (let i = 0; i < length; i++) {\n      if (webStore.key(i).startsWith(E2E_PREFIX)) {\n        return true;\n      }\n    }\n\n    return false;\n  } // Olm Sessions\n\n\n  countEndToEndSessions(txn, func) {\n    let count = 0;\n\n    for (let i = 0; i < this.store.length; ++i) {\n      if (this.store.key(i).startsWith(keyEndToEndSessions(''))) ++count;\n    }\n\n    func(count);\n  }\n\n  _getEndToEndSessions(deviceKey, txn, func) {\n    const sessions = getJsonItem(this.store, keyEndToEndSessions(deviceKey));\n    const fixedSessions = {}; // fix up any old sessions to be objects rather than just the base64 pickle\n\n    for (const [sid, val] of Object.entries(sessions || {})) {\n      if (typeof val === 'string') {\n        fixedSessions[sid] = {\n          session: val\n        };\n      } else {\n        fixedSessions[sid] = val;\n      }\n    }\n\n    return fixedSessions;\n  }\n\n  getEndToEndSession(deviceKey, sessionId, txn, func) {\n    const sessions = this._getEndToEndSessions(deviceKey);\n\n    func(sessions[sessionId] || {});\n  }\n\n  getEndToEndSessions(deviceKey, txn, func) {\n    func(this._getEndToEndSessions(deviceKey) || {});\n  }\n\n  getAllEndToEndSessions(txn, func) {\n    for (let i = 0; i < this.store.length; ++i) {\n      if (this.store.key(i).startsWith(keyEndToEndSessions(''))) {\n        const deviceKey = this.store.key(i).split('/')[1];\n\n        for (const sess of Object.values(this._getEndToEndSessions(deviceKey))) {\n          func(sess);\n        }\n      }\n    }\n  }\n\n  storeEndToEndSession(deviceKey, sessionId, sessionInfo, txn) {\n    const sessions = this._getEndToEndSessions(deviceKey) || {};\n    sessions[sessionId] = sessionInfo;\n    setJsonItem(this.store, keyEndToEndSessions(deviceKey), sessions);\n  }\n\n  async storeEndToEndSessionProblem(deviceKey, type, fixed) {\n    const key = keyEndToEndSessionProblems(deviceKey);\n    const problems = getJsonItem(this.store, key) || [];\n    problems.push({\n      type,\n      fixed,\n      time: Date.now()\n    });\n    problems.sort((a, b) => {\n      return a.time - b.time;\n    });\n    setJsonItem(this.store, key, problems);\n  }\n\n  async getEndToEndSessionProblem(deviceKey, timestamp) {\n    const key = keyEndToEndSessionProblems(deviceKey);\n    const problems = getJsonItem(this.store, key) || [];\n\n    if (!problems.length) {\n      return null;\n    }\n\n    const lastProblem = problems[problems.length - 1];\n\n    for (const problem of problems) {\n      if (problem.time > timestamp) {\n        return Object.assign({}, problem, {\n          fixed: lastProblem.fixed\n        });\n      }\n    }\n\n    if (lastProblem.fixed) {\n      return null;\n    } else {\n      return lastProblem;\n    }\n  }\n\n  async filterOutNotifiedErrorDevices(devices) {\n    const notifiedErrorDevices = getJsonItem(this.store, KEY_NOTIFIED_ERROR_DEVICES) || {};\n    const ret = [];\n\n    for (const device of devices) {\n      const {\n        userId,\n        deviceInfo\n      } = device;\n\n      if (userId in notifiedErrorDevices) {\n        if (!(deviceInfo.deviceId in notifiedErrorDevices[userId])) {\n          ret.push(device);\n          notifiedErrorDevices[userId][deviceInfo.deviceId] = true;\n        }\n      } else {\n        ret.push(device);\n        notifiedErrorDevices[userId] = {\n          [deviceInfo.deviceId]: true\n        };\n      }\n    }\n\n    setJsonItem(this.store, KEY_NOTIFIED_ERROR_DEVICES, notifiedErrorDevices);\n    return ret;\n  } // Inbound Group Sessions\n\n\n  getEndToEndInboundGroupSession(senderCurve25519Key, sessionId, txn, func) {\n    func(getJsonItem(this.store, keyEndToEndInboundGroupSession(senderCurve25519Key, sessionId)), getJsonItem(this.store, keyEndToEndInboundGroupSessionWithheld(senderCurve25519Key, sessionId)));\n  }\n\n  getAllEndToEndInboundGroupSessions(txn, func) {\n    for (let i = 0; i < this.store.length; ++i) {\n      const key = this.store.key(i);\n\n      if (key.startsWith(KEY_INBOUND_SESSION_PREFIX)) {\n        // we can't use split, as the components we are trying to split out\n        // might themselves contain '/' characters. We rely on the\n        // senderKey being a (32-byte) curve25519 key, base64-encoded\n        // (hence 43 characters long).\n        func({\n          senderKey: key.substr(KEY_INBOUND_SESSION_PREFIX.length, 43),\n          sessionId: key.substr(KEY_INBOUND_SESSION_PREFIX.length + 44),\n          sessionData: getJsonItem(this.store, key)\n        });\n      }\n    }\n\n    func(null);\n  }\n\n  addEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {\n    const existing = getJsonItem(this.store, keyEndToEndInboundGroupSession(senderCurve25519Key, sessionId));\n\n    if (!existing) {\n      this.storeEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn);\n    }\n  }\n\n  storeEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {\n    setJsonItem(this.store, keyEndToEndInboundGroupSession(senderCurve25519Key, sessionId), sessionData);\n  }\n\n  storeEndToEndInboundGroupSessionWithheld(senderCurve25519Key, sessionId, sessionData, txn) {\n    setJsonItem(this.store, keyEndToEndInboundGroupSessionWithheld(senderCurve25519Key, sessionId), sessionData);\n  }\n\n  getEndToEndDeviceData(txn, func) {\n    func(getJsonItem(this.store, KEY_DEVICE_DATA));\n  }\n\n  storeEndToEndDeviceData(deviceData, txn) {\n    setJsonItem(this.store, KEY_DEVICE_DATA, deviceData);\n  }\n\n  storeEndToEndRoom(roomId, roomInfo, txn) {\n    setJsonItem(this.store, keyEndToEndRoomsPrefix(roomId), roomInfo);\n  }\n\n  getEndToEndRooms(txn, func) {\n    const result = {};\n    const prefix = keyEndToEndRoomsPrefix('');\n\n    for (let i = 0; i < this.store.length; ++i) {\n      const key = this.store.key(i);\n\n      if (key.startsWith(prefix)) {\n        const roomId = key.substr(prefix.length);\n        result[roomId] = getJsonItem(this.store, key);\n      }\n    }\n\n    func(result);\n  }\n\n  getSessionsNeedingBackup(limit) {\n    const sessionsNeedingBackup = getJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP) || {};\n    const sessions = [];\n\n    for (const session in sessionsNeedingBackup) {\n      if (Object.prototype.hasOwnProperty.call(sessionsNeedingBackup, session)) {\n        // see getAllEndToEndInboundGroupSessions for the magic number explanations\n        const senderKey = session.substr(0, 43);\n        const sessionId = session.substr(44);\n        this.getEndToEndInboundGroupSession(senderKey, sessionId, null, sessionData => {\n          sessions.push({\n            senderKey: senderKey,\n            sessionId: sessionId,\n            sessionData: sessionData\n          });\n        });\n\n        if (limit && session.length >= limit) {\n          break;\n        }\n      }\n    }\n\n    return Promise.resolve(sessions);\n  }\n\n  countSessionsNeedingBackup() {\n    const sessionsNeedingBackup = getJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP) || {};\n    return Promise.resolve(Object.keys(sessionsNeedingBackup).length);\n  }\n\n  unmarkSessionsNeedingBackup(sessions) {\n    const sessionsNeedingBackup = getJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP) || {};\n\n    for (const session of sessions) {\n      delete sessionsNeedingBackup[session.senderKey + '/' + session.sessionId];\n    }\n\n    setJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP, sessionsNeedingBackup);\n    return Promise.resolve();\n  }\n\n  markSessionsNeedingBackup(sessions) {\n    const sessionsNeedingBackup = getJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP) || {};\n\n    for (const session of sessions) {\n      sessionsNeedingBackup[session.senderKey + '/' + session.sessionId] = true;\n    }\n\n    setJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP, sessionsNeedingBackup);\n    return Promise.resolve();\n  }\n  /**\n   * Delete all data from this store.\n   *\n   * @returns {Promise} Promise which resolves when the store has been cleared.\n   */\n\n\n  deleteAllData() {\n    this.store.removeItem(KEY_END_TO_END_ACCOUNT);\n    return Promise.resolve();\n  } // Olm account\n\n\n  getAccount(txn, func) {\n    const account = getJsonItem(this.store, KEY_END_TO_END_ACCOUNT);\n    func(account);\n  }\n\n  storeAccount(txn, newData) {\n    setJsonItem(this.store, KEY_END_TO_END_ACCOUNT, newData);\n  }\n\n  getCrossSigningKeys(txn, func) {\n    const keys = getJsonItem(this.store, KEY_CROSS_SIGNING_KEYS);\n    func(keys);\n  }\n\n  storeCrossSigningKeys(txn, keys) {\n    setJsonItem(this.store, KEY_CROSS_SIGNING_KEYS, keys);\n  }\n\n  doTxn(mode, stores, func) {\n    return Promise.resolve(func(null));\n  }\n\n}\n\nexports.LocalStorageCryptoStore = LocalStorageCryptoStore;\n\nfunction getJsonItem(store, key) {\n  try {\n    // if the key is absent, store.getItem() returns null, and\n    // JSON.parse(null) === null, so this returns null.\n    return JSON.parse(store.getItem(key));\n  } catch (e) {\n    _logger.logger.log(\"Error: Failed to get key %s: %s\", key, e.stack || e);\n\n    _logger.logger.log(e.stack);\n  }\n\n  return null;\n}\n\nfunction setJsonItem(store, key, val) {\n  store.setItem(key, JSON.stringify(val));\n}"]},"metadata":{},"sourceType":"script"}