{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ToDeviceChannel = void 0;\n\nvar _randomstring = require(\"../../../randomstring\");\n\nvar _logger = require(\"../../../logger\");\n\nvar _VerificationRequest = require(\"./VerificationRequest\");\n\nvar _Error = require(\"../Error\");\n/*\nCopyright 2018 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * A key verification channel that sends verification events over to_device messages.\n * Generates its own transaction ids.\n */\n\n\nclass ToDeviceChannel {\n  // userId and devices of user we're about to verify\n  constructor(client, userId, devices, transactionId = null, deviceId = null) {\n    this._client = client;\n    this._userId = userId;\n    this._devices = devices;\n    this.transactionId = transactionId;\n    this._deviceId = deviceId;\n  }\n\n  static getEventType(event) {\n    return event.getType();\n  }\n  /**\n   * Extract the transaction id used by a given key verification event, if any\n   * @param {MatrixEvent} event the event\n   * @returns {string} the transaction id\n   */\n\n\n  static getTransactionId(event) {\n    const content = event.getContent();\n    return content && content.transaction_id;\n  }\n  /**\n   * Checks whether the given event type should be allowed to initiate a new VerificationRequest over this channel\n   * @param {string} type the event type to check\n   * @returns {bool} boolean flag\n   */\n\n\n  static canCreateRequest(type) {\n    return type === _VerificationRequest.REQUEST_TYPE || type === _VerificationRequest.START_TYPE;\n  }\n  /**\n   * Checks whether this event is a well-formed key verification event.\n   * This only does checks that don't rely on the current state of a potentially already channel\n   * so we can prevent channels being created by invalid events.\n   * `handleEvent` can do more checks and choose to ignore invalid events.\n   * @param {MatrixEvent} event the event to validate\n   * @param {MatrixClient} client the client to get the current user and device id from\n   * @returns {bool} whether the event is valid and should be passed to handleEvent\n   */\n\n\n  static validateEvent(event, client) {\n    if (event.isCancelled()) {\n      _logger.logger.warn(\"Ignoring flagged verification request from \" + event.getSender());\n\n      return false;\n    }\n\n    const content = event.getContent();\n\n    if (!content) {\n      return false;\n    }\n\n    if (!content.transaction_id) {\n      return false;\n    }\n\n    const type = event.getType();\n\n    if (type === _VerificationRequest.REQUEST_TYPE) {\n      if (!Number.isFinite(content.timestamp)) {\n        return false;\n      }\n\n      if (event.getSender() === client.getUserId() && content.from_device == client.getDeviceId()) {\n        // ignore requests from ourselves, because it doesn't make sense for a\n        // device to verify itself\n        return false;\n      }\n    }\n\n    return _VerificationRequest.VerificationRequest.validateEvent(type, event, ToDeviceChannel.getTimestamp(event), client);\n  }\n  /**\n   * @param {MatrixEvent} event the event to get the timestamp of\n   * @return {number} the timestamp when the event was sent\n   */\n\n\n  static getTimestamp(event) {\n    const content = event.getContent();\n    return content && content.timestamp;\n  }\n  /**\n   * Changes the state of the channel, request, and verifier in response to a key verification event.\n   * @param {MatrixEvent} event to handle\n   * @param {VerificationRequest} request the request to forward handling to\n   * @returns {Promise} a promise that resolves when any requests as an anwser to the passed-in event are sent.\n   */\n\n\n  async handleEvent(event, request) {\n    const type = event.getType();\n    const content = event.getContent();\n\n    if (type === _VerificationRequest.REQUEST_TYPE || type === _VerificationRequest.START_TYPE) {\n      if (!this.transactionId) {\n        this.transactionId = content.transaction_id;\n      }\n\n      const deviceId = content.from_device; // adopt deviceId if not set before and valid\n\n      if (!this._deviceId && this._devices.includes(deviceId)) {\n        this._deviceId = deviceId;\n      } // if no device id or different from addopted one, cancel with sender\n\n\n      if (!this._deviceId || this._deviceId !== deviceId) {\n        // also check that message came from the device we sent the request to earlier on\n        // and do send a cancel message to that device\n        // (but don't cancel the request for the device we should be talking to)\n        const cancelContent = this.completeContent((0, _Error.errorFromEvent)((0, _Error.newUnexpectedMessageError)()));\n        return this._sendToDevices(_VerificationRequest.CANCEL_TYPE, cancelContent, [deviceId]);\n      }\n    }\n\n    const wasStarted = request.phase === _VerificationRequest.PHASE_STARTED;\n    await request.handleEvent(event.getType(), event, ToDeviceChannel.getTimestamp(event));\n    const isStarted = request.phase === _VerificationRequest.PHASE_STARTED; // the request has picked a start event, tell the other devices about it\n\n    if (type === _VerificationRequest.START_TYPE && !wasStarted && isStarted && this._deviceId) {\n      const nonChosenDevices = this._devices.filter(d => d !== this._deviceId);\n\n      if (nonChosenDevices.length) {\n        const message = this.completeContent({\n          code: \"m.accepted\",\n          reason: \"Verification request accepted by another device\"\n        });\n        await this._sendToDevices(_VerificationRequest.CANCEL_TYPE, message, nonChosenDevices);\n      }\n    }\n  }\n  /**\n   * See {InRoomChannel.completedContentFromEvent} why this is needed.\n   * @param {MatrixEvent} event the received event\n   * @returns {Object} the content object\n   */\n\n\n  completedContentFromEvent(event) {\n    return event.getContent();\n  }\n  /**\n   * Add all the fields to content needed for sending it over this channel.\n   * This is public so verification methods (SAS uses this) can get the exact\n   * content that will be sent independent of the used channel,\n   * as they need to calculate the hash of it.\n   * @param {string} type the event type\n   * @param {object} content the (incomplete) content\n   * @returns {object} the complete content, as it will be sent.\n   */\n\n\n  completeContent(type, content) {\n    // make a copy\n    content = Object.assign({}, content);\n\n    if (this.transactionId) {\n      content.transaction_id = this.transactionId;\n    }\n\n    if (type === _VerificationRequest.REQUEST_TYPE || type === _VerificationRequest.START_TYPE) {\n      content.from_device = this._client.getDeviceId();\n    }\n\n    if (type === _VerificationRequest.REQUEST_TYPE) {\n      content.timestamp = Date.now();\n    }\n\n    return content;\n  }\n  /**\n   * Send an event over the channel with the content not having gone through `completeContent`.\n   * @param {string} type the event type\n   * @param {object} uncompletedContent the (incomplete) content\n   * @returns {Promise} the promise of the request\n   */\n\n\n  send(type, uncompletedContent = {}) {\n    // create transaction id when sending request\n    if ((type === _VerificationRequest.REQUEST_TYPE || type === _VerificationRequest.START_TYPE) && !this.transactionId) {\n      this.transactionId = ToDeviceChannel.makeTransactionId();\n    }\n\n    const content = this.completeContent(type, uncompletedContent);\n    return this.sendCompleted(type, content);\n  }\n  /**\n   * Send an event over the channel with the content having gone through `completeContent` already.\n   * @param {string} type the event type\n   * @param {object} content\n   * @returns {Promise} the promise of the request\n   */\n\n\n  sendCompleted(type, content) {\n    if (type === _VerificationRequest.REQUEST_TYPE) {\n      return this._sendToDevices(type, content, this._devices);\n    } else {\n      return this._sendToDevices(type, content, [this._deviceId]);\n    }\n  }\n\n  _sendToDevices(type, content, devices) {\n    if (devices.length) {\n      const msgMap = {};\n\n      for (const deviceId of devices) {\n        msgMap[deviceId] = content;\n      }\n\n      return this._client.sendToDevice(type, {\n        [this._userId]: msgMap\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n  /**\n   * Allow Crypto module to create and know the transaction id before the .start event gets sent.\n   * @returns {string} the transaction id\n   */\n\n\n  static makeTransactionId() {\n    return (0, _randomstring.randomString)(32);\n  }\n\n}\n\nexports.ToDeviceChannel = ToDeviceChannel;","map":{"version":3,"sources":["/home/kimist/Developpement/React/watcha_client/node_modules/matrix-js-sdk/lib/crypto/verification/request/ToDeviceChannel.js"],"names":["Object","defineProperty","exports","value","ToDeviceChannel","_randomstring","require","_logger","_VerificationRequest","_Error","constructor","client","userId","devices","transactionId","deviceId","_client","_userId","_devices","_deviceId","getEventType","event","getType","getTransactionId","content","getContent","transaction_id","canCreateRequest","type","REQUEST_TYPE","START_TYPE","validateEvent","isCancelled","logger","warn","getSender","Number","isFinite","timestamp","getUserId","from_device","getDeviceId","VerificationRequest","getTimestamp","handleEvent","request","includes","cancelContent","completeContent","errorFromEvent","newUnexpectedMessageError","_sendToDevices","CANCEL_TYPE","wasStarted","phase","PHASE_STARTED","isStarted","nonChosenDevices","filter","d","length","message","code","reason","completedContentFromEvent","assign","Date","now","send","uncompletedContent","makeTransactionId","sendCompleted","msgMap","sendToDevice","Promise","resolve","randomString"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ToDeviceChannel = void 0;\n\nvar _randomstring = require(\"../../../randomstring\");\n\nvar _logger = require(\"../../../logger\");\n\nvar _VerificationRequest = require(\"./VerificationRequest\");\n\nvar _Error = require(\"../Error\");\n\n/*\nCopyright 2018 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * A key verification channel that sends verification events over to_device messages.\n * Generates its own transaction ids.\n */\nclass ToDeviceChannel {\n  // userId and devices of user we're about to verify\n  constructor(client, userId, devices, transactionId = null, deviceId = null) {\n    this._client = client;\n    this._userId = userId;\n    this._devices = devices;\n    this.transactionId = transactionId;\n    this._deviceId = deviceId;\n  }\n\n  static getEventType(event) {\n    return event.getType();\n  }\n  /**\n   * Extract the transaction id used by a given key verification event, if any\n   * @param {MatrixEvent} event the event\n   * @returns {string} the transaction id\n   */\n\n\n  static getTransactionId(event) {\n    const content = event.getContent();\n    return content && content.transaction_id;\n  }\n  /**\n   * Checks whether the given event type should be allowed to initiate a new VerificationRequest over this channel\n   * @param {string} type the event type to check\n   * @returns {bool} boolean flag\n   */\n\n\n  static canCreateRequest(type) {\n    return type === _VerificationRequest.REQUEST_TYPE || type === _VerificationRequest.START_TYPE;\n  }\n  /**\n   * Checks whether this event is a well-formed key verification event.\n   * This only does checks that don't rely on the current state of a potentially already channel\n   * so we can prevent channels being created by invalid events.\n   * `handleEvent` can do more checks and choose to ignore invalid events.\n   * @param {MatrixEvent} event the event to validate\n   * @param {MatrixClient} client the client to get the current user and device id from\n   * @returns {bool} whether the event is valid and should be passed to handleEvent\n   */\n\n\n  static validateEvent(event, client) {\n    if (event.isCancelled()) {\n      _logger.logger.warn(\"Ignoring flagged verification request from \" + event.getSender());\n\n      return false;\n    }\n\n    const content = event.getContent();\n\n    if (!content) {\n      return false;\n    }\n\n    if (!content.transaction_id) {\n      return false;\n    }\n\n    const type = event.getType();\n\n    if (type === _VerificationRequest.REQUEST_TYPE) {\n      if (!Number.isFinite(content.timestamp)) {\n        return false;\n      }\n\n      if (event.getSender() === client.getUserId() && content.from_device == client.getDeviceId()) {\n        // ignore requests from ourselves, because it doesn't make sense for a\n        // device to verify itself\n        return false;\n      }\n    }\n\n    return _VerificationRequest.VerificationRequest.validateEvent(type, event, ToDeviceChannel.getTimestamp(event), client);\n  }\n  /**\n   * @param {MatrixEvent} event the event to get the timestamp of\n   * @return {number} the timestamp when the event was sent\n   */\n\n\n  static getTimestamp(event) {\n    const content = event.getContent();\n    return content && content.timestamp;\n  }\n  /**\n   * Changes the state of the channel, request, and verifier in response to a key verification event.\n   * @param {MatrixEvent} event to handle\n   * @param {VerificationRequest} request the request to forward handling to\n   * @returns {Promise} a promise that resolves when any requests as an anwser to the passed-in event are sent.\n   */\n\n\n  async handleEvent(event, request) {\n    const type = event.getType();\n    const content = event.getContent();\n\n    if (type === _VerificationRequest.REQUEST_TYPE || type === _VerificationRequest.START_TYPE) {\n      if (!this.transactionId) {\n        this.transactionId = content.transaction_id;\n      }\n\n      const deviceId = content.from_device; // adopt deviceId if not set before and valid\n\n      if (!this._deviceId && this._devices.includes(deviceId)) {\n        this._deviceId = deviceId;\n      } // if no device id or different from addopted one, cancel with sender\n\n\n      if (!this._deviceId || this._deviceId !== deviceId) {\n        // also check that message came from the device we sent the request to earlier on\n        // and do send a cancel message to that device\n        // (but don't cancel the request for the device we should be talking to)\n        const cancelContent = this.completeContent((0, _Error.errorFromEvent)((0, _Error.newUnexpectedMessageError)()));\n        return this._sendToDevices(_VerificationRequest.CANCEL_TYPE, cancelContent, [deviceId]);\n      }\n    }\n\n    const wasStarted = request.phase === _VerificationRequest.PHASE_STARTED;\n    await request.handleEvent(event.getType(), event, ToDeviceChannel.getTimestamp(event));\n    const isStarted = request.phase === _VerificationRequest.PHASE_STARTED; // the request has picked a start event, tell the other devices about it\n\n    if (type === _VerificationRequest.START_TYPE && !wasStarted && isStarted && this._deviceId) {\n      const nonChosenDevices = this._devices.filter(d => d !== this._deviceId);\n\n      if (nonChosenDevices.length) {\n        const message = this.completeContent({\n          code: \"m.accepted\",\n          reason: \"Verification request accepted by another device\"\n        });\n        await this._sendToDevices(_VerificationRequest.CANCEL_TYPE, message, nonChosenDevices);\n      }\n    }\n  }\n  /**\n   * See {InRoomChannel.completedContentFromEvent} why this is needed.\n   * @param {MatrixEvent} event the received event\n   * @returns {Object} the content object\n   */\n\n\n  completedContentFromEvent(event) {\n    return event.getContent();\n  }\n  /**\n   * Add all the fields to content needed for sending it over this channel.\n   * This is public so verification methods (SAS uses this) can get the exact\n   * content that will be sent independent of the used channel,\n   * as they need to calculate the hash of it.\n   * @param {string} type the event type\n   * @param {object} content the (incomplete) content\n   * @returns {object} the complete content, as it will be sent.\n   */\n\n\n  completeContent(type, content) {\n    // make a copy\n    content = Object.assign({}, content);\n\n    if (this.transactionId) {\n      content.transaction_id = this.transactionId;\n    }\n\n    if (type === _VerificationRequest.REQUEST_TYPE || type === _VerificationRequest.START_TYPE) {\n      content.from_device = this._client.getDeviceId();\n    }\n\n    if (type === _VerificationRequest.REQUEST_TYPE) {\n      content.timestamp = Date.now();\n    }\n\n    return content;\n  }\n  /**\n   * Send an event over the channel with the content not having gone through `completeContent`.\n   * @param {string} type the event type\n   * @param {object} uncompletedContent the (incomplete) content\n   * @returns {Promise} the promise of the request\n   */\n\n\n  send(type, uncompletedContent = {}) {\n    // create transaction id when sending request\n    if ((type === _VerificationRequest.REQUEST_TYPE || type === _VerificationRequest.START_TYPE) && !this.transactionId) {\n      this.transactionId = ToDeviceChannel.makeTransactionId();\n    }\n\n    const content = this.completeContent(type, uncompletedContent);\n    return this.sendCompleted(type, content);\n  }\n  /**\n   * Send an event over the channel with the content having gone through `completeContent` already.\n   * @param {string} type the event type\n   * @param {object} content\n   * @returns {Promise} the promise of the request\n   */\n\n\n  sendCompleted(type, content) {\n    if (type === _VerificationRequest.REQUEST_TYPE) {\n      return this._sendToDevices(type, content, this._devices);\n    } else {\n      return this._sendToDevices(type, content, [this._deviceId]);\n    }\n  }\n\n  _sendToDevices(type, content, devices) {\n    if (devices.length) {\n      const msgMap = {};\n\n      for (const deviceId of devices) {\n        msgMap[deviceId] = content;\n      }\n\n      return this._client.sendToDevice(type, {\n        [this._userId]: msgMap\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n  /**\n   * Allow Crypto module to create and know the transaction id before the .start event gets sent.\n   * @returns {string} the transaction id\n   */\n\n\n  static makeTransactionId() {\n    return (0, _randomstring.randomString)(32);\n  }\n\n}\n\nexports.ToDeviceChannel = ToDeviceChannel;"]},"metadata":{},"sourceType":"script"}